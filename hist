diff --git a/.mvn/wrapper/maven-wrapper.jar b/.mvn/wrapper/maven-wrapper.jar
deleted file mode 100755
index 01e67997..00000000
Binary files a/.mvn/wrapper/maven-wrapper.jar and /dev/null differ
diff --git a/.mvn/wrapper/maven-wrapper.properties b/.mvn/wrapper/maven-wrapper.properties
index 924dda47..195dc330 100755
--- a/.mvn/wrapper/maven-wrapper.properties
+++ b/.mvn/wrapper/maven-wrapper.properties
@@ -1,2 +1,2 @@
-#Mon Oct 11 14:30:33 CEST 2021
-distributionUrl=https\://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.8.3/apache-maven-3.8.3-bin.zip
+#Tue Feb 22 13:59:13 CET 2022
+distributionUrl=https\://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.8.4/apache-maven-3.8.4-bin.zip
diff --git a/Jenkinsfile b/Jenkinsfile
index 2dd7593d..8bff7fe0 100644
--- a/Jenkinsfile
+++ b/Jenkinsfile
@@ -1,3 +1,9 @@
+def p = [:]
+node {
+    checkout scm
+    p = readProperties interpolate: true, file: 'ci/pipeline.properties'
+}
+
 pipeline {
 	agent none
 
@@ -12,7 +18,7 @@ pipeline {
 	}
 
 	stages {
-		stage("test: baseline (jdk8)") {
+		stage("test: baseline (main)") {
 			when {
 				anyOf {
 					branch 'main'
@@ -25,14 +31,14 @@ pipeline {
 			options { timeout(time: 30, unit: 'MINUTES') }
 
 			environment {
-				DOCKER_HUB = credentials('hub.docker.com-springbuildmaster')
-				ARTIFACTORY = credentials('02bd1690-b54f-4c9f-819d-a77cb7a9822c')
+				DOCKER_HUB = credentials("${p['docker.credentials']}")
+				ARTIFACTORY = credentials("${p['artifactory.credentials']}")
 			}
 
 			steps {
 				script {
-					docker.withRegistry('', 'hub.docker.com-springbuildmaster') {
-						docker.image('adoptopenjdk/openjdk8:latest').inside('-u root -v /var/run/docker.sock:/var/run/docker.sock -v /usr/bin/docker:/usr/bin/docker -v $HOME:/tmp/jenkins-home') {
+					docker.withRegistry(p['docker.registry'], p['docker.credentials']) {
+						docker.image(p['docker.java.main.image']).inside(p['docker.java.inside.docker']) {
 							sh "docker login --username ${DOCKER_HUB_USR} --password ${DOCKER_HUB_PSW}"
 							sh 'PROFILE=ci ci/test.sh'
 							sh "ci/clean.sh"
@@ -50,23 +56,23 @@ pipeline {
 				}
 			}
 			parallel {
-				stage("test: baseline (jdk11)") {
+				stage("test: baseline (next)") {
 					agent {
 						label 'data'
 					}
 					options { timeout(time: 30, unit: 'MINUTES') }
 
 					environment {
-						DOCKER_HUB = credentials('hub.docker.com-springbuildmaster')
-						ARTIFACTORY = credentials('02bd1690-b54f-4c9f-819d-a77cb7a9822c')
+						DOCKER_HUB = credentials("${p['docker.credentials']}")
+						ARTIFACTORY = credentials("${p['artifactory.credentials']}")
 					}
 
 					steps {
 						script {
-							docker.withRegistry('', 'hub.docker.com-springbuildmaster') {
-								docker.image('adoptopenjdk/openjdk11:latest').inside('-u root -v /var/run/docker.sock:/var/run/docker.sock -v /usr/bin/docker:/usr/bin/docker -v $HOME:/tmp/jenkins-home') {
+							docker.withRegistry(p['docker.registry'], p['docker.credentials']) {
+								docker.image(p['docker.java.next.image']).inside(p['docker.java.inside.docker']) {
 									sh "docker login --username ${DOCKER_HUB_USR} --password ${DOCKER_HUB_PSW}"
-									sh 'PROFILE=ci,java11 ci/test.sh'
+									sh 'PROFILE=ci ci/test.sh'
 									sh "ci/clean.sh"
 								}
 							}
@@ -74,23 +80,23 @@ pipeline {
 					}
 				}
 
-				stage("test: baseline (jdk16)") {
+				stage("test: baseline (LTS)") {
 					agent {
 						label 'data'
 					}
 					options { timeout(time: 30, unit: 'MINUTES') }
 
 					environment {
-						DOCKER_HUB = credentials('hub.docker.com-springbuildmaster')
-						ARTIFACTORY = credentials('02bd1690-b54f-4c9f-819d-a77cb7a9822c')
+						DOCKER_HUB = credentials("${p['docker.credentials']}")
+						ARTIFACTORY = credentials("${p['artifactory.credentials']}")
 					}
 
 					steps {
 						script {
-							docker.withRegistry('', 'hub.docker.com-springbuildmaster') {
-								docker.image('adoptopenjdk/openjdk16:latest').inside('-u root -v /var/run/docker.sock:/var/run/docker.sock -v /usr/bin/docker:/usr/bin/docker -v $HOME:/tmp/jenkins-home') {
+							docker.withRegistry(p['docker.registry'], p['docker.credentials']) {
+								docker.image(p['docker.java.lts.image']).inside(p['docker.java.inside.docker']) {
 									sh "docker login --username ${DOCKER_HUB_USR} --password ${DOCKER_HUB_PSW}"
-									sh 'PROFILE=ci,java11 ci/test.sh'
+									sh 'PROFILE=ci ci/test.sh'
 									sh "ci/clean.sh"
 								}
 							}
@@ -113,13 +119,13 @@ pipeline {
 			options { timeout(time: 20, unit: 'MINUTES') }
 
 			environment {
-				ARTIFACTORY = credentials('02bd1690-b54f-4c9f-819d-a77cb7a9822c')
+				ARTIFACTORY = credentials("${p['artifactory.credentials']}")
 			}
 
 			steps {
 				script {
-					docker.withRegistry('', 'hub.docker.com-springbuildmaster') {
-						docker.image('adoptopenjdk/openjdk8:latest').inside('-v $HOME:/tmp/jenkins-home') {
+					docker.withRegistry(p['docker.registry'], p['docker.credentials']) {
+						docker.image(p['docker.java.lts.image']).inside(p['docker.java.inside.basic']) {
 							sh 'MAVEN_OPTS="-Duser.name=jenkins -Duser.home=/tmp/jenkins-home" ./mvnw -s settings.xml -Pci,artifactory -Dmaven.repo.local=/tmp/jenkins-home/.m2/spring-data-couchbase-non-root ' +
 									'-Dartifactory.server=https://repo.spring.io ' +
 									"-Dartifactory.username=${ARTIFACTORY_USR} " +
@@ -133,35 +139,6 @@ pipeline {
 				}
 			}
 		}
-
-		stage('Publish documentation') {
-			when {
-				branch 'main'
-			}
-			agent {
-				label 'data'
-			}
-			options { timeout(time: 20, unit: 'MINUTES') }
-
-			environment {
-				ARTIFACTORY = credentials('02bd1690-b54f-4c9f-819d-a77cb7a9822c')
-			}
-
-			steps {
-				script {
-					docker.withRegistry('', 'hub.docker.com-springbuildmaster') {
-						docker.image('adoptopenjdk/openjdk8:latest').inside('-v $HOME:/tmp/jenkins-home') {
-							sh 'MAVEN_OPTS="-Duser.name=jenkins -Duser.home=/tmp/jenkins-home" ./mvnw -s settings.xml -Pci,distribute -Dmaven.repo.local=/tmp/jenkins-home/.m2/spring-data-couchbase-non-root ' +
-									'-Dartifactory.server=https://repo.spring.io ' +
-									"-Dartifactory.username=${ARTIFACTORY_USR} " +
-									"-Dartifactory.password=${ARTIFACTORY_PSW} " +
-									"-Dartifactory.distribution-repository=temp-private-local " +
-									'-Dmaven.test.skip=true clean deploy -U -B'
-						}
-					}
-				}
-			}
-		}
 	}
 
 	post {
diff --git a/ci/pipeline.properties b/ci/pipeline.properties
new file mode 100644
index 00000000..f3c84e05
--- /dev/null
+++ b/ci/pipeline.properties
@@ -0,0 +1,29 @@
+# Java versions
+java.main.tag=8u322-b06-jdk
+java.next.tag=11.0.14.1_1-jdk
+java.lts.tag=17.0.2_8-jdk
+
+# Docker container images - standard
+docker.java.main.image=harbor-repo.vmware.com/dockerhub-proxy-cache/library/eclipse-temurin:${java.main.tag}
+docker.java.next.image=harbor-repo.vmware.com/dockerhub-proxy-cache/library/eclipse-temurin:${java.next.tag}
+docker.java.lts.image=harbor-repo.vmware.com/dockerhub-proxy-cache/library/eclipse-temurin:${java.lts.tag}
+
+# Supported versions of MongoDB
+docker.mongodb.4.0.version=4.0.28
+docker.mongodb.4.4.version=4.4.12
+docker.mongodb.5.0.version=5.0.6
+
+# Supported versions of Redis
+docker.redis.6.version=6.2.6
+
+# Supported versions of Cassandra
+docker.cassandra.3.version=3.11.12
+
+# Docker environment settings
+docker.java.inside.basic=-v $HOME:/tmp/jenkins-home
+docker.java.inside.docker=-u root -v /var/run/docker.sock:/var/run/docker.sock -v /usr/bin/docker:/usr/bin/docker -v $HOME:/tmp/jenkins-home
+
+# Credentials
+docker.registry=
+docker.credentials=hub.docker.com-springbuildmaster
+artifactory.credentials=02bd1690-b54f-4c9f-819d-a77cb7a9822c
diff --git a/pom.xml b/pom.xml
index 6b51b5d2..2a4ec9bc 100644
--- a/pom.xml
+++ b/pom.xml
@@ -5,7 +5,7 @@
 
     <groupId>org.springframework.data</groupId>
     <artifactId>spring-data-couchbase</artifactId>
-    <version>4.3.0-SNAPSHOT</version>
+    <version>4.4.0-SNAPSHOT</version>
 
     <name>Spring Data Couchbase</name>
     <description>Spring Data integration for Couchbase</description>
@@ -14,13 +14,13 @@
     <parent>
         <groupId>org.springframework.data.build</groupId>
         <artifactId>spring-data-parent</artifactId>
-        <version>2.6.0-SNAPSHOT</version>
+        <version>2.7.0-SNAPSHOT</version>
     </parent>
 
     <properties>
-        <couchbase>3.2.1</couchbase>
-        <couchbase.osgi>3.2.1</couchbase.osgi>
-        <springdata.commons>2.6.0-SNAPSHOT</springdata.commons>
+        <couchbase>3.3.0</couchbase>
+        <couchbase.osgi>3.3.0</couchbase.osgi>
+        <springdata.commons>2.7.0-SNAPSHOT</springdata.commons>
         <java-module-name>spring.data.couchbase</java-module-name>
     </properties>
 
@@ -37,6 +37,7 @@
     </dependencyManagement>
 
     <dependencies>
+
         <dependency>
             <groupId>org.springframework</groupId>
             <artifactId>spring-context-support</artifactId>
@@ -180,7 +181,14 @@
         <dependency>
             <groupId>com.squareup.okhttp3</groupId>
             <artifactId>okhttp</artifactId>
-            <version>4.4.0</version>
+            <version>4.8.1</version>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>com.squareup.okhttp3</groupId>
+            <artifactId>okhttp-tls</artifactId>
+            <version>4.8.1</version>
             <scope>test</scope>
         </dependency>
 
@@ -212,6 +220,18 @@
             <version>4.0.3</version>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>org.testcontainers</groupId>
+            <artifactId>testcontainers</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>ch.qos.logback</groupId>
+            <artifactId>logback-classic</artifactId>
+            <version>1.2.5</version>
+            <scope>compile</scope>
+        </dependency>
+
 
     </dependencies>
 
@@ -230,10 +250,6 @@
                 <enabled>false</enabled>
             </releases>
         </repository>
-        <repository>
-            <id>jitpack.io</id>
-            <url>https://jitpack.io</url>
-        </repository>
     </repositories>
 
     <pluginRepositories>
@@ -265,6 +281,7 @@
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-failsafe-plugin</artifactId>
                 <configuration>
+                    <useModulePath>false</useModulePath>
                     <includes>
                         <include>**/*IntegrationTest.java</include>
                         <include>**/*IntegrationTests.java</include>
diff --git a/src/main/asciidoc/caching.adoc b/src/main/asciidoc/caching.adoc
new file mode 100644
index 00000000..e0bfcfb3
--- /dev/null
+++ b/src/main/asciidoc/caching.adoc
@@ -0,0 +1,57 @@
+[[couchbase.caching]]
+= Caching
+
+This chapter describes additional support for caching and `@Cacheable`.
+
+[[caching.usage]]
+== Configuration & Usage
+
+Technically, caching is not part of spring-data, but is implemented directly in the spring core. Most database implementations in the spring-data package can't support `@Cacheable`, because it is not possible to store arbitrary data.
+
+Couchbase supports both binary and JSON data, so you can get both out of the same database.
+
+To make it work, you need to add the `@EnableCaching` annotation and configure the `cacheManager` bean:
+
+.`AbstractCouchbaseConfiguration` for Caching
+====
+[source,java]
+----
+
+@Configuration
+@EnableCaching
+public class Config extends AbstractCouchbaseConfiguration {
+    // general methods
+
+    @Bean
+    public CouchbaseCacheManager cacheManager(CouchbaseTemplate couchbaseTemplate) throws Exception {
+        CouchbaseCacheManager.CouchbaseCacheManagerBuilder builder = CouchbaseCacheManager.CouchbaseCacheManagerBuilder
+                .fromConnectionFactory(couchbaseTemplate.getCouchbaseClientFactory());
+            return builder.build();
+        }
+
+----
+====
+
+The `persistent` identifier can then be used on the `@Cacheable` annotation to identify the cache manager to use (you can have more than one configured).
+
+Once it is set up, you can annotate every method with the `@Cacheable` annotation to transparently cache it in your couchbase bucket. You can also customize how the key is generated.
+
+.Caching example
+====
+[source,java]
+----
+@Cacheable(value="persistent", key="'longrunsim-'+#time")
+public String simulateLongRun(long time) {
+    try {
+        Thread.sleep(time);
+    } catch(Exception ex) {
+        System.out.println("This shouldnt happen...");
+    }
+    return "I've slept " + time + " miliseconds.;
+}
+----
+====
+
+If you run the method multiple times, you'll see a set operation happening first, followed by multiple get operations and no sleep time (which fakes the expensive execution). You can store whatever you want, if it is JSON of course you can access it through views and look at it in the Web UI.
+
+Note that to use cache.clear() or catch.invalidate(), the bucket must have a primary key.
diff --git a/src/main/asciidoc/collections.adoc b/src/main/asciidoc/collections.adoc
new file mode 100644
index 00000000..d6fbf18d
--- /dev/null
+++ b/src/main/asciidoc/collections.adoc
@@ -0,0 +1,80 @@
+[[couchbase.collections]]
+= Collection Support
+
+Couchbase supports https://docs.couchbase.com/server/current/learn/data/scopes-and-collections.html[Scopes and Collections]. This section documents on how to use it with Spring Data Couchbase.
+
+The https://github.com/couchbaselabs/try-cb-spring[try-cb-spring] sample application is a working example of using Scopes and Collections in Spring Data Couchbase.
+
+The 2021 Couchbase Connect presentation on Collections in Spring Data can be found at https://www.youtube.com/watch?v=MrplTeEFItk[Presentation Only] and https://web.cvent.com/hub/events/1dce8283-986d-4de9-8368-94c98f60df01/sessions/9ee89a85-833c-4e0c-81b0-807864fa351b?goBackHref=%2Fevents%2F1dce8283-986d-4de9-8368-94c98f60df01%2Fsessions&goBackName=Add%2FView+Sessions&goBackTab=all[Presentation with Slide Deck]
+
+== Requirements
+
+ - Couchbase Server 7.0 or above.
+ - Spring Data Couchbase 4.3.1 or above.
+
+== Getting Started & Configuration
+
+
+=== Scope and Collection Specification
+There are several mechanisms of specifying scopes and collections, and these may be combined, or one mechanism may override another. 
+First some definitions for scopes and collections. An unspecified scope indicates that the default scope is to be used, likewise, an 
+unspecified collection indicates that the default collection is to be used.
+There are only three combinations of scopes and collections that are valid. (1) the default scope and the default collection; (2) the default
+scope and a non-default collection; and (3) a non-default scope and a non-default collection. It is not possible to have a non-default 
+scope and a default collection as non-default scopes do not contain a default collections, neither can one be created.
+
+A scope can be specified in the configuration:
+[source,java]
+----
+@Configuration
+static class Config extends AbstractCouchbaseConfiguration {
+
+    // Usual Setup
+    @Override public String getConnectionString() { /* ... */ }
+
+    // optionally specify the scope in the Configuration
+    @Override
+    protected String getScopeName() {
+        return "myScope"; // or a variable etc.;
+    }
+
+}
+----
+Scopes and Collections can be specified as annotations on entity classes and repositories:
+[source,java]
+----
+@Document
+@Scope("travel")
+@Collection("airport")
+public class Airport {...
+----
+
+[source,java]
+----
+@Scope("travel")
+@Collection("airport")
+public interface AirportRepository extends CouchbaseRepository<Airport, String> ...
+----
+
+Scopes and Collections can be specified on templates using the inScope(scopeName) and inCollection(collectionName) fluent APIs:
+[source,java]
+----
+List<Airport> airports = template.findByQuery(Airport.class).inScope("archived").all()
+----
+
+Scopes and Collections can be specified on repositories that extend DynamicProxyable using the withScope(scopeName) and withCollection(collectionName) APIs:
+[source,java]
+----
+public interface AirportRepository extends CouchbaseRepository<Airport, String>, DynamicProxyable<AirportRepository>{...}
+...
+List<Airport> airports = airportRepository.withScope("archived").findByName(iata);  
+----
+
+.The order of precedence is:
+. inScope()/inCollection() of the template fluent api
+. withScope()/withCollection() of the template/repository object
+. annotation of the repository method
+. annotation of the repository interface
+. annotation of the entity object
+. getScope() of the configuration
+
diff --git a/src/main/asciidoc/index.adoc b/src/main/asciidoc/index.adoc
index 1294b2d1..96f910bd 100644
--- a/src/main/asciidoc/index.adoc
+++ b/src/main/asciidoc/index.adoc
@@ -1,10 +1,10 @@
 = Spring Data Couchbase - Reference Documentation
-Michael Nitschinger, Oliver Gierke, Simon Baslé
+Michael Nitschinger, Oliver Gierke, Simon Baslé, Michael Reiche
 :revnumber: {version}
 :revdate: {localdate}
 :spring-data-commons-docs: ../../../../spring-data-commons/src/main/asciidoc
 
-(C) 2014-2019 The original author(s).
+(C) 2014-2022 The original author(s).
 
 NOTE: Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.
 
@@ -24,8 +24,9 @@ include::repository.adoc[]
 include::reactiverepository.adoc[]
 include::template.adoc[]
 include::transactions.adoc[]
-// (daschl) disabled the ansijoins docs since it is being overhauled for 4.x
-// include::ansijoins.adoc[]
+include::collections.adoc[]
+include::ansijoins.adoc[]
+include::caching.adoc[]
 :leveloffset: -1
 
 [[appendix]]
diff --git a/src/main/java/com/couchbase/client/java/Cluster.java b/src/main/java/com/couchbase/client/java/Cluster.java
new file mode 100644
index 00000000..23c58803
--- /dev/null
+++ b/src/main/java/com/couchbase/client/java/Cluster.java
@@ -0,0 +1,589 @@
+/*
+ * Copyright (c) 2018 Couchbase, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.couchbase.client.java;
+
+import com.couchbase.client.core.Core;
+import com.couchbase.client.core.diagnostics.ClusterState;
+import com.couchbase.client.core.diagnostics.DiagnosticsResult;
+import com.couchbase.client.core.annotation.Stability;
+import com.couchbase.client.core.diagnostics.PingResult;
+import com.couchbase.client.core.env.Authenticator;
+import com.couchbase.client.core.env.PasswordAuthenticator;
+import com.couchbase.client.core.env.SeedNode;
+import com.couchbase.client.core.error.CouchbaseException;
+import com.couchbase.client.core.error.TimeoutException;
+import com.couchbase.client.core.msg.search.SearchRequest;
+import com.couchbase.client.java.analytics.AnalyticsOptions;
+import com.couchbase.client.java.analytics.AnalyticsResult;
+import com.couchbase.client.java.diagnostics.DiagnosticsOptions;
+import com.couchbase.client.java.diagnostics.PingOptions;
+import com.couchbase.client.java.diagnostics.WaitUntilReadyOptions;
+import com.couchbase.client.java.env.ClusterEnvironment;
+import com.couchbase.client.java.manager.analytics.AnalyticsIndexManager;
+import com.couchbase.client.java.manager.bucket.BucketManager;
+import com.couchbase.client.java.manager.eventing.EventingFunctionManager;
+import com.couchbase.client.java.manager.query.QueryIndexManager;
+import com.couchbase.client.java.manager.search.SearchIndexManager;
+import com.couchbase.client.java.manager.user.UserManager;
+import com.couchbase.client.java.query.QueryOptions;
+import com.couchbase.client.java.query.QueryResult;
+import com.couchbase.client.java.search.SearchOptions;
+import com.couchbase.client.java.search.SearchQuery;
+import com.couchbase.client.java.search.result.SearchResult;
+import com.couchbase.client.java.transactions.Transactions;
+
+import java.time.Duration;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.function.Supplier;
+
+import static com.couchbase.client.core.util.Validators.notNull;
+import static com.couchbase.client.core.util.Validators.notNullOrEmpty;
+import static com.couchbase.client.java.AsyncCluster.extractClusterEnvironment;
+import static com.couchbase.client.java.AsyncCluster.seedNodesFromConnectionString;
+import static com.couchbase.client.java.AsyncUtils.block;
+import static com.couchbase.client.java.ClusterOptions.clusterOptions;
+import static com.couchbase.client.java.ReactiveCluster.DEFAULT_ANALYTICS_OPTIONS;
+import static com.couchbase.client.java.ReactiveCluster.DEFAULT_DIAGNOSTICS_OPTIONS;
+import static com.couchbase.client.java.ReactiveCluster.DEFAULT_QUERY_OPTIONS;
+import static com.couchbase.client.java.ReactiveCluster.DEFAULT_SEARCH_OPTIONS;
+
+/**
+ * The {@link Cluster} is the main entry point when connecting to a Couchbase cluster.
+ * <p>
+ * Most likely you want to start out by using the {@link #connect(String, String, String)} entry point. For more
+ * advanced options you want to use the {@link #connect(String, ClusterOptions)} method. The entry point that allows
+ * overriding the seed nodes ({@link #connect(Set, ClusterOptions)} is only needed if you run a couchbase cluster
+ * at non-standard ports.
+ * <p>
+ * See the individual connect methods for more information, but here is a snippet to get you off the ground quickly. It
+ * assumes you have Couchbase running locally and the "travel-sample" sample bucket loaded:
+ * <pre>
+ * //Connect and open a bucket
+ * Cluster cluster = Cluster.connect("127.0.0.1","Administrator","password");
+ * Bucket bucket = cluster.bucket("travel-sample");
+ * Collection collection = bucket.defaultCollection();
+ *
+ * // Perform a N1QL query
+ * QueryResult queryResult = cluster.query("select * from `travel-sample` limit 5");
+ * System.out.println(queryResult.rowsAsObject());
+ *
+ * // Perform a KV request and load a document
+ * GetResult getResult = collection.get("airline_10");
+ * System.out.println(getResult);
+ * </pre>
+ * <p>
+ * When the application shuts down (or the SDK is not needed anymore), you are required to call {@link #disconnect()}.
+ * If you omit this step, the application will terminate (all spawned threads are daemon threads) but any operations
+ * or work in-flight will not be able to complete and lead to undesired side-effects. Note that disconnect will also
+ * shutdown all associated {@link Bucket buckets}.
+ * <p>
+ * Cluster-level operations like {@link #query(String)} will not work unless at leas one bucket is opened against a
+ * pre 6.5 cluster. If you are using 6.5 or later, you can run cluster-level queries without opening a bucket. All
+ * of these operations are lazy, so the SDK will bootstrap in the background and service queries as quickly as possible.
+ * This also means that the first operations might be a bit slower until all sockets are opened in the background and
+ * the configuration is loaded. If you want to wait explicitly, you can utilize the {@link #waitUntilReady(Duration)}
+ * method before performing your first query.
+ * <p>
+ * The SDK will only work against Couchbase Server 5.0 and later, because RBAC (role-based access control) is a first
+ * class concept since 3.0 and therefore required.
+ */
+// todo gpx as per discussion with miker - if required, ClusterInterface will be added to the SDK instead
+public class Cluster implements ClusterInterface {
+
+  /**
+   * Holds the underlying async cluster reference.
+   */
+  private final AsyncCluster asyncCluster;
+
+  /**
+   * Holds the adjacent reactive cluster reference.
+   */
+  private final ReactiveCluster reactiveCluster;
+
+  /**
+   * The search index manager manages search indexes.
+   */
+  private final SearchIndexManager searchIndexManager;
+
+  /**
+   * The user manager manages users and groups.
+   */
+  private final UserManager userManager;
+
+  /**
+   * The bucket manager manages buckets and allows to flush them.
+   */
+  private final BucketManager bucketManager;
+
+  /**
+   * Allows to manage query indexes.
+   */
+  private final QueryIndexManager queryIndexManager;
+
+  /**
+   * Allows to manage analytics indexes.
+   */
+  private final AnalyticsIndexManager analyticsIndexManager;
+
+  /**
+   * Allows to manage eventing functions.
+   */
+  private final EventingFunctionManager eventingFunctionManager;
+
+  /**
+   * Stores already opened buckets for reuse.
+   */
+  private final Map<String, Bucket> bucketCache = new ConcurrentHashMap<>();
+
+  /**
+   * Connect to a Couchbase cluster with a username and a password as credentials.
+   * <p>
+   * This is the simplest (and recommended) method to connect to the cluster if you do not need to provide any
+   * custom options.
+   * <p>
+   * The first argument (the connection string in its simplest form) is used to supply the hostnames of the cluster. In
+   * development it is OK to only pass in one hostname (or IP address), but in production we recommend passing in at
+   * least 3 nodes of the cluster (comma separated). The reason is that if one or more of the nodes are not reachable
+   * the client will still be able to bootstrap (and your application will become more resilient as a result).
+   * <p>
+   * Here is how you specify one node to use for bootstrapping:
+   * <pre>
+   * Cluster cluster = Cluster.connect("127.0.0.1", "user", "password"); // ok during development
+   * </pre>
+   * This is what we recommend in production:
+   * <pre>
+   * Cluster cluster = Cluster.connect("host1,host2,host3", "user", "password"); // recommended in production
+   * </pre>
+   * It is important to understand that the SDK will only use the bootstrap ("seed nodes") host list to establish an
+   * initial contact with the cluster. Once the configuration is loaded this list is discarded and the client will
+   * connect to all nodes based on this configuration.
+   * <p>
+   * This method will return immediately and the SDK will try to establish all the necessary resources and connections
+   * in the background. This means that depending on how fast it can be bootstrapped, the first couple cluster-level
+   * operations like {@link #query(String)} will take a bit longer. If you want to wait explicitly until those resources
+   * are available, you can use the {@link #waitUntilReady(Duration)} method before running any of them:
+   * <pre>
+   * Cluster cluster = Cluster.connect("host1,host2,host3", "user", "password");
+   * cluster.waitUntilReady(Duration.ofSeconds(5));
+   * QueryResult result = cluster.query("select * from bucket limit 1");
+   * </pre>
+   *
+   * @param connectionString connection string used to locate the Couchbase cluster.
+   * @param username the name of the user with appropriate permissions on the cluster.
+   * @param password the password of the user with appropriate permissions on the cluster.
+   * @return the instantiated {@link Cluster}.
+   */
+  public static Cluster connect(final String connectionString, final String username, final String password) {
+    return connect(connectionString, clusterOptions(PasswordAuthenticator.create(username, password)));
+  }
+
+  /**
+   * Connect to a Couchbase cluster with custom options.
+   * <p>
+   * You likely want to use this over the simpler {@link #connect(String, String, String)} if:
+   * <ul>
+   *   <li>A custom {@link ClusterEnvironment}</li>
+   *   <li>Or a custom {@link Authenticator}</li>
+   * </ul>
+   * needs to be provided.
+   * <p>
+   * A custom environment can be passed in like this:
+   * <pre>
+   * // on bootstrap:
+   * ClusterEnvironment environment = ClusterEnvironment.builder().build();
+   * Cluster cluster = Cluster.connect(
+   *   "127.0.0.1",
+   *   clusterOptions("user", "password").environment(environment)
+   * );
+   *
+   * // on shutdown:
+   * cluster.disconnect();
+   * environment.shutdown();
+   * </pre>
+   * It is <strong>VERY</strong> important to shut down the environment when being passed in separately (as shown in
+   * the code sample above) and <strong>AFTER</strong> the cluster is disconnected. This will ensure an orderly shutdown
+   * and makes sure that no resources are left lingering.
+   * <p>
+   * If you want to pass in a custom {@link Authenticator}, it is likely because you are setting up certificate-based
+   * authentication instead of using a username and a password directly. Remember to also enable TLS.
+   * <pre>
+   * ClusterEnvironment environment = ClusterEnvironment
+   *   .builder()
+   *   .securityConfig(SecurityConfig.enableTls(true))
+   *   .build();
+   *
+   * Authenticator authenticator = CertificateAuthenticator.fromKey(...);
+   *
+   * Cluster cluster = Cluster.connect(
+   *   "127.0.0.1",
+   *   clusterOptions(authenticator).environment(environment)
+   * );
+   * </pre>
+   * This method will return immediately and the SDK will try to establish all the necessary resources and connections
+   * in the background. This means that depending on how fast it can be bootstrapped, the first couple cluster-level
+   * operations like {@link #query(String)} will take a bit longer. If you want to wait explicitly until those resources
+   * are available, you can use the {@link #waitUntilReady(Duration)} method before running any of them:
+   * <pre>
+   * Cluster cluster = Cluster.connect("host1,host2,host3", "user", "password");
+   * cluster.waitUntilReady(Duration.ofSeconds(5));
+   * QueryResult result = cluster.query("select * from bucket limit 1");
+   * </pre>
+   *
+   * @param connectionString connection string used to locate the Couchbase cluster.
+   * @param options custom options when creating the cluster.
+   * @return the instantiated {@link Cluster}.
+   */
+  public static Cluster connect(final String connectionString, final ClusterOptions options) {
+    notNullOrEmpty(connectionString, "ConnectionString");
+    notNull(options, "ClusterOptions");
+
+    final ClusterOptions.Built opts = options.build();
+    final Supplier<ClusterEnvironment> environmentSupplier = extractClusterEnvironment(connectionString, opts);
+    return new Cluster(
+            environmentSupplier,
+            opts.authenticator(),
+            seedNodesFromConnectionString(connectionString, environmentSupplier.get())
+    );
+  }
+
+  /**
+   * Connect to a Couchbase cluster with a list of seed nodes and custom options.
+   * <p>
+   * Note that you likely only want to use this method if you need to pass in custom ports for specific seed nodes
+   * during bootstrap. Otherwise we recommend relying on the simpler {@link #connect(String, String, String)} method
+   * instead.
+   * <p>
+   * The following example shows how to bootstrap against a node with custom KV and management ports:
+   * <pre>
+   * Set<SeedNode> seedNodes = new HashSet<>(Collections.singletonList(
+   *   SeedNode.create("127.0.0.1", Optional.of(12000), Optional.of(9000))
+   * ));
+   * Cluster cluster Cluster.connect(seedNodes, clusterOptions("user", "password"));
+   * </pre>
+   * @param seedNodes the seed nodes used to connect to the cluster.
+   * @param options custom options when creating the cluster.
+   * @return the instantiated {@link Cluster}.
+   */
+  public static Cluster connect(final Set<SeedNode> seedNodes, final ClusterOptions options) {
+    notNullOrEmpty(seedNodes, "SeedNodes");
+    notNull(options, "ClusterOptions");
+
+    final ClusterOptions.Built opts = options.build();
+    return new Cluster(extractClusterEnvironment("", opts), opts.authenticator(), seedNodes);
+  }
+
+  /**
+   * Creates a new cluster from a {@link ClusterEnvironment}.
+   *
+   * @param environment the environment to use.
+   * @param authenticator the authenticator to use.
+   * @param seedNodes the seed nodes to bootstrap from.
+   */
+  private Cluster(final Supplier<ClusterEnvironment> environment, final Authenticator authenticator,
+                  final Set<SeedNode> seedNodes) {
+    this.asyncCluster = new AsyncCluster(environment, authenticator, seedNodes);
+    this.reactiveCluster = new ReactiveCluster(asyncCluster);
+    this.searchIndexManager = new SearchIndexManager(asyncCluster.searchIndexes());
+    this.userManager = new UserManager(asyncCluster.users());
+    this.bucketManager = new BucketManager(asyncCluster.buckets());
+    this.queryIndexManager = new QueryIndexManager(asyncCluster.queryIndexes());
+    this.analyticsIndexManager = new AnalyticsIndexManager(this);
+    this.eventingFunctionManager = new EventingFunctionManager(asyncCluster.eventingFunctions());
+  }
+
+  /**
+   * Provides access to the related {@link AsyncCluster}.
+   * <p>
+   * Note that the {@link AsyncCluster} is considered advanced API and should only be used to get the last drop
+   * of performance or if you are building higher-level abstractions on top. If in doubt, we recommend using the
+   * {@link #reactive()} API instead.
+   */
+  public AsyncCluster async() {
+    return asyncCluster;
+  }
+
+  /**
+   * Provides access to the related {@link ReactiveCluster}.
+   */
+  public ReactiveCluster reactive() {
+    return reactiveCluster;
+  }
+
+  /**
+   * Provides access to the underlying {@link Core}.
+   *
+   * <p>This is advanced and volatile API - it might change any time without notice. <strong>Use with care!</strong></p>
+   */
+  @Stability.Volatile
+  public Core core() {
+    return asyncCluster.core();
+  }
+
+  /**
+   * The user manager allows to manage users and groups.
+   */
+  public UserManager users() {
+    return userManager;
+  }
+
+  /**
+   * The bucket manager allows to perform administrative tasks on buckets and their resources.
+   */
+  public BucketManager buckets() {
+    return bucketManager;
+  }
+
+  /**
+   * The analytics index manager allows to modify and create indexes for the analytics service.
+   */
+  public AnalyticsIndexManager analyticsIndexes() {
+    return analyticsIndexManager;
+  }
+
+  /**
+   * The query index manager allows to modify and create indexes for the query service.
+   */
+  public QueryIndexManager queryIndexes() {
+    return queryIndexManager;
+  }
+
+  /**
+   * The search index manager allows to modify and create indexes for the search service.
+   */
+  public SearchIndexManager searchIndexes() {
+    return searchIndexManager;
+  }
+
+  /**
+   * Provides access to the eventing function management services.
+   */
+  @Stability.Uncommitted
+  public EventingFunctionManager eventingFunctions() {
+    return eventingFunctionManager;
+  }
+
+  /**
+   * Provides access to the used {@link ClusterEnvironment}.
+   */
+  public ClusterEnvironment environment() {
+    return asyncCluster.environment();
+  }
+
+  /**
+   * Performs a query against the query (N1QL) services.
+   *
+   * @param statement the N1QL query statement.
+   * @return the {@link QueryResult} once the response arrives successfully.
+   * @throws TimeoutException if the operation times out before getting a result.
+   * @throws CouchbaseException for all other error reasons (acts as a base type and catch-all).
+   */
+  public QueryResult query(final String statement) {
+    return query(statement, DEFAULT_QUERY_OPTIONS);
+  }
+
+  /**
+   * Performs a query against the query (N1QL) services with custom options.
+   *
+   * @param statement the N1QL query statement as a raw string.
+   * @param options the custom options for this query.
+   * @return the {@link QueryResult} once the response arrives successfully.
+   * @throws TimeoutException if the operation times out before getting a result.
+   * @throws CouchbaseException for all other error reasons (acts as a base type and catch-all).
+   */
+  public QueryResult query(final String statement, final QueryOptions options) {
+    return block(async().query(statement, options));
+  }
+
+  /**
+   * Performs an analytics query with default {@link AnalyticsOptions}.
+   *
+   * @param statement the query statement as a raw string.
+   * @return the {@link AnalyticsResult} once the response arrives successfully.
+   * @throws TimeoutException if the operation times out before getting a result.
+   * @throws CouchbaseException for all other error reasons (acts as a base type and catch-all).
+   */
+  public AnalyticsResult analyticsQuery(final String statement) {
+    return analyticsQuery(statement, DEFAULT_ANALYTICS_OPTIONS);
+  }
+
+  /**
+   * Performs an analytics query with custom {@link AnalyticsOptions}.
+   *
+   * @param statement the query statement as a raw string.
+   * @param options the custom options for this query.
+   * @return the {@link AnalyticsResult} once the response arrives successfully.
+   * @throws TimeoutException if the operation times out before getting a result.
+   * @throws CouchbaseException for all other error reasons (acts as a base type and catch-all).
+   */
+  public AnalyticsResult analyticsQuery(final String statement, final AnalyticsOptions options) {
+    return block(async().analyticsQuery(statement, options));
+  }
+
+  /**
+   * Performs a Full Text Search (FTS) query with default {@link SearchOptions}.
+   *
+   * @param query the query, in the form of a {@link SearchQuery}
+   * @return the {@link SearchRequest} once the response arrives successfully.
+   * @throws TimeoutException if the operation times out before getting a result.
+   * @throws CouchbaseException for all other error reasons (acts as a base type and catch-all).
+   */
+  public SearchResult searchQuery(final String indexName, final SearchQuery query) {
+    return searchQuery(indexName, query, DEFAULT_SEARCH_OPTIONS);
+  }
+
+  /**
+   * Performs a Full Text Search (FTS) query with custom {@link SearchOptions}.
+   *
+   * @param query the query, in the form of a {@link SearchQuery}
+   * @param options the custom options for this query.
+   * @return the {@link SearchRequest} once the response arrives successfully.
+   * @throws TimeoutException if the operation times out before getting a result.
+   * @throws CouchbaseException for all other error reasons (acts as a base type and catch-all).
+   */
+  public SearchResult searchQuery(final String indexName, final SearchQuery query, final SearchOptions options) {
+    return block(asyncCluster.searchQuery(indexName, query, options));
+  }
+
+  /**
+   * Opens a {@link Bucket} with the given name.
+   *
+   * @param bucketName the name of the bucket to open.
+   * @return a {@link Bucket} once opened.
+   */
+  public Bucket bucket(final String bucketName) {
+    return bucketCache.computeIfAbsent(bucketName, n -> new Bucket(asyncCluster.bucket(n)));
+  }
+
+  /**
+   * Performs a non-reversible disconnect of this {@link Cluster}.
+   * <p>
+   * If this method is used, the default disconnect timeout on the environment is used. Please use the companion
+   * overload ({@link #disconnect(Duration)} if you want to provide a custom duration.
+   * <p>
+   * If a custom {@link ClusterEnvironment} has been passed in during connect, it is <strong>VERY</strong> important to
+   * shut it down after calling this method. This will prevent any in-flight tasks to be stopped prematurely.
+   */
+  public void disconnect() {
+    block(asyncCluster.disconnect());
+  }
+
+  /**
+   * Performs a non-reversible disconnect of this {@link Cluster}.
+   * <p>
+   * If a custom {@link ClusterEnvironment} has been passed in during connect, it is <strong>VERY</strong> important to
+   * shut it down after calling this method. This will prevent any in-flight tasks to be stopped prematurely.
+   *
+   * @param timeout allows to override the default disconnect duration.
+   */
+  public void disconnect(final Duration timeout) {
+    block(asyncCluster.disconnect(timeout));
+  }
+
+  /**
+   * Runs a diagnostic report on the current state of the cluster from the SDKs point of view.
+   * <p>
+   * Please note that it does not perform any I/O to do this, it will only use the current known state of the cluster
+   * to assemble the report (so, if for example no N1QL query has been run the socket pool might be empty and as
+   * result not show up in the report).
+   *
+   * @return the {@link DiagnosticsResult} once complete.
+   */
+  public DiagnosticsResult diagnostics() {
+    return block(asyncCluster.diagnostics(DEFAULT_DIAGNOSTICS_OPTIONS));
+  }
+
+  /**
+   * Runs a diagnostic report with custom options on the current state of the cluster from the SDKs point of view.
+   * <p>
+   * Please note that it does not perform any I/O to do this, it will only use the current known state of the cluster
+   * to assemble the report (so, if for example no N1QL query has been run the socket pool might be empty and as
+   * result not show up in the report).
+   *
+   * @param options options that allow to customize the report.
+   * @return the {@link DiagnosticsResult} once complete.
+   */
+  public DiagnosticsResult diagnostics(final DiagnosticsOptions options) {
+    return block(asyncCluster.diagnostics(options));
+  }
+
+  /**
+   * Performs application-level ping requests against services in the couchbase cluster.
+   * <p>
+   * Note that this operation performs active I/O against services and endpoints to assess their health. If you do
+   * not wish to perform I/O, consider using the {@link #diagnostics()} instead. You can also combine the functionality
+   * of both APIs as needed, which is {@link #waitUntilReady(Duration)} is doing in its implementation as well.
+   *
+   * @return the {@link PingResult} once complete.
+   */
+  public PingResult ping() {
+    return block(asyncCluster.ping());
+  }
+
+  /**
+   * Performs application-level ping requests with custom options against services in the couchbase cluster.
+   * <p>
+   * Note that this operation performs active I/O against services and endpoints to assess their health. If you do
+   * not wish to perform I/O, consider using the {@link #diagnostics(DiagnosticsOptions)} instead. You can also combine
+   * the functionality of both APIs as needed, which is {@link #waitUntilReady(Duration)} is doing in its
+   * implementation as well.
+   *
+   * @return the {@link PingResult} once complete.
+   */
+  public PingResult ping(final PingOptions options) {
+    return block(asyncCluster.ping(options));
+  }
+
+  /**
+   * Waits until the desired {@link ClusterState} is reached.
+   * <p>
+   * This method will wait until either the cluster state is "online", or the timeout is reached. Since the SDK is
+   * bootstrapping lazily, this method allows to eagerly check during bootstrap if all of the services are online
+   * and usable before moving on.
+   *
+   * @param timeout the maximum time to wait until readiness.
+   */
+  public void waitUntilReady(final Duration timeout) {
+    block(asyncCluster.waitUntilReady(timeout));
+  }
+
+  /**
+   * Waits until the desired {@link ClusterState} is reached.
+   * <p>
+   * This method will wait until either the cluster state is "online" by default, or the timeout is reached. Since the
+   * SDK is bootstrapping lazily, this method allows to eagerly check during bootstrap if all of the services are online
+   * and usable before moving on. You can tune the properties through {@link WaitUntilReadyOptions}.
+   *
+   * @param timeout the maximum time to wait until readiness.
+   * @param options the options to customize the readiness waiting.
+   */
+  public void waitUntilReady(final Duration timeout, final WaitUntilReadyOptions options) {
+    block(asyncCluster.waitUntilReady(timeout, options));
+  }
+
+  /**
+   * Allows access to transactions.
+   *
+   * @return the {@link Transactions} interface.
+   */
+  @Stability.Uncommitted
+  public Transactions transactions() {
+    return new Transactions(core(), environment().jsonSerializer());
+  }
+}
+
diff --git a/src/main/java/com/couchbase/client/java/ClusterInterface.java b/src/main/java/com/couchbase/client/java/ClusterInterface.java
new file mode 100644
index 00000000..872a6efd
--- /dev/null
+++ b/src/main/java/com/couchbase/client/java/ClusterInterface.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright (c) 2018 Couchbase, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.couchbase.client.java;
+
+import com.couchbase.client.core.Core;
+import com.couchbase.client.core.annotation.Stability;
+import com.couchbase.client.core.diagnostics.DiagnosticsResult;
+import com.couchbase.client.core.diagnostics.PingResult;
+import com.couchbase.client.core.env.Authenticator;
+import com.couchbase.client.core.env.PasswordAuthenticator;
+import com.couchbase.client.core.env.SeedNode;
+import com.couchbase.client.java.analytics.AnalyticsOptions;
+//import com.couchbase.client.java.analytics.AnalyticsResult;
+import com.couchbase.client.java.diagnostics.DiagnosticsOptions;
+import com.couchbase.client.java.diagnostics.PingOptions;
+import com.couchbase.client.java.diagnostics.WaitUntilReadyOptions;
+import com.couchbase.client.java.env.ClusterEnvironment;
+import com.couchbase.client.java.manager.analytics.AnalyticsIndexManager;
+import com.couchbase.client.java.manager.bucket.BucketManager;
+import com.couchbase.client.java.manager.eventing.EventingFunctionManager;
+import com.couchbase.client.java.manager.query.QueryIndexManager;
+import com.couchbase.client.java.manager.search.SearchIndexManager;
+import com.couchbase.client.java.manager.user.UserManager;
+import com.couchbase.client.java.query.QueryOptions;
+import com.couchbase.client.java.query.QueryResult;
+import com.couchbase.client.java.search.SearchOptions;
+import com.couchbase.client.java.search.SearchQuery;
+import com.couchbase.client.java.search.result.SearchResult;
+import com.couchbase.client.java.transactions.Transactions;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
+
+import java.time.Duration;
+import java.util.Set;
+import java.util.function.Supplier;
+
+import static com.couchbase.client.core.util.Validators.notNull;
+import static com.couchbase.client.core.util.Validators.notNullOrEmpty;
+import static com.couchbase.client.java.AsyncCluster.extractClusterEnvironment;
+import static com.couchbase.client.java.AsyncCluster.seedNodesFromConnectionString;
+import static com.couchbase.client.java.ClusterOptions.clusterOptions;
+
+public interface ClusterInterface {
+
+  AsyncCluster async();
+
+  ReactiveCluster reactive();
+
+  @Stability.Volatile
+  Core core();
+
+  UserManager users();
+
+  BucketManager buckets();
+
+  AnalyticsIndexManager analyticsIndexes();
+
+  QueryIndexManager queryIndexes();
+
+  SearchIndexManager searchIndexes();
+
+  @Stability.Uncommitted
+  EventingFunctionManager eventingFunctions();
+
+  ClusterEnvironment environment();
+
+  QueryResult query(String statement);
+
+  QueryResult query(String statement, QueryOptions options);
+
+  //AnalyticsResult analyticsQuery(String statement);
+
+  // AnalyticsResult analyticsQuery(String statement, AnalyticsOptions options);
+
+  SearchResult searchQuery(String indexName, SearchQuery query);
+
+  SearchResult searchQuery(String indexName, SearchQuery query, SearchOptions options);
+
+  Bucket bucket(String bucketName);
+
+  void disconnect();
+
+  void disconnect(Duration timeout);
+
+  DiagnosticsResult diagnostics();
+
+  DiagnosticsResult diagnostics(DiagnosticsOptions options);
+
+  PingResult ping();
+
+  PingResult ping(PingOptions options);
+
+  void waitUntilReady(Duration timeout);
+
+  void waitUntilReady(Duration timeout, WaitUntilReadyOptions options);
+
+  Transactions transactions();
+}
diff --git a/src/main/java/com/couchbase/client/java/transactions/AttemptContextReactiveAccessor.java b/src/main/java/com/couchbase/client/java/transactions/AttemptContextReactiveAccessor.java
new file mode 100644
index 00000000..7397759e
--- /dev/null
+++ b/src/main/java/com/couchbase/client/java/transactions/AttemptContextReactiveAccessor.java
@@ -0,0 +1,209 @@
+/*
+/*
+ * Copyright 2021 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.couchbase.client.java.transactions;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.time.Duration;
+import java.time.temporal.ChronoUnit;
+import java.util.Optional;
+import java.util.UUID;
+import java.util.function.Consumer;
+import java.util.logging.Logger;
+
+import com.couchbase.client.core.annotation.Stability;
+import com.couchbase.client.core.transaction.CoreTransactionAttemptContext;
+import com.couchbase.client.core.transaction.CoreTransactionContext;
+import com.couchbase.client.core.transaction.CoreTransactionsReactive;
+import com.couchbase.client.core.transaction.config.CoreMergedTransactionConfig;
+import com.couchbase.client.core.transaction.config.CoreTransactionOptions;
+import com.couchbase.client.core.transaction.log.CoreTransactionLogger;
+import com.couchbase.client.core.transaction.support.AttemptState;
+import com.couchbase.client.java.codec.JsonSerializer;
+import reactor.core.publisher.Mono;
+import reactor.util.annotation.Nullable;
+
+/**
+ * To access the ReactiveTransactionAttemptContext held by TransactionAttemptContext
+ *
+ * @author Michael Reiche
+ */
+public class AttemptContextReactiveAccessor {
+
+	public static ReactiveTransactions reactive(Transactions transactions) {
+		try {
+			Field field = Transactions.class.getDeclaredField("reactive");
+			field.setAccessible(true);
+			return (ReactiveTransactions) field.get(transactions);
+		} catch (Throwable err) {
+			throw new RuntimeException(err);
+		}
+	}
+
+	public static ReactiveTransactionAttemptContext reactive(TransactionAttemptContext atr) {
+		JsonSerializer serializer;
+		try {
+			Field field = TransactionAttemptContext.class.getDeclaredField("serializer");
+			field.setAccessible(true);
+			serializer = (JsonSerializer) field.get(atr);
+		} catch (Throwable err) {
+			throw new RuntimeException(err);
+		}
+		return new ReactiveTransactionAttemptContext(getCore(atr), serializer);
+	}
+
+	public static TransactionAttemptContext blocking(ReactiveTransactionAttemptContext atr) {
+		JsonSerializer serializer;
+		try {
+			Field field = ReactiveTransactionAttemptContext.class.getDeclaredField("serializer");
+			field.setAccessible(true);
+			serializer = (JsonSerializer) field.get(atr);
+		} catch (Throwable err) {
+			throw new RuntimeException(err);
+		}
+			return new TransactionAttemptContext(getCore(atr), serializer);
+	}
+
+	public static CoreTransactionLogger getLogger(ReactiveTransactionAttemptContext attemptContextReactive) {
+		return attemptContextReactive.logger();
+	}
+
+	public static CoreTransactionLogger getLogger(TransactionAttemptContext attemptContextReactive) {
+		return attemptContextReactive.logger();
+	}
+
+	// todo gp needed?
+	@Stability.Internal
+	public static CoreTransactionAttemptContext newCoreTranactionAttemptContext(ReactiveTransactions transactions) {
+
+		String txnId = UUID.randomUUID().toString();
+		CoreTransactionsReactive coreTransactionsReactive;
+		try {
+			Field field = ReactiveTransactions.class.getDeclaredField("internal");
+			field.setAccessible(true);
+			coreTransactionsReactive = (CoreTransactionsReactive) field.get(transactions);
+		} catch (Throwable err) {
+			throw new RuntimeException(err);
+		}
+
+		CoreTransactionOptions perConfig = new CoreTransactionOptions(Optional.empty(), Optional.empty(), Optional.empty(),
+				Optional.of(Duration.ofMinutes(10)), Optional.empty(), Optional.empty());
+
+		CoreMergedTransactionConfig merged = new CoreMergedTransactionConfig(coreTransactionsReactive.config(),
+				Optional.ofNullable(perConfig));
+		CoreTransactionContext overall = new CoreTransactionContext(
+				coreTransactionsReactive.core().context().environment().requestTracer(),
+				coreTransactionsReactive.core().context().environment().eventBus(), UUID.randomUUID().toString(), merged,
+				coreTransactionsReactive.core().transactionsCleanup());
+
+		CoreTransactionAttemptContext coreTransactionAttemptContext = coreTransactionsReactive.createAttemptContext(overall,
+				merged, txnId);
+		return coreTransactionAttemptContext;
+	}
+
+	private static Duration now() {
+		return Duration.of(System.nanoTime(), ChronoUnit.NANOS);
+	}
+
+	public static ReactiveTransactionAttemptContext from(CoreTransactionAttemptContext coreTransactionAttemptContext,
+			JsonSerializer serializer) {
+		TransactionAttemptContext tac = new TransactionAttemptContext(coreTransactionAttemptContext, serializer);
+		return reactive(tac);
+	}
+
+	public static CoreTransactionAttemptContext getCore(ReactiveTransactionAttemptContext atr) {
+		CoreTransactionAttemptContext coreTransactionsReactive;
+		try {
+			Field field = ReactiveTransactionAttemptContext.class.getDeclaredField("internal");
+			field.setAccessible(true);
+			coreTransactionsReactive = (CoreTransactionAttemptContext) field.get(atr);
+		} catch (Throwable err) {
+			throw new RuntimeException(err);
+		}
+		return coreTransactionsReactive;
+	}
+
+	public static CoreTransactionAttemptContext getCore(TransactionAttemptContext atr) {
+		try {
+			Field field = TransactionAttemptContext.class.getDeclaredField("internal");
+			field.setAccessible(true);
+			return (CoreTransactionAttemptContext) field.get(atr);
+		} catch (Throwable err) {
+			throw new RuntimeException(err);
+		}
+	}
+
+	public static Mono<Void> implicitCommit(ReactiveTransactionAttemptContext atr, boolean b) {
+		CoreTransactionAttemptContext coreTransactionsReactive = getCore(atr);
+		try {
+			// getDeclaredMethod() does not find it (because of primitive arg?)
+			// CoreTransactionAttemptContext.class.getDeclaredMethod("implicitCommit", Boolean.class);
+			Method[] methods = CoreTransactionAttemptContext.class.getDeclaredMethods();
+			Method method = null;
+			for (Method m : methods) {
+				if (m.getName().equals("implicitCommit")) {
+					method = m;
+					break;
+				}
+			}
+			if (method == null) {
+				throw new RuntimeException("did not find implicitCommit method");
+			}
+			method.setAccessible(true);
+			return (Mono<Void>) method.invoke(coreTransactionsReactive, b);
+		} catch (Throwable err) {
+			throw new RuntimeException(err);
+		}
+
+	}
+
+	public static AttemptState getState(ReactiveTransactionAttemptContext atr) {
+		CoreTransactionAttemptContext coreTransactionsReactive = getCore(atr);
+		try {
+			Field field = CoreTransactionAttemptContext.class.getDeclaredField("state");
+			field.setAccessible(true);
+			return (AttemptState) field.get(coreTransactionsReactive);
+		} catch (Throwable err) {
+			throw new RuntimeException(err);
+		}
+	}
+
+	public static ReactiveTransactionAttemptContext createReactiveTransactionAttemptContext(
+			CoreTransactionAttemptContext core, JsonSerializer jsonSerializer) {
+		return new ReactiveTransactionAttemptContext(core, jsonSerializer);
+	}
+
+	public static CoreTransactionsReactive getCoreTransactionsReactive(ReactiveTransactions transactions) {
+		try {
+			Field field = ReactiveTransactions.class.getDeclaredField("internal");
+			field.setAccessible(true);
+			return (CoreTransactionsReactive) field.get(transactions);
+		} catch (Throwable err) {
+			throw new RuntimeException(err);
+		}
+	}
+
+	public static TransactionAttemptContext newTransactionAttemptContext(CoreTransactionAttemptContext ctx,
+			JsonSerializer jsonSerializer) {
+		return new TransactionAttemptContext(ctx, jsonSerializer);
+	}
+
+	public static TransactionResult run(Transactions transactions, Consumer<TransactionAttemptContext> transactionLogic, CoreTransactionOptions coreTransactionOptions) {
+		return reactive(transactions).runBlocking(transactionLogic, coreTransactionOptions);
+	}
+
+}
diff --git a/src/main/java/com/couchbase/transactions/TransactionsReactive.java b/src/main/java/com/couchbase/transactions/TransactionsReactive.java
new file mode 100644
index 00000000..352135ea
--- /dev/null
+++ b/src/main/java/com/couchbase/transactions/TransactionsReactive.java
@@ -0,0 +1,753 @@
+///*
+// * Copyright 2021 Couchbase, Inc.
+// *
+// * Licensed under the Apache License, Version 2.0 (the "License");
+// * you may not use this file except in compliance with the License.
+// * You may obtain a copy of the License at
+// *
+// *     http://www.apache.org/licenses/LICENSE-2.0
+// *
+// * Unless required by applicable law or agreed to in writing, software
+// * distributed under the License is distributed on an "AS IS" BASIS,
+// * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// * See the License for the specific language governing permissions and
+// * limitations under the License.
+// */
+//
+//package com.couchbase.transactions;
+//
+//import com.couchbase.client.core.annotation.Stability;
+//import com.couchbase.client.core.cnc.EventBus;
+//import com.couchbase.client.core.retry.reactor.DefaultRetry;
+//import com.couchbase.client.core.retry.reactor.Jitter;
+//import com.couchbase.client.core.retry.reactor.RetryContext;
+//import com.couchbase.client.java.Cluster;
+//import com.couchbase.client.java.ReactiveCollection;
+//import com.couchbase.client.java.ReactiveScope;
+//import com.couchbase.client.java.json.JsonObject;
+//import com.couchbase.client.java.query.ReactiveQueryResult;
+//import com.couchbase.transactions.cleanup.ClusterData;
+//import com.couchbase.transactions.cleanup.TransactionsCleanup;
+//import com.couchbase.transactions.components.ATR;
+//import com.couchbase.transactions.components.ActiveTransactionRecord;
+//import com.couchbase.transactions.config.MergedTransactionConfig;
+//import com.couchbase.transactions.config.PerTransactionConfig;
+//import com.couchbase.transactions.config.PerTransactionConfigBuilder;
+//import com.couchbase.transactions.config.SingleQueryTransactionConfig;
+//import com.couchbase.transactions.config.SingleQueryTransactionConfigBuilder;
+//import com.couchbase.transactions.config.TransactionConfig;
+//import com.couchbase.transactions.deferred.TransactionSerializedContext;
+//import com.couchbase.transactions.error.TransactionCommitAmbiguous;
+//import com.couchbase.transactions.error.TransactionExpired;
+//import com.couchbase.transactions.error.TransactionFailedException;
+//import com.couchbase.transactions.error.internal.ErrorClasses;
+//import com.couchbase.transactions.error.external.TransactionOperationFailed;
+//import com.couchbase.transactions.forwards.Supported;
+//import com.couchbase.transactions.log.EventBusPersistedLogger;
+//import com.couchbase.transactions.log.PersistedLogWriter;
+//import com.couchbase.transactions.log.TransactionLogEvent;
+//import com.couchbase.transactions.support.AttemptContextFactory;
+//import com.couchbase.transactions.support.AttemptState;
+//import com.couchbase.transactions.support.OptionsWrapperUtil;
+//import com.couchbase.transactions.util.DebugUtil;
+//import reactor.core.publisher.Mono;
+//import reactor.core.scheduler.Schedulers;
+//
+//import java.time.Duration;
+//import java.time.temporal.ChronoUnit;
+//import java.util.Objects;
+//import java.util.Optional;
+//import java.util.UUID;
+//import java.util.concurrent.TimeUnit;
+//import java.util.concurrent.atomic.AtomicReference;
+//import java.util.function.Consumer;
+//import java.util.function.Function;
+//import java.util.function.Predicate;
+//
+//import static com.couchbase.transactions.error.internal.TransactionOperationFailedBuilder.createError;
+//import static com.couchbase.transactions.log.PersistedLogWriter.MAX_LOG_ENTRIES_DEFAULT;
+//import static com.couchbase.transactions.support.SpanWrapperUtil.DB_COUCHBASE_TRANSACTIONS;
+//
+///**
+// * An asynchronous version of {@link Transactions}, allowing transactions to be created and run in an asynchronous
+// * manner.
+// * <p>
+// * The main method to run transactions is {@link TransactionsReactive#run}.
+// */
+//public class TransactionsReactive {
+//    static final int MAX_ATTEMPTS = 1000;
+//    private final TransactionsCleanup cleanup;
+//    private final TransactionConfig config;
+//    private AttemptContextFactory attemptContextFactory;
+//    private EventBusPersistedLogger persistedLogger;
+//
+//    /**
+//     * This is package-private.  Applications should create a {@link Transactions} object instead, and then call {@link
+//     * Transactions#reactive}.
+//     */
+//    static TransactionsReactive create(Cluster cluster, TransactionConfig config) {
+//        return new TransactionsReactive(cluster, config);
+//    }
+//
+//    private TransactionsReactive(Cluster cluster, TransactionConfig config) {
+//        Objects.requireNonNull(cluster);
+//        Objects.requireNonNull(config);
+//
+//        ClusterData clusterData = new ClusterData(cluster);
+//        this.config = config;
+//        this.attemptContextFactory = config.attemptContextFactory();
+//        MergedTransactionConfig merged = new MergedTransactionConfig(config, Optional.empty());
+//        cleanup = new TransactionsCleanup(merged, clusterData);
+//
+//        config.persistentLoggingCollection().ifPresent(collection -> {
+//            PersistedLogWriter persistedLogWriter = new PersistedLogWriter(collection, MAX_LOG_ENTRIES_DEFAULT);
+//            persistedLogger = new EventBusPersistedLogger(cluster.environment().eventBus(), persistedLogWriter, merged);
+//        });
+//    }
+//
+//
+//    /**
+//     * The main transactions 'engine', responsible for attempting the transaction logic as many times as required,
+//     * until the transaction commits, is explicitly rolled back, or expires.
+//     */
+//    // TODO: changed from private to public.  package-protected plus an accessor would be ok to
+//    public Mono<TransactionResult> executeTransaction(MergedTransactionConfig config,
+//                                                       TransactionContext overall,
+//                                                       Mono<ReactiveTransactionAttemptContext> transactionLogic) {
+//        AtomicReference<Long> startTime = new AtomicReference<>();
+//
+//        return Mono.just(overall)
+//
+//                .subscribeOn(reactor.core.scheduler.Schedulers.elastic())
+//
+//                .doOnSubscribe(v -> {
+//                    if (startTime.get() == null) startTime.set(System.nanoTime());
+//                })
+//
+//                // Where the magic happens: execute the app's transaction logic
+//                // A ReactiveTransactionAttemptContext gets created in here.  Rollback requires one of these (so it knows what
+//                // to rollback), so only errors thrown inside this block can trigger rollback.
+//                // So, expiry checks only get done inside this block.
+//                .then(transactionLogic)
+//
+//                .flatMap(this::executeImplicitCommit)
+//
+//                // Track an attempt if non-error, and request that the attempt be cleaned up.  Similar logic is also
+//                // done in executeHandleErrorsPreRetry.
+//                .doOnNext(ctx -> executeAddAttemptAndCleanupRequest(config, overall, ctx))
+//
+//                // Track an attempt if error, and perform rollback if needed.
+//                // All errors reaching here must be a `TransactionOperationFailed`.
+//                .onErrorResume(err -> executeHandleErrorsPreRetry(config, overall, err))
+//
+//                // This is the main place to retry txns.  Feed all errors up to this centralised point.
+//                // All errors reaching here must be a `TransactionOperationFailed`.
+//                .retryWhen(executeCreateRetryWhen(overall))
+//
+//                // If we're here, then we've hit an error that we don't want to retry.
+//                // Either raise some derivative of TransactionFailedException to the app, or return an ReactiveTransactionAttemptContext
+//                // to return success (some errors result in success, e.g. TRANSACTION_FAILED_POST_COMMIT)
+//                // All errors reaching here must be an `ErrorWrapper`.
+//                .onErrorResume(err -> executeHandleErrorsPostRetry(overall, err))
+//
+//                .doOnError(err -> {
+//                    if (config.logOnFailure() && !config.logDirectly()) {
+//                        EventBus eventBus = cleanup.clusterData().cluster().environment().eventBus();
+//                        overall.LOGGER.logs().forEach(log -> {
+//                            eventBus.publish(new TransactionLogEvent(config.logOnFailureLevel(),
+//                                    TransactionLogEvent.DEFAULT_CATEGORY, log.toString()));
+//                        });
+//                    }
+//                })
+//
+//                // If we get here, success
+//                .doOnSuccess(v ->
+//                        overall.LOGGER.info("finished txn in %dus",
+//                                TimeUnit.NANOSECONDS.toMicros(System.nanoTime() - startTime.get()))
+//                )
+//
+//                // Safe to do single() as there will only ever be 1 result
+//                .single()
+//                .map(v -> createResultFromContext(overall));
+//    }
+//
+//    private reactor.util.retry.Retry executeCreateRetryWhen(TransactionContext overall) {
+//        Predicate<? super RetryContext<Object>> predicate = context -> {
+//            Throwable exception = context.exception();
+//
+//            if (!(exception instanceof TransactionOperationFailed)) {
+//                // A bug.  Only TransactionOperationFailed is allowed to reach here.
+//                throw new IllegalStateException("Non-TransactionOperationFailed '" + DebugUtil.dbg(exception) + "' received during retry, this is a bug", exception);
+//            }
+//
+//            TransactionOperationFailed e = (TransactionOperationFailed) exception;
+//
+//            overall.LOGGER.info("TransactionOperationFailed retryTransaction=%s", e.retryTransaction());
+//
+//            return e.retryTransaction();
+//        };
+//
+//        return DefaultRetry.create(predicate)
+//
+//                .exponentialBackoff(Duration.of(1, ChronoUnit.MILLIS),
+//                        Duration.of(2, ChronoUnit.MILLIS))
+//
+//                .doOnRetry(v -> overall.LOGGER.info("<>", "retrying transaction after backoff %dmillis", v.backoff().toMillis()))
+//
+//                // Add some jitter so two txns don't livelock each other
+//                .jitter(Jitter.random())
+//
+//                // Really, this is a safety-guard.  The txn will be aborted when it expires.
+//                .retryMax(MAX_ATTEMPTS)
+//
+//                .toReactorRetry();
+//    }
+//
+//    private Mono<ReactiveTransactionAttemptContext> executeHandleErrorsPreRetry(MergedTransactionConfig config,
+//                                                                     TransactionContext overall, Throwable err) {
+//        if (!(err instanceof TransactionOperationFailed)) {
+//            // A bug.  Only TransactionOperationFailed is allowed to reach here.
+//            overall.LOGGER.warn("<>", "received non-TransactionOperationFailed error %s, unable to rollback as don't have " +
+//                    "context", DebugUtil.dbg(err));
+//            return Mono.error(new IllegalStateException("received non-TransactionOperationFailed error " + err.getClass().getName() + " in pre-retry", err));
+//        }
+//
+//        Mono<Void> autoRollback = Mono.empty();
+//        Mono<Void> cleanupReq = Mono.empty();
+//
+//        TransactionOperationFailed e = (TransactionOperationFailed) err;
+//        ReactiveTransactionAttemptContext ctx = e.context();
+//
+//        overall.LOGGER.info("<>", "finishing attempt off after error '%s'", e);
+//
+//        if (e.autoRollbackAttempt()) {
+//            // In queryMode we always ROLLBACK, as there is possibly delta table state to cleanup, and there may be an
+//            // ATR - we don't know
+//            if (ctx.state() == AttemptState.NOT_STARTED && !ctx.queryMode()) {
+//                // This is a better way of doing [RETRY-ERR-NOATR] and likely means that the older logic for
+//                // handling that won't trigger now
+//                ctx.LOGGER.info(ctx.attemptId(), "told to auto-rollback but in NOT_STARTED state, so nothing to do - skipping rollback");
+//            }
+//            else {
+//                ctx.LOGGER.info(ctx.attemptId(), "auto-rolling-back on error");
+//
+//                autoRollback = ctx.rollbackInternal(false);
+//            }
+//        } else {
+//            ctx.LOGGER.info(ctx.attemptId(), "has been told to skip auto-rollback");
+//        }
+//
+//        if (!config.runRegularAttemptsCleanupThread()) {
+//            // Don't add a request to a queue that no-one will be processing
+//            ctx.LOGGER.trace(ctx.attemptId(), "skipping addition of cleanup request on failure as regular cleanup disabled");
+//        }
+//        else {
+//            cleanupReq = Mono.fromRunnable(() -> addCleanupRequestForContext(ctx));
+//        }
+//
+//        Mono<Void> addAttempt = Mono.fromRunnable(() -> {
+//            TransactionAttempt ta = TransactionAttempt.createFromContext(ctx, Optional.of(err));
+//            overall.addAttempt(ta);
+//            ctx.LOGGER.info(ctx.attemptId(), "added attempt %s after error", ta);
+//        });
+//
+//        final Mono<Void> cleanupReqForLambda = cleanupReq;
+//
+//        return autoRollback
+//                // See [Primary Operations] section in design document
+//                .onErrorResume(er -> {
+//                    overall.LOGGER.info("<>", "rollback failed with %s, raising original error but with retryTransaction turned off",
+//                            DebugUtil.dbg(er));
+//
+//                    // Still want to add attempt and cleanup request
+//                    return cleanupReqForLambda
+//                            .then(addAttempt)
+//                            .then(Mono.error(createError(e.context(), e.causingErrorClass())
+//                                    .raiseException(e.toRaise())
+//                                    .cause(e.getCause())
+//                                    .build()));
+//                })
+//                .then(cleanupReqForLambda)
+//                // Only want to add the attempt after doing the rollback, so the attempt has the correct state (hopefully
+//                // ROLLED_BACK)
+//                .then(addAttempt)
+//                .then(Mono.defer(() -> {
+//                    if (e.retryTransaction() && overall.hasExpiredClientSide()) {
+//                        overall.LOGGER.info("<>", "original error planned to retry transaction, but it has subsequently expired");
+//                        return Mono.error(createError(ctx, ErrorClasses.FAIL_EXPIRY)
+//                                .doNotRollbackAttempt()
+//                                .raiseException(TransactionOperationFailed.FinalErrorToRaise.TRANSACTION_EXPIRED)
+//                                .build());
+//                    }
+//                    else {
+//                        // Raise the error up the stack so the logic later can decide whether to retry the transaction
+//                        overall.LOGGER.info("<>", "reraising original exception %s", DebugUtil.dbg(err));
+//                        return Mono.error(err);
+//                    }
+//                }))
+//                .doFinally(v -> ctx.span().failWith(e))
+//                .thenReturn(ctx);
+//    }
+//
+//    private Mono<ReactiveTransactionAttemptContext> executeHandleErrorsPostRetry(TransactionContext overall, Throwable err) {
+//        if (!(err instanceof TransactionOperationFailed)) {
+//            // A bug.  Only TransactionOperationFailed is allowed to reach here.
+//            return Mono.error(new IllegalStateException("Non-TransactionOperationFailed '" + DebugUtil.dbg(err) + "' received, this is a bug"));
+//        }
+//
+//        TransactionResult result = createResultFromContext(overall);
+//        TransactionOperationFailed e = (TransactionOperationFailed) err;
+//
+//        if (e.toRaise() == TransactionOperationFailed.FinalErrorToRaise.TRANSACTION_FAILED_POST_COMMIT) {
+//            e.context().LOGGER.info(e.context().attemptId(), "converted TRANSACTION_FAILED_POST_COMMIT to success, unstagingComplete() will be false");
+//
+//            return Mono.just(e.context());
+//        }
+//        else {
+//            TransactionFailedException ret;
+//
+//            switch (e.toRaise()) {
+//                case TRANSACTION_EXPIRED: {
+//                    String msg = "Transaction has expired configured timeout of " + overall.expirationTime().toMillis() + "msecs.  The transaction is not committed.";
+//                    ret = new TransactionExpired(e.getCause(), result, msg);
+//                    break;
+//                }
+//                case TRANSACTION_COMMIT_AMBIGUOUS: {
+//                    String msg = "It is ambiguous whether the transaction committed";
+//                    ret = new TransactionCommitAmbiguous(e.getCause(), result, msg);
+//                    break;
+//                }
+//                default:
+//                    ret = new TransactionFailedException(e.getCause(), result);
+//                    break;
+//            }
+//
+//            e.context().LOGGER.info(e.context().attemptId(), "converted TransactionOperationFailed %s to final error %s",
+//                    e.toRaise(), ret);
+//
+//            return Mono.error(ret);
+//        }
+//    }
+//
+//    private void executeAddAttemptAndCleanupRequest(MergedTransactionConfig config, TransactionContext overall,
+//                                                    ReactiveTransactionAttemptContext ctx) {
+//        TransactionAttempt ta = TransactionAttempt.createFromContext(ctx, Optional.empty());
+//        overall.addAttempt(ta);
+//        ctx.LOGGER.info(ctx.attemptId(), "added attempt %s after success", ta);
+//
+//        if (config.runRegularAttemptsCleanupThread()) {
+//            addCleanupRequestForContext(ctx);
+//        } else {
+//            ctx.LOGGER.trace(ctx.attemptId(), "skipping addition of cleanup request on success");
+//        }
+//
+//        ctx.span().finish();
+//    }
+//
+//    private Mono<ReactiveTransactionAttemptContext> executeImplicitCommit(ReactiveTransactionAttemptContext ctx) {
+//        return Mono.defer(() -> {
+//            // If app has not explicitly performed a commit, assume they want to do so anyway
+//            if (!ctx.isDone()) {
+//                if (ctx.serialized().isPresent()) {
+//                    return Mono.just(ctx);
+//                } else {
+//                    ctx.LOGGER.trace(ctx.attemptId(), "doing implicit commit");
+//
+//                    return ctx.commit()
+//                            .then(Mono.just(ctx))
+//                            .onErrorResume(err -> Mono.error(TransactionOperationFailed.convertToOperationFailedIfNeeded(err, ctx)));
+//                }
+//            } else {
+//                return Mono.just(ctx);
+//            }
+//        });
+//    }
+//
+//    // TODO: changed from package-protected to public (could have just used an accessor class in same package)
+//    public ReactiveTransactionAttemptContext createAttemptContext(TransactionContext overall,
+//                                                MergedTransactionConfig config,
+//                                                String attemptId) {
+//        // null only happens in testing with Mockito, harmless
+//        if (overall != null) {
+//            return attemptContextFactory.create(overall, config, attemptId, this, Optional.of(overall.span()));
+//        } else {
+//            return null;
+//        }
+//    }
+//
+//    /**
+//     * Runs the supplied transactional logic until success or failure.
+//     * <p>
+//     * This is the asynchronous version of {@link Transactions#run}, so to cover the differences:
+//     * <ul>
+//     * <li>The transaction logic is supplied with a {@link ReactiveTransactionAttemptContext}, which contains asynchronous
+//     * methods to allow it to read, mutate, insert and delete documents, as well as commit or rollback the
+//     * transactions.</li>
+//     * <li>The transaction logic should run these methods as a Reactor chain.</li>
+//     * <li>The transaction logic should return a <code>Mono{@literal <}Void{@literal >}</code>.  Any
+//     * <code>Flux</code> or <code>Mono</code> can be converted to a <code>Mono{@literal <}Void{@literal >}</code> by
+//     * calling <code>.then()</code> on it.</li>
+//     * <li>This method returns a <code>Mono{@literal <}TransactionResult{@literal >}</code>, which should be handled
+//     * as a normal Reactor Mono.</li>
+//     * </ul>
+//     *
+//     * @param transactionLogic the application's transaction logic
+//     * @param perConfig        the configuration to use for this transaction
+//     * @return there is no need to check the returned {@link TransactionResult}, as success is implied by the lack of a
+//     * thrown exception.  It contains information useful only for debugging and logging.
+//     * @throws TransactionFailedException or a derived exception if the transaction fails to commit for any reason, possibly
+//     *                           after multiple retries.  The exception contains further details of the error.  Not
+//     */
+//    public Mono<TransactionResult> run(Function<ReactiveTransactionAttemptContext, Mono<Void>> transactionLogic,
+//                                       PerTransactionConfig perConfig) {
+//        return Mono.defer(() -> {
+//            MergedTransactionConfig merged = new MergedTransactionConfig(config, Optional.of(perConfig));
+//
+//            TransactionContext overall =
+//                    new TransactionContext(cleanup.clusterData().cluster().environment().requestTracer(),
+//                            cleanup.clusterData().cluster().environment().eventBus(),
+//                            UUID.randomUUID().toString(),
+//                            now(),
+//                            Duration.ZERO,
+//                            merged);
+//            AtomicReference<Long> startTime = new AtomicReference<>(0L);
+//
+//            Mono<ReactiveTransactionAttemptContext> ob = Mono.fromCallable(() -> {
+//                String txnId = UUID.randomUUID().toString();
+//                overall.LOGGER.info(configDebug(config, perConfig));
+//                return createAttemptContext(overall, merged, txnId);
+//            }).flatMap(ctx -> {
+//                ctx.LOGGER.info("starting attempt %d/%s/%s",
+//                        overall.numAttempts(), ctx.transactionId(), ctx.attemptId());
+//                Mono<Void> result = transactionLogic.apply(ctx);
+//                return result
+//                        .onErrorResume(err -> {
+//                            ctx.LOGGER.info(ctx.attemptId(), "caught exception '%s' in async, rethrowing", err);
+//                            logElidedStacktrace(ctx, err);
+//
+//                            return Mono.error(TransactionOperationFailed.convertToOperationFailedIfNeeded(err, ctx));
+//                        })
+//                        .thenReturn(ctx);
+//            }).doOnSubscribe(v -> startTime.set(System.nanoTime()))
+//                    .doOnNext(v -> v.LOGGER.trace(v.attemptId(), "finished attempt %d in %sms",
+//                            overall.numAttempts(), (System.nanoTime() - startTime.get()) / 1_000_000));
+//
+//            return executeTransaction(merged, overall, ob)
+//                    .doOnNext(v -> overall.span().finish())
+//                    .doOnError(err -> overall.span().failWith(err));
+//        });
+//    }
+//
+//    // Printing the stacktrace is expensive in terms of log noise, but has been a life saver on many debugging
+//    // encounters.  Strike a balance by eliding the more useless elements.
+//    // TODO: changed from private to public
+//    public void logElidedStacktrace(ReactiveTransactionAttemptContext ctx, Throwable err) {
+//        DebugUtil.fetchElidedStacktrace(err, (s) -> ctx.LOGGER.info(ctx.attemptId(), "          " + s.toString()));
+//    }
+//
+//    // TODO: changed from private to public
+//    public static String configDebug(TransactionConfig config, PerTransactionConfig perConfig) {
+//        StringBuilder sb = new StringBuilder();
+//        sb.append("library version: ");
+//        sb.append(TransactionsReactive.class.getPackage().getImplementationVersion());
+//        sb.append(" config: ");
+//        sb.append("atrs=");
+//        sb.append(config.numAtrs());
+//        sb.append(", metadataCollection=");
+//        sb.append(config.metadataCollection());
+//        sb.append(", expiry=");
+//        sb.append(perConfig.expirationTime().orElse(config.transactionExpirationTime()).toMillis());
+//        sb.append("msecs durability=");
+//        sb.append(config.durabilityLevel());
+//        sb.append(" per-txn config=");
+//        sb.append(" durability=");
+//        sb.append(perConfig.durabilityLevel());
+//        sb.append(", supported=");
+//        sb.append(Supported.SUPPORTED);
+//        return sb.toString();
+//    }
+//
+//    /**
+//     * Convenience overload that runs {@link TransactionsReactive#run} with a default <code>PerTransactionConfig</code>.
+//     */
+//    public Mono<TransactionResult> run(Function<ReactiveTransactionAttemptContext, Mono<Void>> transactionLogic) {
+//        return run(transactionLogic, PerTransactionConfigBuilder.create().build());
+//    }
+//
+//    @Stability.Volatile
+//    public Mono<TransactionResult> commit(TransactionSerializedContext serialized, PerTransactionConfig perConfig) {
+//        return deferred(serialized,
+//                perConfig,
+//                // Nothing to actually do, just want the implicit commit
+//                (ctx) -> Mono.empty());
+//    }
+//
+//    @Stability.Volatile
+//    public Mono<TransactionResult> rollback(TransactionSerializedContext serialized, PerTransactionConfig perConfig) {
+//        return deferred(serialized,
+//                perConfig,
+//                (ctx) -> ctx.rollback());
+//    }
+//
+//    @Stability.Volatile
+//    private Mono<TransactionResult> deferred(TransactionSerializedContext serialized,
+//                                             PerTransactionConfig perConfig,
+//                                             Function<ReactiveTransactionAttemptContext, Mono<Void>> initial) {
+//        MergedTransactionConfig merged = new MergedTransactionConfig(config, Optional.of(perConfig));
+//        JsonObject hydrated = JsonObject.fromJson(serialized.encodeAsString());
+//
+//        String atrBucket = hydrated.getString("atrBucket");
+//        String atrScope = hydrated.getString("atrScope");
+//        String atrCollectionName = hydrated.getString("atrCollection");
+//        String atrId = hydrated.getString("atrId");
+//        ReactiveCollection atrCollection = cleanup.clusterData()
+//                .getBucketFromName(atrBucket)
+//                .scope(atrScope)
+//                .collection(atrCollectionName);
+//
+//        return ActiveTransactionRecord.getAtr(atrCollection,
+//                                atrId,
+//                                OptionsWrapperUtil.kvTimeoutNonMutating(merged, atrCollection.core()),
+//                                null)
+//
+//                .flatMap(atrOpt -> {
+//                    if (!atrOpt.isPresent()) {
+//                        return Mono.error(new IllegalStateException(String.format("ATR %s/%s could not be found",
+//                                atrBucket, atrId)));
+//                    }
+//                    else {
+//                        ATR atr = atrOpt.get();
+//
+//                        // Note startTimeServerMillis is written with ${Mutation.CAS} while currentTimeServer
+//                        // could have come from $vbucket.HLC and is hence one-second granularity.  So, this is a
+//                        // somewhat imperfect comparison.
+//                        Duration currentTimeServer = Duration.ofNanos(atr.cas());
+//                        Duration startTimeServer = Duration.ofMillis(hydrated.getLong("startTimeServerMillis"));
+//
+//                        // This includes the time elapsed during the first part of the transaction, plus any time
+//                        // elapsed during the period the transaction was expired.  Total time since the transaction
+//                        // began, basically.
+//                        Duration timeElapsed = currentTimeServer.minus(startTimeServer);
+//
+//                        TransactionContext overall =
+//                                new TransactionContext(cleanup.clusterData().cluster().environment().requestTracer(),
+//                                        cleanup.clusterData().cluster().environment().eventBus(),
+//                                        UUID.randomUUID().toString(),
+//                                        Duration.ofNanos(System.nanoTime()),
+//                                        timeElapsed,
+//                                        merged);
+//                        AtomicReference<Long> startTime = new AtomicReference<>(0L);
+//
+//                        overall.LOGGER.info("elapsed time = %dmsecs (ATR start time %dmsecs, current ATR time %dmsecs)",
+//                                timeElapsed.toMillis(), startTimeServer.toMillis(), currentTimeServer.toMillis());
+//
+//                        Mono<ReactiveTransactionAttemptContext> ob = Mono.defer(() -> {
+//                            ReactiveTransactionAttemptContext ctx = attemptContextFactory.createFrom(hydrated, overall, merged, this);
+//                            ctx.LOGGER.info("starting attempt %d/%s/%s",
+//                                    overall.numAttempts(), ctx.transactionId(), ctx.attemptId());
+//                            ctx.LOGGER.info(configDebug(config, perConfig));
+//
+//                            return initial.apply(ctx)
+//
+//                                    // TXNJ-50: Make sure we run user's blocking logic on a scheduler that can take it
+//                                    .subscribeOn(Schedulers.elastic())
+//
+//                                    .onErrorResume(err -> {
+//                                        ctx.LOGGER.info(ctx.attemptId(), "caught exception '%s' in deferred, rethrowing",
+//                                                err);
+//
+//                                        logElidedStacktrace(ctx, err);
+//
+//                                        return Mono.error(TransactionOperationFailed.convertToOperationFailedIfNeeded(err, ctx));
+//                                    })
+//
+//                                    .doOnSubscribe(v -> startTime.set(System.nanoTime()))
+//
+//                                    .doOnNext(v -> {
+//                                        ctx.LOGGER.trace(ctx.attemptId(), "finished attempt %d in %sms",
+//                                                overall.numAttempts(), (System.nanoTime() - startTime.get()) / 1_000_000);
+//                                    })
+//
+//                                    .thenReturn(ctx);
+//                        });
+//
+//                        return executeTransaction(merged, overall, ob)
+//                                .doOnNext(v -> overall.span().attribute(DB_COUCHBASE_TRANSACTIONS + "retries", overall.numAttempts()).finish())
+//                                .doOnError(err -> overall.span().attribute(DB_COUCHBASE_TRANSACTIONS + "retries", overall.numAttempts()).failWith(err));
+//                    }
+//                });
+//    }
+//
+//    Mono<TransactionResult> runBlocking(Consumer<TransactionAttemptContext> txnLogic, PerTransactionConfig perConfig) {
+//        return Mono.defer(() -> {
+//            MergedTransactionConfig merged = new MergedTransactionConfig(config, Optional.of(perConfig));
+//            TransactionContext overall =
+//                    new TransactionContext(cleanup.clusterData().cluster().environment().requestTracer(),
+//                            cleanup.clusterData().cluster().environment().eventBus(),
+//                            UUID.randomUUID().toString(),
+//                            now(),
+//                            Duration.ZERO,
+//                            merged);
+//            AtomicReference<Long> startTime = new AtomicReference<>(0L);
+//            overall.LOGGER.info(configDebug(config, perConfig));
+//
+//            Mono<ReactiveTransactionAttemptContext> ob = Mono.defer(() -> {
+//                String txnId = UUID.randomUUID().toString();
+//                ReactiveTransactionAttemptContext ctx = createAttemptContext(overall, merged, txnId);
+//                TransactionAttemptContext ctxBlocking = new TransactionAttemptContext(ctx);
+//                ctx.LOGGER.info("starting attempt %d/%s/%s",
+//                        overall.numAttempts(), ctx.transactionId(), ctx.attemptId());
+//
+//                return Mono.fromRunnable(() -> txnLogic.accept(ctxBlocking))
+//
+//                        // TXNJ-50: Make sure we run user's blocking logic on a scheduler that can take it
+//                        .subscribeOn(Schedulers.elastic())
+//
+//                        .onErrorResume(err -> {
+//                            ctx.LOGGER.info(ctx.attemptId(), "caught exception '%s' in runBlocking, rethrowing", err);
+//
+//                            logElidedStacktrace(ctx, err);
+//
+//                            return Mono.error(TransactionOperationFailed.convertToOperationFailedIfNeeded(err, ctx));
+//                        })
+//
+//                        .doOnSubscribe(v -> startTime.set(System.nanoTime()))
+//
+//                        .doOnNext(v -> {
+//                            ctx.LOGGER.trace(ctx.attemptId(), "finished attempt %d in %sms",
+//                                    overall.numAttempts(), (System.nanoTime() - startTime.get()) / 1_000_000);
+//                        })
+//
+//                        .thenReturn(ctx);
+//            });
+//
+//            return executeTransaction(merged, overall, ob)
+//                    .doOnNext(v -> overall.span().attribute(DB_COUCHBASE_TRANSACTIONS + "retries", overall.numAttempts()).finish())
+//                    .doOnError(err -> overall.span().attribute(DB_COUCHBASE_TRANSACTIONS + "retries", overall.numAttempts()).failWith(err));
+//        });
+//    }
+//
+//    public TransactionConfig config() {
+//        return config;
+//    }
+//
+//    private static Duration now() {
+//        return Duration.of(System.nanoTime(), ChronoUnit.NANOS);
+//    }
+//
+//    TransactionsCleanup cleanup() {
+//        return cleanup;
+//    }
+//
+//    private void addCleanupRequestForContext(ReactiveTransactionAttemptContext ctx) {
+//        // Whether the txn was successful or not, still want to clean it up
+//        if (ctx.queryMode()) {
+//            ctx.LOGGER.info(ctx.attemptId(), "Skipping cleanup request as in query mode");
+//        }
+//        else if (ctx.serialized().isPresent()) {
+//            ctx.LOGGER.info(ctx.attemptId(), "Skipping cleanup request as deferred transaction");
+//        }
+//        else if (ctx.atrId().isPresent() && ctx.atrCollection().isPresent()) {
+//            switch (ctx.state()) {
+//                case NOT_STARTED:
+//                case COMPLETED:
+//                case ROLLED_BACK:
+//                    ctx.LOGGER.trace(ctx.attemptId(), "Skipping addition of cleanup request in state %s", ctx.state());
+//                    break;
+//                default:
+//                    ctx.LOGGER.trace(ctx.attemptId(), "Adding cleanup request for %s/%s",
+//                            ctx.atrCollection().get().name(), ctx.atrId().get());
+//
+//                    cleanup.add(ctx.createCleanupRequest());
+//            }
+//        } else {
+//            // No ATR entry to remove
+//            ctx.LOGGER.trace(ctx.attemptId(), "Skipping cleanup request as no ATR entry to remove (due to no " +
+//                    "mutations)");
+//        }
+//    }
+//
+//    private static TransactionResult createResultFromContext(TransactionContext overall) {
+//        return new TransactionResult(overall.attempts(),
+//                overall.LOGGER,
+//                Duration.of(System.nanoTime() - overall.startTimeClient().toNanos(), ChronoUnit.NANOS),
+//                overall.transactionId(),
+//                overall.serialized());
+//    }
+//
+//    /**
+//     * Performs a single query transaction, with default configuration.
+//     *
+//     * @param statement the statement to execute.
+//     * @return a ReactiveSingleQueryTransactionResult
+//     */
+//    @Stability.Uncommitted
+//    public Mono<ReactiveSingleQueryTransactionResult> query(String statement) {
+//        return query(null, statement, SingleQueryTransactionConfigBuilder.create().build());
+//    }
+//
+//    /**
+//     * Performs a single query transaction, with a custom configuration.
+//     *
+//     * @param statement the statement to execute.
+//     * @param queryOptions configuration options.
+//     * @return a ReactiveSingleQueryTransactionResult
+//     */
+//    @Stability.Uncommitted
+//    public Mono<ReactiveSingleQueryTransactionResult> query(String statement, SingleQueryTransactionConfig queryOptions) {
+//        return query(null, statement, queryOptions);
+//    }
+//
+//    /**
+//     * Performs a single query transaction, with a scope context and default configuration.
+//     *
+//     * @param statement the statement to execute.
+//     * @param scope the query will be executed in the context of this scope, so it can refer to a collection on this scope
+//     *              rather than needed to provide the full keyspace.
+//     * @return a ReactiveSingleQueryTransactionResult
+//     */
+//    @Stability.Uncommitted
+//    public Mono<ReactiveSingleQueryTransactionResult> query(ReactiveScope scope, String statement) {
+//        return query(scope, statement, SingleQueryTransactionConfigBuilder.create().build());
+//    }
+//
+//    /**
+//     * Performs a single query transaction, with a scope context and custom configuration.
+//     *
+//     * @param statement the statement to execute.
+//     * @param scope the query will be executed in the context of this scope, so it can refer to a collection on this scope
+//     *              rather than needed to provide the full keyspace.
+//     * @param queryOptions configuration options.
+//     * @return a ReactiveSingleQueryTransactionResult
+//     */
+//    @Stability.Uncommitted
+//    public Mono<ReactiveSingleQueryTransactionResult> query(ReactiveScope scope, String statement, SingleQueryTransactionConfig queryOptions) {
+//        return Mono.defer(() -> {
+//            AtomicReference<ReactiveQueryResult> queryResult = new AtomicReference<>();
+//            return run((ctx) -> ctx.query(scope, statement, queryOptions.queryOptions(), true)
+//                    .doOnNext(qr -> queryResult.set(qr))
+//                    .then(), queryOptions.convert())
+//                    .map(result -> new ReactiveSingleQueryTransactionResult(result.log(), queryResult.get()));
+//        });
+//    }
+//
+//    @Stability.Internal
+//    @Deprecated // Prefer setting TransactionConfigBuilder#testFactories now
+//    public void setAttemptContextFactory(AttemptContextFactory factory) {
+//        this.attemptContextFactory = factory;
+//    }
+//    public ReactiveTransactionAttemptContext newAttemptContextReactive(){
+//        PerTransactionConfig perConfig = PerTransactionConfigBuilder.create().build();
+//        MergedTransactionConfig merged = new MergedTransactionConfig(config, Optional.of(perConfig));
+//
+//        TransactionContext overall = new TransactionContext(
+//            cleanup().clusterData().cluster().environment().requestTracer(),
+//            cleanup().clusterData().cluster().environment().eventBus(),
+//            UUID.randomUUID().toString(), now(), Duration.ZERO, merged);
+//
+//        String txnId = UUID.randomUUID().toString();
+//        overall.LOGGER.info(configDebug(config, perConfig));
+//        return createAttemptContext(overall, merged, txnId);
+//    }
+//
+//}
diff --git a/src/main/java/com/example/demo/CouchbaseTransactionManager.pre-core b/src/main/java/com/example/demo/CouchbaseTransactionManager.pre-core
new file mode 100644
index 00000000..ab9d8408
--- /dev/null
+++ b/src/main/java/com/example/demo/CouchbaseTransactionManager.pre-core
@@ -0,0 +1,201 @@
+package com.example.demo;
+
+import java.util.concurrent.atomic.AtomicReference;
+
+import com.couchbase.client.java.transactions.ReactiveTransactionAttemptContext;
+import com.couchbase.client.java.transactions.TransactionAttemptContext;
+import com.couchbase.client.java.transactions.AttemptContextReactiveAccessor;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.beans.factory.DisposableBean;
+import org.springframework.data.couchbase.core.CouchbaseTemplate;
+import org.springframework.data.couchbase.transaction.ClientSession;
+import org.springframework.data.couchbase.transaction.ClientSessionImpl;
+import org.springframework.transaction.TransactionDefinition;
+import org.springframework.transaction.TransactionException;
+import org.springframework.transaction.support.AbstractPlatformTransactionManager;
+import org.springframework.transaction.support.CallbackPreferringPlatformTransactionManager;
+import org.springframework.transaction.support.DefaultTransactionStatus;
+import org.springframework.transaction.support.ResourceHolderSupport;
+import org.springframework.transaction.support.ResourceTransactionManager;
+import org.springframework.transaction.support.SmartTransactionObject;
+import org.springframework.transaction.support.TransactionCallback;
+import org.springframework.transaction.support.TransactionSynchronizationManager;
+import org.springframework.transaction.support.TransactionSynchronizationUtils;
+import org.springframework.util.Assert;
+
+// todo gp why is there separate CouchbaseCallbackTransactionManager if this class also extends CallbackPreferringPlatformTransactionManager?
+// todo gp there is another CouchbaseTransactionManager in another package, which is valid?
+public class CouchbaseTransactionManager extends AbstractPlatformTransactionManager
+  implements DisposableBean, ResourceTransactionManager, CallbackPreferringPlatformTransactionManager {
+
+  private static final Logger LOGGER = LoggerFactory.getLogger(CouchbaseTransactionManager.class);
+
+  private final CouchbaseTemplate template;
+
+  public CouchbaseTransactionManager(CouchbaseTemplate template) {
+    this.template = template;
+  }
+
+  public CouchbaseTransactionalTemplate template() {
+    return new CouchbaseTransactionalTemplate(template);
+  }
+
+  @Override
+  public <T> T execute(TransactionDefinition definition, TransactionCallback<T> callback) throws TransactionException {
+    final AtomicReference<T> result = new AtomicReference<>();
+    // todo gp like CouchbaseCallbackTransactionManager, it needs access to CouchbaseClientFactory here (Cluster)
+//    TransactionResult txnResult = transactions.run(attemptContext -> {
+//
+//      if (TransactionSynchronizationManager.hasResource(template.getCouchbaseClientFactory())) {
+//        ((CouchbaseResourceHolder) TransactionSynchronizationManager
+//          .getResource(template.reactive().getCouchbaseClientFactory()))
+//          .setAttemptContext(attemptContext);
+//      } else {
+//        TransactionSynchronizationManager.bindResource(
+//          template.reactive().getCouchbaseClientFactory(),
+//          new CouchbaseResourceHolder(attemptContext)
+//        );
+//      }
+//
+//      try {
+//        // Since we are on a different thread now transparently, at least make sure
+//        // that the original method invocation is synchronized.
+//        synchronized (this) {
+//          result.set(callback.doInTransaction(null));
+//        }
+//      } catch (RuntimeException e) {
+//        System.err.println("RuntimeException: "+e+" instanceof RuntimeException "+(e instanceof RuntimeException));
+//        throw e;
+//      } catch (Throwable e) {
+//        System.err.println("RuntimeException: "+e+" instanceof "+(e instanceof Throwable));
+//        throw new RuntimeException(e);
+//      }
+//    });
+
+//    LOGGER.debug("Completed Couchbase Transaction with Result: " + txnResult);
+    return result.get();
+  }
+
+  @Override
+  protected CouchbaseTransactionObject doGetTransaction() throws TransactionException {
+    CouchbaseResourceHolder resourceHolder = (CouchbaseResourceHolder) TransactionSynchronizationManager
+      .getResource(template.getCouchbaseClientFactory());
+    return new CouchbaseTransactionObject(resourceHolder);
+  }
+
+  @Override
+  protected boolean isExistingTransaction(Object transaction) throws TransactionException {
+    return extractTransaction(transaction).hasResourceHolder();
+  }
+
+  @Override
+  protected void doBegin(Object transaction, TransactionDefinition definition) throws TransactionException {
+    LOGGER.debug("Beginning Couchbase Transaction with Definition {}", definition);
+  }
+
+  @Override
+  protected void doCommit(DefaultTransactionStatus status) throws TransactionException {
+    LOGGER.debug("Committing Couchbase Transaction with status {}", status);
+  }
+
+  @Override
+  protected void doRollback(DefaultTransactionStatus status) throws TransactionException {
+    LOGGER.warn("Rolling back Couchbase Transaction with status {}", status);
+  }
+
+  @Override
+  protected void doCleanupAfterCompletion(Object transaction) {
+    LOGGER.trace("Performing cleanup of Couchbase Transaction {}", transaction);
+  }
+
+  @Override
+  public void destroy() {
+  }
+
+  @Override
+  public Object getResourceFactory() {
+    return template.getCouchbaseClientFactory();
+  }
+
+  private static CouchbaseTransactionObject extractTransaction(Object transaction) {
+    Assert.isInstanceOf(CouchbaseTransactionObject.class, transaction,
+      () -> String.format("Expected to find a %s but it turned out to be %s.", CouchbaseTransactionObject.class,
+        transaction.getClass()));
+
+    return (CouchbaseTransactionObject) transaction;
+  }
+
+  public static class CouchbaseResourceHolder extends ResourceHolderSupport {
+
+    private volatile TransactionAttemptContext attemptContext;
+    private volatile ReactiveTransactionAttemptContext attemptContextReactive;
+    private volatile ClientSession session = new ClientSessionImpl();
+
+    public CouchbaseResourceHolder(TransactionAttemptContext attemptContext) {
+      this.attemptContext = attemptContext;
+    }
+
+    public TransactionAttemptContext getAttemptContext() {
+      return attemptContext;
+    }
+
+    public void setAttemptContext(TransactionAttemptContext attemptContext) {
+      this.attemptContext = attemptContext;
+    }
+
+    public ReactiveTransactionAttemptContext getAttemptContextReactive() {
+      return attemptContext!= null ? AttemptContextReactiveAccessor.getACR(attemptContext) : attemptContextReactive;
+    }
+    public void setAttemptContextReactive(ReactiveTransactionAttemptContext attemptContextReactive) {
+      this.attemptContextReactive = attemptContextReactive;
+    }
+
+    public ClientSession getSession() {
+      return session;
+    }
+
+    public void setSession(ClientSession session){
+      this.session = session;
+    }
+
+    @Override
+    public String toString() {
+      return "CouchbaseResourceHolder{" +
+        "attemptContext=" + attemptContext +
+        '}';
+    }
+
+  }
+
+  protected static class CouchbaseTransactionObject implements SmartTransactionObject {
+
+    final CouchbaseResourceHolder resourceHolder;
+
+    CouchbaseTransactionObject(CouchbaseResourceHolder resourceHolderIn) {
+      resourceHolder = resourceHolderIn;
+    }
+
+    @Override
+    public boolean isRollbackOnly() {
+      return resourceHolder != null && resourceHolder.isRollbackOnly();
+    }
+
+    @Override
+    public void flush() {
+      TransactionSynchronizationUtils.triggerFlush();
+    }
+
+    public boolean hasResourceHolder() {
+      return resourceHolder != null;
+    }
+
+    @Override
+    public String toString() {
+      return "CouchbaseTransactionObject{" +
+        "resourceHolder=" + resourceHolder +
+        '}';
+    }
+  }
+
+}
diff --git a/src/main/java/com/example/demo/CouchbaseTransactionalTemplate.java b/src/main/java/com/example/demo/CouchbaseTransactionalTemplate.java
new file mode 100644
index 00000000..c0098a9d
--- /dev/null
+++ b/src/main/java/com/example/demo/CouchbaseTransactionalTemplate.java
@@ -0,0 +1,67 @@
+package com.example.demo;
+
+import com.couchbase.client.core.transaction.CoreTransactionAttemptContext;
+import com.couchbase.client.core.transaction.CoreTransactionGetResult;
+import com.couchbase.client.java.codec.Transcoder;
+import com.couchbase.client.java.transactions.ReactiveTransactionAttemptContext;
+import com.couchbase.client.java.transactions.TransactionAttemptContext;
+import com.couchbase.client.java.transactions.TransactionGetResult;
+import org.springframework.data.couchbase.core.CouchbaseTemplate;
+import org.springframework.data.couchbase.core.ReactiveCouchbaseTemplate;
+import org.springframework.data.couchbase.transaction.ReactiveCouchbaseResourceHolder;
+import org.springframework.transaction.support.TransactionSynchronizationManager;
+
+import static com.couchbase.client.java.transactions.internal.ConverterUtil.makeCollectionIdentifier;
+
+public class CouchbaseTransactionalTemplate {
+
+	private final CouchbaseTemplate template;
+
+	public CouchbaseTransactionalTemplate(CouchbaseTemplate template) {
+		this.template = template;
+	}
+
+	public <T> SpringTransactionGetResult<T> findById(String id, Class<T> domainType) {
+		try {
+			CoreTransactionAttemptContext ctx = getContext();
+			CoreTransactionGetResult getResult = ctx.get(  makeCollectionIdentifier(template.getCouchbaseClientFactory().getDefaultCollection().async()) , id).block();
+
+			T t = template.support().decodeEntity(id, new String(getResult.contentAsBytes()), getResult.cas(), domainType,
+					null, null, null);
+			return new SpringTransactionGetResult<>(t, getResult);
+		} catch (Exception e) {
+			e.printStackTrace();
+			throw e;
+		}
+
+	}
+
+	public <T> void replaceById(CoreTransactionGetResult getResult, T entity) {
+		CoreTransactionAttemptContext ctx = getContext();
+		Transcoder transCoder = template.getCouchbaseClientFactory().getCluster().environment().transcoder();
+		Transcoder.EncodedValue encoded = transCoder.encode(template.support().encodeEntity(entity).export());
+		ctx.replace(getResult, encoded.encoded());
+	}
+
+	private CoreTransactionAttemptContext getContext() {
+		ReactiveCouchbaseResourceHolder resource = (ReactiveCouchbaseResourceHolder) TransactionSynchronizationManager
+				.getResource(template.getCouchbaseClientFactory());
+		CoreTransactionAttemptContext atr;
+		if (resource != null) {
+			atr = resource.getCore();
+		} else {
+			ReactiveCouchbaseResourceHolder holder = (ReactiveCouchbaseResourceHolder) TransactionSynchronizationManager
+					.getResource(template.getCouchbaseClientFactory().getCluster());
+			atr = holder.getCore();
+		}
+		return atr;
+	}
+
+
+	public static ReactiveCouchbaseResourceHolder getSession(ReactiveCouchbaseTemplate template) {
+		ReactiveCouchbaseResourceHolder resource = (ReactiveCouchbaseResourceHolder) TransactionSynchronizationManager
+				.getResource(template.getCouchbaseClientFactory());
+		return resource;
+	}
+
+}
diff --git a/src/main/java/com/example/demo/SpringTransactionGetResult.java b/src/main/java/com/example/demo/SpringTransactionGetResult.java
new file mode 100644
index 00000000..27ede4aa
--- /dev/null
+++ b/src/main/java/com/example/demo/SpringTransactionGetResult.java
@@ -0,0 +1,31 @@
+package com.example.demo;
+
+import com.couchbase.client.core.transaction.CoreTransactionGetResult;
+import com.couchbase.client.java.transactions.TransactionGetResult;
+
+public class SpringTransactionGetResult<T> {
+
+  private final T value;
+  private final CoreTransactionGetResult inner;
+
+  public SpringTransactionGetResult(T value, CoreTransactionGetResult inner) {
+    this.value = value;
+    this.inner = inner;
+  }
+
+  public T getValue() {
+    return value;
+  }
+
+  public CoreTransactionGetResult getInner() {
+    return inner;
+  }
+
+  @Override
+  public String toString() {
+    return "SpringTransactionGetResult{" +
+            "value=" + value +
+            ", inner=" + inner +
+            '}';
+  }
+}
diff --git a/src/main/java/org/springframework/data/couchbase/CouchbaseClientFactory.java b/src/main/java/org/springframework/data/couchbase/CouchbaseClientFactory.java
index 51781a7d..70a6c922 100644
--- a/src/main/java/org/springframework/data/couchbase/CouchbaseClientFactory.java
+++ b/src/main/java/org/springframework/data/couchbase/CouchbaseClientFactory.java
@@ -18,6 +18,9 @@ package org.springframework.data.couchbase;
 
 import java.io.Closeable;
 
+import com.couchbase.client.core.transaction.CoreTransactionAttemptContext;
+import com.couchbase.client.java.transactions.ReactiveTransactionAttemptContext;
+import com.couchbase.client.java.transactions.config.TransactionOptions;
 import org.springframework.dao.support.PersistenceExceptionTranslator;
 
 import com.couchbase.client.java.Bucket;
@@ -73,4 +76,10 @@ public interface CouchbaseClientFactory extends Closeable {
 	 */
 	PersistenceExceptionTranslator getExceptionTranslator();
 
+	CoreTransactionAttemptContext getCore(TransactionOptions options,
+										  CoreTransactionAttemptContext atr);
+
+	//CouchbaseClientFactory with(CouchbaseTransactionalOperator txOp);
+
+	//CouchbaseTransactionalOperator getTransactionalOperator();
 }
diff --git a/src/main/java/org/springframework/data/couchbase/ReactiveCouchbaseClientFactory.java b/src/main/java/org/springframework/data/couchbase/ReactiveCouchbaseClientFactory.java
new file mode 100644
index 00000000..13f0f977
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/ReactiveCouchbaseClientFactory.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright 2016-2021 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.couchbase;
+
+import com.couchbase.client.core.transaction.CoreTransactionAttemptContext;
+import com.couchbase.client.java.Bucket;
+import com.couchbase.client.java.Cluster;
+import com.couchbase.client.java.ClusterInterface;
+import com.couchbase.client.java.Collection;
+import com.couchbase.client.java.Scope;
+import com.couchbase.client.java.transactions.ReactiveTransactionAttemptContext;
+import com.couchbase.client.java.transactions.config.TransactionOptions;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
+import org.springframework.data.couchbase.transaction.ReactiveCouchbaseResourceHolder;
+import reactor.core.publisher.Mono;
+
+import org.springframework.dao.support.PersistenceExceptionTranslator;
+
+import java.io.IOException;
+
+/**
+ * Interface for factories creating reactive {@link Cluster} instances.
+ *
+ * @author Mark Paluch
+ * @author Christoph Strobl
+ * @author Mathieu Ouellet
+ * @since 2.0
+ */
+public interface ReactiveCouchbaseClientFactory /*extends CodecRegistryProvider*/ {
+
+	/**
+	 * Provides access to the managed SDK {@link Cluster} reference.
+	 */
+	Mono<ClusterInterface> getCluster();
+
+	/**
+	 * Provides access to the managed SDK {@link Cluster} reference.
+	 */
+	ClusterInterface getBlockingCluster();
+
+	/**
+	 * Provides access to the managed SDK {@link Bucket} reference.
+	 */
+	Mono<Bucket> getBucket();
+
+	/**
+	 * Provides access to the managed SDK {@link Scope} reference.
+	 */
+	Mono<Scope> getScope();
+
+	/**
+	 * Provides access to the managed SDK {@link Scope} reference without block()
+	 */
+	 Scope getBlockingScope(String scopeName);
+
+	/**
+	 * Provides access to a collection (identified by its name) in managed SDK {@link Scope} reference.
+	 *
+	 * @param name the name of the collection. If null is passed in, the default collection is assumed.
+	 */
+	Mono<Collection> getCollection(String name);
+
+	/**
+	 * Provides access to a collection (identified by its name) without block()
+	 *
+	 * @param name the name of the collection. If null is passed in, the default collection is assumed.
+	 */
+	 Collection getBlockingCollection(String collectionName);
+
+	/**
+	 * Provides access to the default collection.
+	 */
+	Mono<Collection> getDefaultCollection();
+
+	/**
+	 * Returns a new {@link CouchbaseClientFactory} set to the scope given as an argument.
+	 *
+	 * @param scopeName the name of the scope to use for all collection access.
+	 * @return a new client factory, bound to the other scope.
+	 */
+	ReactiveCouchbaseClientFactory withScope(String scopeName);
+
+	/**
+	 * The exception translator used on the factory.
+	 */
+	PersistenceExceptionTranslator getExceptionTranslator();
+
+	Mono<ReactiveCouchbaseResourceHolder> getTransactionResources(TransactionOptions options);
+
+	String getBucketName();
+
+	String getScopeName();
+
+	void close() throws IOException;
+
+	ReactiveCouchbaseResourceHolder getTransactionResources(TransactionOptions options, CoreTransactionAttemptContext ctx);
+
+	/*
+	 * (non-Javadoc)
+	 * @see org.springframework.data.mongodb.ReactiveMongoDatabaseFactory#withSession(com.mongodb.session.ClientSession)
+	 */
+	ReactiveCouchbaseClientFactory withCore(ReactiveCouchbaseResourceHolder core);
+
+	/*
+	 * (non-Javadoc)
+	 * @see org.springframework.data.mongodb.ReactiveMongoDatabaseFactory#with(com.mongodb.session.ClientSession)
+	 */
+	ReactiveCouchbaseClientFactory with(CouchbaseTransactionalOperator txOp);
+
+	/*
+	 * (non-Javadoc)
+	 * @see org.springframework.data.mongodb.ReactiveMongoDatabaseFactory#isTransactionActive()
+	 */
+	boolean isTransactionActive();
+
+	CouchbaseTransactionalOperator getTransactionalOperator();
+}
diff --git a/src/main/java/org/springframework/data/couchbase/SimpleCouchbaseClientFactory.java b/src/main/java/org/springframework/data/couchbase/SimpleCouchbaseClientFactory.java
index b97b57f9..f6d70244 100644
--- a/src/main/java/org/springframework/data/couchbase/SimpleCouchbaseClientFactory.java
+++ b/src/main/java/org/springframework/data/couchbase/SimpleCouchbaseClientFactory.java
@@ -15,8 +15,12 @@
  */
 package org.springframework.data.couchbase;
 
+import java.time.Duration;
+import java.time.temporal.ChronoUnit;
 import java.util.function.Supplier;
 
+import com.couchbase.client.core.transaction.CoreTransactionAttemptContext;
+import com.couchbase.client.java.transactions.config.TransactionOptions;
 import org.springframework.dao.support.PersistenceExceptionTranslator;
 import org.springframework.data.couchbase.core.CouchbaseExceptionTranslator;
 
@@ -28,7 +32,11 @@ import com.couchbase.client.java.Cluster;
 import com.couchbase.client.java.ClusterOptions;
 import com.couchbase.client.java.Collection;
 import com.couchbase.client.java.Scope;
+import com.couchbase.client.java.codec.JsonSerializer;
 import com.couchbase.client.java.env.ClusterEnvironment;
+import com.couchbase.client.java.transactions.AttemptContextReactiveAccessor;
+import com.couchbase.client.java.transactions.config.TransactionsCleanupConfig;
+import com.couchbase.client.java.transactions.config.TransactionsConfig;
 
 /**
  * The default implementation of a {@link CouchbaseClientFactory}.
@@ -42,6 +50,7 @@ public class SimpleCouchbaseClientFactory implements CouchbaseClientFactory {
 	private final Bucket bucket;
 	private final Scope scope;
 	private final PersistenceExceptionTranslator exceptionTranslator;
+	//private JsonSerializer serializer = null;
 
 	public SimpleCouchbaseClientFactory(final String connectionString, final Authenticator authenticator,
 										final String bucketName) {
@@ -50,7 +59,10 @@ public class SimpleCouchbaseClientFactory implements CouchbaseClientFactory {
 
 	public SimpleCouchbaseClientFactory(final String connectionString, final Authenticator authenticator,
 										final String bucketName, final String scopeName) {
-		this(new OwnedSupplier<>(Cluster.connect(connectionString, ClusterOptions.clusterOptions(authenticator))),
+		this(new OwnedSupplier<>(Cluster.connect(connectionString, ClusterOptions.clusterOptions(authenticator)
+						// todo gp disabling cleanupLostAttempts to simplify output during development
+						.environment(env -> env.transactionsConfig(
+								TransactionsConfig.cleanupConfig(TransactionsCleanupConfig.cleanupLostAttempts(false)))))),
 				bucketName, scopeName);
 	}
 
@@ -60,10 +72,12 @@ public class SimpleCouchbaseClientFactory implements CouchbaseClientFactory {
 				new OwnedSupplier<>(
 						Cluster.connect(connectionString, ClusterOptions.clusterOptions(authenticator).environment(environment))),
 				bucketName, scopeName);
+		//this.serializer = environment.jsonSerializer();
 	}
 
 	public SimpleCouchbaseClientFactory(final Cluster cluster, final String bucketName, final String scopeName) {
 		this(() -> cluster, bucketName, scopeName);
+		//this.serializer = cluster.environment().jsonSerializer();
 	}
 
 	private SimpleCouchbaseClientFactory(final Supplier<Cluster> cluster, final String bucketName,
@@ -97,9 +111,9 @@ public class SimpleCouchbaseClientFactory implements CouchbaseClientFactory {
 	@Override
 	public Collection getCollection(final String collectionName) {
 		final Scope scope = getScope();
-		if (collectionName == null) {
+		if (collectionName == null || CollectionIdentifier.DEFAULT_COLLECTION.equals(collectionName)) {
 			if (!scope.name().equals(CollectionIdentifier.DEFAULT_SCOPE)) {
-				throw new IllegalStateException("A collectionName must be provided if a non-default scope is used!");
+				throw new IllegalStateException("A collectionName must be provided if a non-default scope is used");
 			}
 			return getBucket().defaultCollection();
 		}
@@ -116,11 +130,38 @@ public class SimpleCouchbaseClientFactory implements CouchbaseClientFactory {
 		return exceptionTranslator;
 	}
 
+	@Override
+	public CoreTransactionAttemptContext getCore(TransactionOptions options, CoreTransactionAttemptContext atr) {
+		// can't we just use AttemptContextReactive everywhere? Instead of creating AttemptContext(atr), then
+		// accessing at.getACR() ?
+		if (atr == null) {
+			atr = AttemptContextReactiveAccessor
+					.newCoreTranactionAttemptContext(AttemptContextReactiveAccessor.reactive(getCluster().transactions()));
+		}
+
+		return atr;
+	}
+
+	// @Override
+	// public CouchbaseClientFactory with(CouchbaseStuffHandle txOp) {
+	// return new SimpleCouchbaseClientFactory(cluster, bucket.name(), scope.name(), txOp);
+	// }
+
+	// @Override
+	// public CouchbaseStuffHandle getTransactionalOperator() {
+	// return (CouchbaseStuffHandle) transactionalOperator;
+	// }
+
 	@Override
 	public void close() {
-		if (cluster instanceof OwnedSupplier) {
-			cluster.get().disconnect();
+		// todo gp
+		// if (cluster instanceof OwnedSupplier) {
+		// cluster.get().disconnect();
+		// }
 	}
+
+	private static Duration now() {
+		return Duration.of(System.nanoTime(), ChronoUnit.NANOS);
 	}
 
 }
diff --git a/src/main/java/org/springframework/data/couchbase/SimpleReactiveCouchbaseClientFactory.java b/src/main/java/org/springframework/data/couchbase/SimpleReactiveCouchbaseClientFactory.java
new file mode 100644
index 00000000..5e90fc7e
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/SimpleReactiveCouchbaseClientFactory.java
@@ -0,0 +1,402 @@
+package org.springframework.data.couchbase;
+
+import static com.couchbase.client.core.io.CollectionIdentifier.DEFAULT_COLLECTION;
+import static com.couchbase.client.core.io.CollectionIdentifier.DEFAULT_SCOPE;
+
+import com.couchbase.client.core.transaction.CoreTransactionAttemptContext;
+import com.couchbase.client.java.ClusterInterface;
+import com.couchbase.client.java.codec.JsonSerializer;
+import com.couchbase.client.java.transactions.AttemptContextReactiveAccessor;
+import com.couchbase.client.java.transactions.Transactions;
+import com.couchbase.client.java.transactions.config.TransactionOptions;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
+import org.springframework.data.couchbase.transaction.ReactiveCouchbaseResourceHolder;
+import reactor.core.publisher.Mono;
+
+import java.io.IOException;
+
+import org.springframework.aop.framework.ProxyFactory;
+import org.springframework.dao.DataAccessException;
+import org.springframework.dao.support.PersistenceExceptionTranslator;
+import org.springframework.data.couchbase.core.CouchbaseExceptionTranslator;
+import org.springframework.data.couchbase.transaction.SessionAwareMethodInterceptor;
+import org.springframework.util.ObjectUtils;
+
+import com.couchbase.client.java.Bucket;
+import com.couchbase.client.java.Cluster;
+import com.couchbase.client.java.Collection;
+import com.couchbase.client.java.Scope;
+
+public class SimpleReactiveCouchbaseClientFactory implements ReactiveCouchbaseClientFactory {
+	final Mono<ClusterInterface> cluster;
+	final ClusterInterface theCluster;
+	final String bucketName;
+	final String scopeName;
+	final PersistenceExceptionTranslator exceptionTranslator;
+	JsonSerializer serializer;
+	Transactions transactions;
+	CouchbaseTransactionalOperator transactionalOperator;
+
+	public SimpleReactiveCouchbaseClientFactory(Cluster cluster, String bucketName, String scopeName,
+												CouchbaseTransactionalOperator transactionalOperator) {
+		this.cluster = Mono.just(cluster);
+		this.theCluster = cluster;
+		this.bucketName = bucketName;
+		this.scopeName = scopeName;
+		this.exceptionTranslator = new CouchbaseExceptionTranslator();
+		this.serializer = cluster.environment().jsonSerializer();
+		this.transactions = cluster.transactions();
+		this.transactionalOperator = transactionalOperator;
+	}
+
+	public SimpleReactiveCouchbaseClientFactory(Cluster cluster, String bucketName, String scopeName) {
+		this(cluster, bucketName, scopeName, null);
+	}
+
+	@Override
+	public Mono<ClusterInterface> getCluster() {
+		return cluster;
+	}
+
+
+	@Override
+	public ClusterInterface getBlockingCluster() {
+		return theCluster;
+	}
+
+	@Override
+	public Mono<Bucket> getBucket() {
+		return cluster.map((c) -> c.bucket(bucketName));
+	}
+
+	@Override
+	public String getBucketName() {
+		return bucketName;
+	}
+
+	@Override
+	public Mono<Scope> getScope() {
+		return cluster.map((c) -> c.bucket(bucketName).scope(scopeName != null ? scopeName : DEFAULT_SCOPE));
+	}
+
+	@Override
+	public Scope getBlockingScope(String scopeName) {
+		return theCluster.bucket(bucketName).scope(scopeName != null ? scopeName : (this.scopeName != null ? this.scopeName : DEFAULT_SCOPE));
+	}
+
+	@Override
+	public String getScopeName() {
+		return scopeName;
+	}
+
+	@Override
+	public Mono<Collection> getCollection(String collectionName) {
+		if (getScopeName() != null && !DEFAULT_SCOPE.equals(getScopeName())) {
+			if (collectionName == null || DEFAULT_COLLECTION.equals(collectionName)) {
+				throw new IllegalStateException("A collectionName must be provided if a non-default scope is used.");
+			}
+		}
+		if (getScopeName() == null || DEFAULT_SCOPE.equals(getScopeName())) {
+			if (collectionName != null && !DEFAULT_COLLECTION.equals(collectionName)) {
+				throw new IllegalStateException(
+						"A collectionName must be null or " + DEFAULT_COLLECTION + " if scope is null or " + DEFAULT_SCOPE);
+			}
+		}
+		return getScope().map((s) -> s.collection(collectionName != null ? collectionName : DEFAULT_COLLECTION));
+	}
+
+	@Override
+	public Collection getBlockingCollection(String collectionName) {
+		if (getScopeName() != null && !DEFAULT_SCOPE.equals(getScopeName())) {
+			if (collectionName == null || DEFAULT_COLLECTION.equals(collectionName)) {
+				throw new IllegalStateException("A collectionName must be provided if a non-default scope is used.");
+			}
+		}
+		if (getScopeName() == null || DEFAULT_SCOPE.equals(getScopeName())) {
+			if (collectionName != null && !DEFAULT_COLLECTION.equals(collectionName)) {
+				throw new IllegalStateException(
+						"A collectionName must be null or " + DEFAULT_COLLECTION + " if scope is null or " + DEFAULT_SCOPE);
+			}
+		}
+		return theCluster.bucket(bucketName).scope(scopeName != null ? scopeName : DEFAULT_SCOPE).collection(collectionName != null ? collectionName : DEFAULT_COLLECTION);
+	}
+
+	@Override
+	public Mono<Collection> getDefaultCollection() {
+		if (getScopeName() != null && DEFAULT_SCOPE.equals(getScopeName())) {
+			throw new IllegalStateException("A collectionName must be provided if a non-default scope is used.");
+		}
+		return cluster.map((c) -> c.bucket(bucketName).defaultCollection());
+	}
+
+	@Override
+	public ReactiveCouchbaseClientFactory withScope(String scopeName) {
+		return new SimpleReactiveCouchbaseClientFactory((Cluster) cluster.block(), bucketName,
+				scopeName != null ? scopeName : this.scopeName);
+	}
+
+	@Override
+	public PersistenceExceptionTranslator getExceptionTranslator() {
+		return exceptionTranslator;
+	}
+
+	@Override
+	public void close() {
+		cluster.block().disconnect();
+	}
+
+	@Override
+	public Mono<ReactiveCouchbaseResourceHolder> getTransactionResources(TransactionOptions options) { 
+	return Mono.just(new ReactiveCouchbaseResourceHolder(null));
+	}
+
+	@Override
+	public ReactiveCouchbaseResourceHolder getTransactionResources(TransactionOptions options,
+																   CoreTransactionAttemptContext atr) {
+		if (atr == null) {
+			atr = AttemptContextReactiveAccessor
+					.newCoreTranactionAttemptContext(AttemptContextReactiveAccessor.reactive(transactions));
+		}
+		return new ReactiveCouchbaseResourceHolder(atr);
+	}
+
+	@Override
+	public ReactiveCouchbaseClientFactory withCore(ReactiveCouchbaseResourceHolder holder) {
+		return new CoreTransactionAttemptContextBoundCouchbaseClientFactory(holder, this, transactions);
+	}
+
+	@Override
+	public boolean isTransactionActive() {
+		return false;
+	}
+
+	@Override
+	public CouchbaseTransactionalOperator getTransactionalOperator() {
+		return transactionalOperator;
+	}
+
+	@Override
+	public ReactiveCouchbaseClientFactory with(CouchbaseTransactionalOperator txOp) {
+		return new SimpleReactiveCouchbaseClientFactory((Cluster) getCluster().block(), bucketName, scopeName, txOp);
+	}
+
+	private <T> T createProxyInstance(ReactiveCouchbaseResourceHolder session, T target, Class<T> targetType) {
+
+		ProxyFactory factory = new ProxyFactory();
+		factory.setTarget(target);
+		factory.setInterfaces(targetType);
+		factory.setOpaque(true);
+
+		factory.addAdvice(new SessionAwareMethodInterceptor<>(session, target, ReactiveCouchbaseResourceHolder.class,
+				ClusterInterface.class, this::proxyDatabase, Collection.class, this::proxyCollection));
+
+		return targetType.cast(factory.getProxy(target.getClass().getClassLoader()));
+	}
+
+	private Collection proxyCollection(ReactiveCouchbaseResourceHolder session, Collection c) {
+		return createProxyInstance(session, c, Collection.class);
+	}
+
+	private ClusterInterface proxyDatabase(ReactiveCouchbaseResourceHolder session, ClusterInterface cluster) {
+		return createProxyInstance(session, cluster, ClusterInterface.class);
+	}
+
+	/**
+	 * {@link CoreTransactionAttemptContext} bound TODO decorating the database with a
+	 * {@link SessionAwareMethodInterceptor}.
+	 *
+	 * @author Christoph Strobl
+	 * @since 2.1
+	 */
+	static final class CoreTransactionAttemptContextBoundCouchbaseClientFactory
+			implements ReactiveCouchbaseClientFactory {
+
+		private final ReactiveCouchbaseResourceHolder transactionResources;
+		private final ReactiveCouchbaseClientFactory delegate;
+		// private final Transactions transactions;
+
+		CoreTransactionAttemptContextBoundCouchbaseClientFactory(ReactiveCouchbaseResourceHolder transactionResources,
+																 ReactiveCouchbaseClientFactory delegate, Transactions transactions) {
+			this.transactionResources = transactionResources;
+			this.delegate = delegate;
+			// this.transactions = transactions;
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * @see org.springframework.data.mongodb.ReactiveMongoDatabaseFactory#getMongoDatabase()
+		 */
+		@Override
+		public Mono<ClusterInterface> getCluster() throws DataAccessException {
+			return delegate.getCluster().map(this::decorateDatabase);
+		}
+
+		@Override
+		public ClusterInterface getBlockingCluster() throws DataAccessException {
+			return decorateDatabase(delegate.getBlockingCluster());
+		}
+
+		@Override
+		public Mono<Bucket> getBucket() {
+			return delegate.getBucket();
+		}
+
+		@Override
+		public Mono<Scope> getScope() {
+			return delegate.getScope();
+		}
+
+		@Override
+		public Mono<Collection> getCollection(String name) {
+			return delegate.getCollection(name);
+		}
+
+		@Override
+		public Collection getBlockingCollection(String collectionName) {
+			return delegate.getBlockingCollection(collectionName);
+		}
+
+		@Override
+		public Scope getBlockingScope(String scopeName) {
+			return delegate.getBlockingScope(scopeName);
+		}
+		@Override
+		public Mono<Collection> getDefaultCollection() {
+			return delegate.getDefaultCollection();
+		}
+
+		@Override
+		public ReactiveCouchbaseClientFactory withScope(String scopeName) {
+			return delegate.withScope(scopeName);
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * @see org.springframework.data.mongodb.ReactiveMongoDatabaseFactory#getExceptionTranslator()
+		 */
+		@Override
+		public PersistenceExceptionTranslator getExceptionTranslator() {
+			return delegate.getExceptionTranslator();
+		}
+
+		@Override
+		public String getBucketName() {
+			return delegate.getBucketName();
+		}
+
+		@Override
+		public String getScopeName() {
+			return delegate.getScopeName();
+		}
+
+		@Override
+		public void close() throws IOException {
+			delegate.close();
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * @see org.springframework.data.mongodb.ReactiveMongoDatabaseFactory#getSession(com.mongodb.CoreTransactionAttemptContextOptions)
+		 */
+
+		@Override
+		public Mono<ReactiveCouchbaseResourceHolder> getTransactionResources(TransactionOptions options) {
+			return Mono.just(transactionResources);
+		}
+
+		@Override
+		public ReactiveCouchbaseResourceHolder getTransactionResources(TransactionOptions options,
+																	   CoreTransactionAttemptContext atr) {
+			ReactiveCouchbaseResourceHolder holder = delegate.getTransactionResources(options, atr);
+			return holder;
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * @see org.springframework.data.mongodb.ReactiveMongoDatabaseFactory#withSession(com.mongodb.session.CoreTransactionAttemptContext)
+		 */
+		@Override
+		public ReactiveCouchbaseClientFactory withCore(ReactiveCouchbaseResourceHolder core) {
+			return delegate.withCore(core);
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * @see org.springframework.data.mongodb.ReactiveMongoDatabaseFactory#isTransactionActive()
+		 */
+		@Override
+		public boolean isTransactionActive() {
+			return transactionResources != null && transactionResources.hasActiveTransaction();
+		}
+
+		@Override
+		public CouchbaseTransactionalOperator getTransactionalOperator() {
+			return delegate.getTransactionalOperator();
+		}
+
+		@Override
+		public ReactiveCouchbaseClientFactory with(CouchbaseTransactionalOperator txOp) {
+			return delegate.with(txOp);
+		}
+
+		private ClusterInterface decorateDatabase(ClusterInterface database) {
+			return createProxyInstance(transactionResources, database, ClusterInterface.class);
+		}
+
+		private ClusterInterface proxyDatabase(ReactiveCouchbaseResourceHolder session, ClusterInterface database) {
+			return createProxyInstance(session, database, ClusterInterface.class);
+		}
+
+		private Collection proxyCollection(ReactiveCouchbaseResourceHolder session, Collection collection) {
+			return createProxyInstance(session, collection, Collection.class);
+		}
+
+		private <T> T createProxyInstance(ReactiveCouchbaseResourceHolder session, T target, Class<T> targetType) {
+
+			ProxyFactory factory = new ProxyFactory();
+			factory.setTarget(target);
+			factory.setInterfaces(targetType);
+			factory.setOpaque(true);
+
+			factory.addAdvice(new SessionAwareMethodInterceptor<>(session, target, ReactiveCouchbaseResourceHolder.class,
+					ClusterInterface.class, this::proxyDatabase, Collection.class, this::proxyCollection));
+
+			return targetType.cast(factory.getProxy(target.getClass().getClassLoader()));
+		}
+
+		public ReactiveCouchbaseResourceHolder getTransactionResources() {
+			return this.transactionResources;
+		}
+
+		public ReactiveCouchbaseClientFactory getDelegate() {
+			return this.delegate;
+		}
+
+		@Override
+		public boolean equals(Object o) {
+			if (this == o)
+				return true;
+			if (o == null || getClass() != o.getClass())
+				return false;
+
+			CoreTransactionAttemptContextBoundCouchbaseClientFactory that = (CoreTransactionAttemptContextBoundCouchbaseClientFactory) o;
+
+			if (!ObjectUtils.nullSafeEquals(this.transactionResources, that.transactionResources)) {
+				return false;
+			}
+			return ObjectUtils.nullSafeEquals(this.delegate, that.delegate);
+		}
+
+		@Override
+		public int hashCode() {
+			int result = ObjectUtils.nullSafeHashCode(this.transactionResources);
+			result = 31 * result + ObjectUtils.nullSafeHashCode(this.delegate);
+			return result;
+		}
+
+		public String toString() {
+			return "SimpleReactiveCouchbaseDatabaseFactory.CoreTransactionAttemptContextBoundCouchDbFactory(session="
+					+ this.getTransactionResources() + ", delegate=" + this.getDelegate() + ")";
+		}
+	}
+}
diff --git a/src/main/java/org/springframework/data/couchbase/cache/CouchbaseCache.java b/src/main/java/org/springframework/data/couchbase/cache/CouchbaseCache.java
index cfcd22b9..8df20f75 100644
--- a/src/main/java/org/springframework/data/couchbase/cache/CouchbaseCache.java
+++ b/src/main/java/org/springframework/data/couchbase/cache/CouchbaseCache.java
@@ -106,7 +106,7 @@ public class CouchbaseCache extends AbstractValueAdaptingCache {
 					name));
 		}
 
-		cacheWriter.put(cacheConfig.getCollectionName(), createCacheKey(key), value, cacheConfig.getExpiry(),
+		cacheWriter.put(cacheConfig.getCollectionName(), createCacheKey(key), toStoreValue(value), cacheConfig.getExpiry(),
 				cacheConfig.getValueTranscoder());
 	}
 
@@ -116,7 +116,7 @@ public class CouchbaseCache extends AbstractValueAdaptingCache {
 			return get(key);
 		}
 
-		Object result = cacheWriter.putIfAbsent(cacheConfig.getCollectionName(), createCacheKey(key), value,
+		Object result = cacheWriter.putIfAbsent(cacheConfig.getCollectionName(), createCacheKey(key), toStoreValue(value),
 				cacheConfig.getExpiry(), cacheConfig.getValueTranscoder());
 
 		if (result == null) {
diff --git a/src/main/java/org/springframework/data/couchbase/cache/CouchbaseCacheConfiguration.java b/src/main/java/org/springframework/data/couchbase/cache/CouchbaseCacheConfiguration.java
index 841815b4..db66a8d7 100644
--- a/src/main/java/org/springframework/data/couchbase/cache/CouchbaseCacheConfiguration.java
+++ b/src/main/java/org/springframework/data/couchbase/cache/CouchbaseCacheConfiguration.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2020 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -64,6 +64,7 @@ public class CouchbaseCacheConfiguration {
 	 * <ul>
 	 * <li>{@link String} to {@link byte byte[]} using UTF-8 encoding.</li>
 	 * <li>{@link SimpleKey} to {@link String}</li>
+	 * </ul>
 	 * 
 	 * @param registry must not be {@literal null}.
 	 */
@@ -85,6 +86,18 @@ public class CouchbaseCacheConfiguration {
 				valueTranscoder, collectionName);
 	}
 
+	/**
+	 * Set the collectinName to use.
+	 *
+	 * @param collectionName must not be {@literal null}.
+	 * @return new {@link CouchbaseCacheConfiguration}.
+	 */
+	public CouchbaseCacheConfiguration collection(final String collectionName) {
+		Assert.notNull(collectionName, "collectionName must not be null!");
+		return new CouchbaseCacheConfiguration(expiry, cacheNullValues, usePrefix, keyPrefix, conversionService,
+				valueTranscoder, collectionName);
+	}
+
 	/**
 	 * Sets a custom transcoder to use for reads and writes.
 	 *
diff --git a/src/main/java/org/springframework/data/couchbase/cache/CouchbaseCacheManager.java b/src/main/java/org/springframework/data/couchbase/cache/CouchbaseCacheManager.java
index a96c8e16..3ec1f1ff 100644
--- a/src/main/java/org/springframework/data/couchbase/cache/CouchbaseCacheManager.java
+++ b/src/main/java/org/springframework/data/couchbase/cache/CouchbaseCacheManager.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2020 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -228,7 +228,7 @@ public class CouchbaseCacheManager extends AbstractTransactionSupportingCacheMan
 
 		/**
 		 * Disable in-flight {@link org.springframework.cache.Cache} creation for unconfigured caches.
-		 * <p />
+		 * <p>
 		 * {@link CouchbaseCacheManager#getMissingCache(String)} returns {@literal null} for any unconfigured
 		 * {@link org.springframework.cache.Cache} instead of a new {@link CouchbaseCache} instance. This allows eg.
 		 * {@link org.springframework.cache.support.CompositeCacheManager} to chime in.
diff --git a/src/main/java/org/springframework/data/couchbase/config/AbstractCouchbaseConfiguration.java b/src/main/java/org/springframework/data/couchbase/config/AbstractCouchbaseConfiguration.java
index 2c9ff971..80f4e72b 100644
--- a/src/main/java/org/springframework/data/couchbase/config/AbstractCouchbaseConfiguration.java
+++ b/src/main/java/org/springframework/data/couchbase/config/AbstractCouchbaseConfiguration.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,19 +17,31 @@
 package org.springframework.data.couchbase.config;
 
 import static com.couchbase.client.java.ClusterOptions.clusterOptions;
+import static org.springframework.data.couchbase.config.BeanNames.COUCHBASE_MAPPING_CONTEXT;
+import static org.springframework.data.couchbase.config.BeanNames.COUCHBASE_TRANSACTIONS;
 
+import java.time.Duration;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
 
+import com.couchbase.client.core.msg.kv.DurabilityLevel;
+import com.couchbase.client.core.transaction.config.CoreTransactionsConfig;
+import com.couchbase.client.java.query.QueryScanConsistency;
+import com.couchbase.client.java.transactions.config.TransactionOptions;
+import com.couchbase.client.java.transactions.config.TransactionsCleanupConfig;
+import com.couchbase.client.java.transactions.config.TransactionsConfig;
 import org.springframework.beans.factory.config.BeanDefinition;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider;
 import org.springframework.context.annotation.Configuration;
+import org.springframework.context.annotation.Role;
 import org.springframework.core.type.filter.AnnotationTypeFilter;
 import org.springframework.data.convert.CustomConversions;
 import org.springframework.data.couchbase.CouchbaseClientFactory;
+import org.springframework.data.couchbase.ReactiveCouchbaseClientFactory;
 import org.springframework.data.couchbase.SimpleCouchbaseClientFactory;
+import org.springframework.data.couchbase.SimpleReactiveCouchbaseClientFactory;
 import org.springframework.data.couchbase.core.CouchbaseTemplate;
 import org.springframework.data.couchbase.core.ReactiveCouchbaseTemplate;
 import org.springframework.data.couchbase.core.convert.CouchbaseCustomConversions;
@@ -40,12 +52,22 @@ import org.springframework.data.couchbase.core.mapping.CouchbaseMappingContext;
 import org.springframework.data.couchbase.core.mapping.Document;
 import org.springframework.data.couchbase.repository.config.ReactiveRepositoryOperationsMapping;
 import org.springframework.data.couchbase.repository.config.RepositoryOperationsMapping;
+import org.springframework.data.couchbase.transaction.CouchbaseSimpleCallbackTransactionManager;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionManager;
+import org.springframework.data.couchbase.transaction.ReactiveCouchbaseTransactionManager;
+import org.springframework.data.couchbase.transaction.interceptor.CouchbaseTransactionInterceptor;
 import org.springframework.data.mapping.model.CamelCaseAbbreviatingFieldNamingStrategy;
 import org.springframework.data.mapping.model.FieldNamingStrategy;
 import org.springframework.data.mapping.model.PropertyNameFieldNamingStrategy;
+import org.springframework.transaction.annotation.AnnotationTransactionAttributeSource;
+import org.springframework.transaction.config.TransactionManagementConfigUtils;
+import org.springframework.transaction.interceptor.BeanFactoryTransactionAttributeSourceAdvisor;
+import org.springframework.transaction.interceptor.TransactionAttributeSource;
+import org.springframework.transaction.interceptor.TransactionInterceptor;
 import org.springframework.util.ClassUtils;
 import org.springframework.util.StringUtils;
 
+import com.couchbase.client.core.cnc.Event;
 import com.couchbase.client.core.deps.com.fasterxml.jackson.databind.DeserializationFeature;
 import com.couchbase.client.core.encryption.CryptoManager;
 import com.couchbase.client.core.env.Authenticator;
@@ -57,7 +79,6 @@ import com.couchbase.client.java.encryption.databind.jackson.EncryptionModule;
 import com.couchbase.client.java.env.ClusterEnvironment;
 import com.couchbase.client.java.json.JacksonTransformers;
 import com.couchbase.client.java.json.JsonValueModule;
-import com.couchbase.client.java.query.QueryScanConsistency;
 import com.fasterxml.jackson.databind.ObjectMapper;
 
 /**
@@ -123,15 +144,21 @@ public abstract class AbstractCouchbaseConfiguration {
 	 * @param couchbaseCluster the cluster reference from the SDK.
 	 * @return the initialized factory.
 	 */
-	@Bean
+	@Bean(name = BeanNames.COUCHBASE_CLIENT_FACTORY)
 	public CouchbaseClientFactory couchbaseClientFactory(final Cluster couchbaseCluster) {
 		return new SimpleCouchbaseClientFactory(couchbaseCluster, getBucketName(), getScopeName());
 	}
 
+	@Bean
+	public ReactiveCouchbaseClientFactory reactiveCouchbaseClientFactory(final Cluster couchbaseCluster) {
+		return new SimpleReactiveCouchbaseClientFactory(couchbaseCluster, getBucketName(), getScopeName());
+	}
+
 	@Bean(destroyMethod = "disconnect")
 	public Cluster couchbaseCluster(ClusterEnvironment couchbaseClusterEnvironment) {
-		return Cluster.connect(getConnectionString(),
+		Cluster c = Cluster.connect(getConnectionString(),
 				clusterOptions(authenticator()).environment(couchbaseClusterEnvironment));
+		return c;
 	}
 
 	@Bean(destroyMethod = "shutdown")
@@ -141,6 +168,9 @@ public abstract class AbstractCouchbaseConfiguration {
 			throw new CouchbaseException("non-shadowed Jackson not present");
 		}
 		builder.jsonSerializer(JacksonJsonSerializer.create(couchbaseObjectMapper()));
+		// todo gp only suitable for tests
+		TransactionsConfig.cleanupConfig(TransactionsCleanupConfig.cleanupLostAttempts(false));
+		builder.transactionsConfig(transactionsConfig());
 		configureEnvironment(builder);
 		return builder.build();
 	}
@@ -156,26 +186,31 @@ public abstract class AbstractCouchbaseConfiguration {
 
 	@Bean(name = BeanNames.COUCHBASE_TEMPLATE)
 	public CouchbaseTemplate couchbaseTemplate(CouchbaseClientFactory couchbaseClientFactory,
+											   ReactiveCouchbaseClientFactory reactiveCouchbaseClientFactory,
 											   MappingCouchbaseConverter mappingCouchbaseConverter, TranslationService couchbaseTranslationService) {
-		return new CouchbaseTemplate(couchbaseClientFactory, mappingCouchbaseConverter, couchbaseTranslationService,
-				getDefaultConsistency());
+		return new CouchbaseTemplate(couchbaseClientFactory, reactiveCouchbaseClientFactory, mappingCouchbaseConverter,
+				couchbaseTranslationService, getDefaultConsistency());
 	}
 
 	public CouchbaseTemplate couchbaseTemplate(CouchbaseClientFactory couchbaseClientFactory,
+											   ReactiveCouchbaseClientFactory reactiveCouchbaseClientFactory,
 											   MappingCouchbaseConverter mappingCouchbaseConverter) {
-		return couchbaseTemplate(couchbaseClientFactory, mappingCouchbaseConverter, new JacksonTranslationService());
+		return couchbaseTemplate(couchbaseClientFactory, reactiveCouchbaseClientFactory, mappingCouchbaseConverter,
+				new JacksonTranslationService());
 	}
 
 	@Bean(name = BeanNames.REACTIVE_COUCHBASE_TEMPLATE)
-	public ReactiveCouchbaseTemplate reactiveCouchbaseTemplate(CouchbaseClientFactory couchbaseClientFactory,
+	public ReactiveCouchbaseTemplate reactiveCouchbaseTemplate(
+			ReactiveCouchbaseClientFactory reactiveCouchbaseClientFactory,
 			MappingCouchbaseConverter mappingCouchbaseConverter, TranslationService couchbaseTranslationService) {
-		return new ReactiveCouchbaseTemplate(couchbaseClientFactory, mappingCouchbaseConverter, couchbaseTranslationService,
-				getDefaultConsistency());
+		return new ReactiveCouchbaseTemplate(reactiveCouchbaseClientFactory,  mappingCouchbaseConverter,
+				couchbaseTranslationService, getDefaultConsistency());
 	}
 
-	public ReactiveCouchbaseTemplate reactiveCouchbaseTemplate(CouchbaseClientFactory couchbaseClientFactory,
+	public ReactiveCouchbaseTemplate reactiveCouchbaseTemplate(
+			ReactiveCouchbaseClientFactory reactiveCouchbaseClientFactory,
 			MappingCouchbaseConverter mappingCouchbaseConverter) {
-		return reactiveCouchbaseTemplate(couchbaseClientFactory, mappingCouchbaseConverter,
+		return reactiveCouchbaseTemplate( reactiveCouchbaseClientFactory, mappingCouchbaseConverter,
 				new JacksonTranslationService());
 	}
 
@@ -254,8 +289,6 @@ public abstract class AbstractCouchbaseConfiguration {
 
 	/**
 	 * Creates a {@link MappingCouchbaseConverter} using the configured {@link #couchbaseMappingContext}.
-	 *
-	 * @throws Exception on Bean construction failure.
 	 */
 	@Bean
 	public MappingCouchbaseConverter mappingCouchbaseConverter(CouchbaseMappingContext couchbaseMappingContext,
@@ -283,9 +316,8 @@ public abstract class AbstractCouchbaseConfiguration {
 	/**
 	 * Creates a {@link CouchbaseMappingContext} equipped with entity classes scanned from the mapping base package.
 	 *
-	 * @throws Exception on Bean construction failure.
 	 */
-	@Bean
+	@Bean(COUCHBASE_MAPPING_CONTEXT)
 	public CouchbaseMappingContext couchbaseMappingContext(CustomConversions customConversions) throws Exception {
 		CouchbaseMappingContext mappingContext = new CouchbaseMappingContext();
 		mappingContext.setInitialEntitySet(getInitialEntitySet());
@@ -299,7 +331,6 @@ public abstract class AbstractCouchbaseConfiguration {
 	/**
 	 * Creates a {@link ObjectMapper} for the jsonSerializer of the ClusterEnvironment
 	 *
-	 * @throws Exception on Bean construction failure.
 	 * @return ObjectMapper
 	 */
 
@@ -314,6 +345,55 @@ public abstract class AbstractCouchbaseConfiguration {
 		return mapper;
 	}
 
+	/*****  ALL THIS TX SHOULD BE MOVED OUT INTO THE IMPL OF AbstractCouchbaseConfiguration *****/
+
+	@Bean(BeanNames.REACTIVE_COUCHBASE_TRANSACTION_MANAGER)
+	ReactiveCouchbaseTransactionManager reactiveTransactionManager(
+			ReactiveCouchbaseClientFactory reactiveCouchbaseClientFactory) {
+		return new ReactiveCouchbaseTransactionManager(reactiveCouchbaseClientFactory);
+	}
+
+//	@Bean(BeanNames.COUCHBASE_TRANSACTION_MANAGER)
+//	CouchbaseTransactionManager transactionManager(CouchbaseClientFactory couchbaseClientFactory) {
+//		return new CouchbaseTransactionManager(couchbaseClientFactory);
+//	}
+
+	// todo gp experimenting with making  CouchbaseSimpleCallbackTransactionManager the default - but it doesn't play
+	// nice with MR's changes to insert CouchbaseTransactionInterceptor
+	// todo mr THIS DOES NOT WORK WELL with @TestTransaction / @BeforeTransaction / @AfterTransaction etc.
+	// todo mr Maybe it is only useful with @Transactional?
+	@Bean(BeanNames.COUCHBASE_SIMPLE_CALLBACK_TRANSACTION_MANAGER)
+	CouchbaseSimpleCallbackTransactionManager callbackTransactionManager(ReactiveCouchbaseClientFactory clientFactory, TransactionOptions options) {
+		return new CouchbaseSimpleCallbackTransactionManager(clientFactory, options);
+	}
+
+	@Bean(BeanNames.COUCHBASE_TRANSACTION_MANAGER)
+	CouchbaseTransactionManager transactionManager(CouchbaseClientFactory clientFactory, TransactionOptions options) {
+		return new CouchbaseTransactionManager(clientFactory, options);
+	}
+
+	// todo gpx these would be per-transactions options so it seems odd to have a global bean?  Surely would want to configure everything at global level instead?
+	@Bean
+	public TransactionOptions transactionsOptions(){
+		return TransactionOptions.transactionOptions();
+	}
+
+	// todo gpx transactions config is now done in standard ClusterConfig - so I think we don't want a separate bean?
+	public TransactionsConfig.Builder transactionsConfig(){
+		return TransactionsConfig.builder().durabilityLevel(DurabilityLevel.NONE).timeout(Duration.ofMinutes(20));// for testing
+	}
+
+	/**
+	 * Blocking Transaction Manager
+	 *
+	 * @param couchbaseTemplate
+	 * @return
+	 */
+//	@Bean(BeanNames.COUCHBASE_CALLBACK_TRANSACTION_MANAGER)
+//	CouchbaseCallbackTransactionManager callbackTransactionManager(CouchbaseTemplate couchbaseTemplate, ReactiveCouchbaseTemplate couchbaseReactiveTemplate) {
+//		return new CouchbaseCallbackTransactionManager(couchbaseTemplate, couchbaseReactiveTemplate);
+//	}
+
 	/**
 	 * Configure whether to automatically create indices for domain types by deriving the from the entity or not.
 	 */
@@ -337,11 +417,9 @@ public abstract class AbstractCouchbaseConfiguration {
 	/**
 	 * Return the base package to scan for mapped {@link Document}s. Will return the package name of the configuration
 	 * class (the concrete class, not this one here) by default.
-	 * <p/>
 	 * <p>
 	 * So if you have a {@code com.acme.AppConfig} extending {@link AbstractCouchbaseConfiguration} the base package will
 	 * be considered {@code com.acme} unless the method is overridden to implement alternate behavior.
-	 * </p>
 	 *
 	 * @return the base package to scan for mapped {@link Document} classes or {@literal null} to not enable scanning for
 	 *         entities.
@@ -381,5 +459,33 @@ public abstract class AbstractCouchbaseConfiguration {
 	public QueryScanConsistency getDefaultConsistency() {
 		return null;
 	}
+/*
+	@Bean
+	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
+	public TransactionInterceptor transactionInterceptor(TransactionAttributeSource transactionAttributeSource) {
+		TransactionInterceptor interceptor = new CouchbaseTransactionInterceptor();
+		interceptor.setTransactionAttributeSource(transactionAttributeSource);
+		return interceptor;
+	}
+
+	@Bean
+	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
+	public TransactionAttributeSource transactionAttributeSource() {
+		return new AnnotationTransactionAttributeSource();
+	}
+
+	@Bean(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)
+	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
+	public BeanFactoryTransactionAttributeSourceAdvisor transactionAdvisor(
+			TransactionAttributeSource transactionAttributeSource, TransactionInterceptor transactionInterceptor) {
 
+		BeanFactoryTransactionAttributeSourceAdvisor advisor = new BeanFactoryTransactionAttributeSourceAdvisor();
+		advisor.setTransactionAttributeSource(transactionAttributeSource);
+		advisor.setAdvice(transactionInterceptor);
+		// if (this.enableTx != null) {
+		// advisor.setOrder(this.enableTx.<Integer>getNumber("order"));
+		// }
+		return advisor;
+	}
+ */
 }
diff --git a/src/main/java/org/springframework/data/couchbase/config/BeanNames.java b/src/main/java/org/springframework/data/couchbase/config/BeanNames.java
index cb9bf63e..100c841e 100644
--- a/src/main/java/org/springframework/data/couchbase/config/BeanNames.java
+++ b/src/main/java/org/springframework/data/couchbase/config/BeanNames.java
@@ -34,6 +34,8 @@ public class BeanNames {
 
 	public static final String COUCHBASE_CUSTOM_CONVERSIONS = "couchbaseCustomConversions";
 
+	public static final String COUCHBASE_TRANSACTIONS = "couchbaseTransactions";
+
 	/**
 	 * The name for the bean that stores custom mapping between repositories and their backing couchbaseOperations.
 	 */
@@ -59,4 +61,12 @@ public class BeanNames {
 	 * The name for the bean that will handle reactive audit trail marking of entities.
 	 */
 	public static final String REACTIVE_COUCHBASE_AUDITING_HANDLER = "reactiveCouchbaseAuditingHandler";
+
+	public static final String COUCHBASE_CLIENT_FACTORY = "couchbaseClientFactory";
+
+	public static final String REACTIVE_COUCHBASE_TRANSACTION_MANAGER = "reactiveCouchbaseTransactionManager";
+
+	public static final String COUCHBASE_TRANSACTION_MANAGER = "couchbaseTransactionManager";
+
+	public static final String COUCHBASE_SIMPLE_CALLBACK_TRANSACTION_MANAGER = "couchbaseSimpleCallbackTransactionManager";
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/AbstractTemplateSupport.java b/src/main/java/org/springframework/data/couchbase/core/AbstractTemplateSupport.java
new file mode 100644
index 00000000..8164f2cd
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/core/AbstractTemplateSupport.java
@@ -0,0 +1,226 @@
+/*
+ * Copyright 2021 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.couchbase.core;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.context.ApplicationContext;
+import org.springframework.data.couchbase.core.convert.CouchbaseConverter;
+import org.springframework.data.couchbase.core.convert.join.N1qlJoinResolver;
+import org.springframework.data.couchbase.core.convert.translation.TranslationService;
+import org.springframework.data.couchbase.core.mapping.CouchbaseDocument;
+import org.springframework.data.couchbase.core.mapping.CouchbasePersistentEntity;
+import org.springframework.data.couchbase.core.mapping.CouchbasePersistentProperty;
+import org.springframework.data.couchbase.core.mapping.event.AfterSaveEvent;
+import org.springframework.data.couchbase.core.mapping.event.CouchbaseMappingEvent;
+import org.springframework.data.couchbase.repository.support.MappingCouchbaseEntityInformation;
+import org.springframework.data.couchbase.repository.support.TransactionResultHolder;
+import org.springframework.data.couchbase.transaction.ReactiveCouchbaseResourceHolder;
+import org.springframework.data.mapping.PersistentPropertyAccessor;
+import org.springframework.data.mapping.context.MappingContext;
+import org.springframework.data.mapping.model.ConvertingPropertyAccessor;
+
+import com.couchbase.client.core.error.CouchbaseException;
+import org.springframework.util.ClassUtils;
+
+import java.util.Map;
+import java.util.Set;
+
+public abstract class AbstractTemplateSupport {
+
+	final ReactiveCouchbaseTemplate template;
+	final CouchbaseConverter converter;
+	final MappingContext<? extends CouchbasePersistentEntity<?>, CouchbasePersistentProperty> mappingContext;
+	final TranslationService translationService;
+	ApplicationContext applicationContext;
+	static final Logger LOG = LoggerFactory.getLogger(AbstractTemplateSupport.class);
+
+	public AbstractTemplateSupport(ReactiveCouchbaseTemplate template, CouchbaseConverter converter, TranslationService translationService) {
+		this.template = template;
+		this.converter = converter;
+		this.mappingContext = converter.getMappingContext();
+		this.translationService = translationService;
+	}
+
+	abstract ReactiveCouchbaseTemplate getReactiveTemplate();
+
+	public <T> T decodeEntityBase(String id, String source, long cas, Class<T> entityClass, String scope, String collection,
+								  TransactionResultHolder txResultHolder, ReactiveCouchbaseResourceHolder holder) {
+		final CouchbaseDocument converted = new CouchbaseDocument(id);
+		converted.setId(id);
+
+		// this is the entity class defined for the repository. It may not be the class of the document that was read
+		// we will reset it after reading the document
+		//
+		// This will fail for the case where:
+		// 1) The version is defined in the concrete class, but not in the abstract class; and
+		// 2) The constructor takes a "long version" argument resulting in an exception would be thrown if version in
+		// the source is null.
+		// We could expose from the MappingCouchbaseConverter determining the persistent entity from the source,
+		// but that is a lot of work to do every time just for this very rare and avoidable case.
+		// TypeInformation<? extends R> typeToUse = typeMapper.readType(source, type);
+
+		CouchbasePersistentEntity persistentEntity = couldBePersistentEntity(entityClass);
+
+		if (persistentEntity == null) { // method could return a Long, Boolean, String etc.
+			// QueryExecutionConverters.unwrapWrapperTypes will recursively unwrap until there is nothing left
+			// to unwrap. This results in List<String[]> being unwrapped past String[] to String, so this may also be a
+			// Collection (or Array) of entityClass. We have no way of knowing - so just assume it is what we are told.
+			// if this is a Collection or array, only the first element will be returned.
+			Set<Map.Entry<String, Object>> set = ((CouchbaseDocument) translationService.decode(source, converted))
+					.getContent().entrySet();
+			return (T) set.iterator().next().getValue();
+		}
+
+		// if possible, set the version property in the source so that if the constructor has a long version argument,
+		// it will have a value an not fail (as null is not a valid argument for a long argument). This possible failure
+		// can be avoid by defining the argument as Long instead of long.
+		// persistentEntity is still the (possibly abstract) class specified in the repository definition
+		// it's possible that the abstract class does not have a version property, and this won't be able to set the version
+		if (cas != 0 && persistentEntity.getVersionProperty() != null) {
+			converted.put(persistentEntity.getVersionProperty().getName(), cas);
+		}
+
+		// if the constructor has an argument that is long version, then construction will fail if the 'version'
+		// is not available as 'null' is not a legal value for a long. Changing the arg to "Long version" would solve this.
+		// (Version doesn't come from 'source', it comes from the cas argument to decodeEntity)
+		T readEntity = converter.read(entityClass, (CouchbaseDocument) translationService.decode(source, converted));
+		final ConvertingPropertyAccessor<T> accessor = getPropertyAccessor(readEntity);
+
+		persistentEntity = couldBePersistentEntity(readEntity.getClass());
+
+		if (cas != 0 && persistentEntity.getVersionProperty() != null) {
+			accessor.setProperty(persistentEntity.getVersionProperty(), cas);
+		}
+		if (persistentEntity.transactionResultProperty() != null) {
+			accessor.setProperty(persistentEntity.transactionResultProperty(), System.identityHashCode(txResultHolder));
+		}
+		N1qlJoinResolver.handleProperties(persistentEntity, accessor, getReactiveTemplate(), id, scope, collection);
+
+		if(holder != null){
+			holder.transactionResultHolder(txResultHolder, (T)accessor.getBean());
+		}
+
+		return accessor.getBean();
+	}
+
+	CouchbasePersistentEntity couldBePersistentEntity(Class<?> entityClass) {
+		if (ClassUtils.isPrimitiveOrWrapper(entityClass) || entityClass == String.class) {
+			return null;
+		}
+		return mappingContext.getPersistentEntity(entityClass);
+	}
+
+
+
+	public <T> T applyResultBase(T entity, CouchbaseDocument converted, Object id, long cas,
+								 TransactionResultHolder txResultHolder, ReactiveCouchbaseResourceHolder holder) {
+		ConvertingPropertyAccessor<Object> accessor = getPropertyAccessor(entity);
+
+		final CouchbasePersistentEntity<?> persistentEntity = converter.getMappingContext()
+				.getRequiredPersistentEntity(entity.getClass());
+
+		final CouchbasePersistentProperty idProperty = persistentEntity.getIdProperty();
+		if (idProperty != null) {
+			accessor.setProperty(idProperty, id);
+		}
+
+		final CouchbasePersistentProperty versionProperty = persistentEntity.getVersionProperty();
+		if (versionProperty != null) {
+			accessor.setProperty(versionProperty, cas);
+		}
+
+		final CouchbasePersistentProperty transactionResultProperty = persistentEntity.transactionResultProperty();
+		if (transactionResultProperty != null) {
+			accessor.setProperty(transactionResultProperty, System.identityHashCode(txResultHolder));
+		}
+		if(holder != null){
+			holder.transactionResultHolder(txResultHolder, (T)accessor.getBean());
+		}
+		maybeEmitEvent(new AfterSaveEvent(accessor.getBean(), converted));
+		return (T) accessor.getBean();
+
+	}
+
+	public Long getCas(final Object entity) {
+		final ConvertingPropertyAccessor<Object> accessor = getPropertyAccessor(entity);
+		final CouchbasePersistentEntity<?> persistentEntity = mappingContext.getRequiredPersistentEntity(entity.getClass());
+		final CouchbasePersistentProperty versionProperty = persistentEntity.getVersionProperty();
+		long cas = 0;
+		if (versionProperty != null) {
+			Object casObject = accessor.getProperty(versionProperty);
+			if (casObject instanceof Number) {
+				cas = ((Number) casObject).longValue();
+			}
+		}
+		return cas;
+	}
+
+	public Object getId(final Object entity) {
+		final ConvertingPropertyAccessor<Object> accessor = getPropertyAccessor(entity);
+		final CouchbasePersistentEntity<?> persistentEntity = mappingContext.getRequiredPersistentEntity(entity.getClass());
+		final CouchbasePersistentProperty idProperty = persistentEntity.getIdProperty();
+		Object id = null;
+		if (idProperty != null) {
+			id = accessor.getProperty(idProperty);
+		}
+		return id;
+	}
+
+	public String getJavaNameForEntity(final Class<?> clazz) {
+		final CouchbasePersistentEntity<?> persistentEntity = mappingContext.getRequiredPersistentEntity(clazz);
+		MappingCouchbaseEntityInformation<?, Object> info = new MappingCouchbaseEntityInformation<>(persistentEntity);
+		return info.getJavaType().getName();
+	}
+
+	<T> ConvertingPropertyAccessor<T> getPropertyAccessor(final T source) {
+		CouchbasePersistentEntity<?> entity = mappingContext.getRequiredPersistentEntity(source.getClass());
+		PersistentPropertyAccessor<T> accessor = entity.getPropertyAccessor(source);
+		return new ConvertingPropertyAccessor<>(accessor, converter.getConversionService());
+	}
+
+	public <T> Integer getTxResultKey(T source) {
+		final CouchbasePersistentEntity<?> persistentEntity = mappingContext.getRequiredPersistentEntity(source.getClass());
+		final CouchbasePersistentProperty transactionResultProperty = persistentEntity.transactionResultProperty();
+		if (transactionResultProperty == null) {
+			throw new CouchbaseException("the entity class " + source.getClass()
+					+ " does not have a property required for transactions:\n\t@TransactionResult TransactionResultHolder txResultHolder");
+		}
+		return getPropertyAccessor(source).getProperty(transactionResultProperty, Integer.class);
+	}
+
+	public void maybeEmitEvent(CouchbaseMappingEvent<?> event) {
+		if (canPublishEvent()) {
+			try {
+				this.applicationContext.publishEvent(event);
+			} catch (Exception e) {
+				LOG.warn("{} thrown during {}", e, event);
+				throw e;
+			}
+		} else {
+			LOG.info("maybeEmitEvent called, but CouchbaseTemplate not initialized with applicationContext");
+		}
+
+	}
+
+	private boolean canPublishEvent() {
+		return this.applicationContext != null;
+	}
+
+	public TranslationService getTranslationService(){
+		return translationService;
+	}
+}
diff --git a/src/main/java/org/springframework/data/couchbase/core/CouchbaseExceptionTranslator.java b/src/main/java/org/springframework/data/couchbase/core/CouchbaseExceptionTranslator.java
index 3ae3cb21..e4d22669 100644
--- a/src/main/java/org/springframework/data/couchbase/core/CouchbaseExceptionTranslator.java
+++ b/src/main/java/org/springframework/data/couchbase/core/CouchbaseExceptionTranslator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2020 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -25,6 +25,7 @@ import org.springframework.dao.DataIntegrityViolationException;
 import org.springframework.dao.DataRetrievalFailureException;
 import org.springframework.dao.DuplicateKeyException;
 import org.springframework.dao.InvalidDataAccessResourceUsageException;
+import org.springframework.dao.OptimisticLockingFailureException;;
 import org.springframework.dao.QueryTimeoutException;
 import org.springframework.dao.TransientDataAccessResourceException;
 import org.springframework.dao.support.PersistenceExceptionTranslator;
@@ -33,7 +34,7 @@ import com.couchbase.client.core.error.*;
 
 /**
  * Simple {@link PersistenceExceptionTranslator} for Couchbase.
- * <p/>
+ * <p>
  * Convert the given runtime exception to an appropriate exception from the {@code org.springframework.dao} hierarchy.
  * Return {@literal null} if no translation is appropriate: any other exception may have resulted from user code, and
  * should not be translated.
@@ -66,8 +67,11 @@ public class CouchbaseExceptionTranslator implements PersistenceExceptionTransla
 			return new DataRetrievalFailureException(ex.getMessage(), ex);
 		}
 
-		if (ex instanceof CasMismatchException || ex instanceof ConcurrentModificationException
-				|| ex instanceof ReplicaNotConfiguredException || ex instanceof DurabilityLevelNotAvailableException
+		if (ex instanceof CasMismatchException || ex instanceof ConcurrentModificationException) {
+			return new OptimisticLockingFailureException(ex.getMessage(), ex);
+		}
+
+		if ( ex instanceof ReplicaNotConfiguredException || ex instanceof DurabilityLevelNotAvailableException
 				|| ex instanceof DurabilityImpossibleException || ex instanceof DurabilityAmbiguousException) {
 			return new DataIntegrityViolationException(ex.getMessage(), ex);
 		}
diff --git a/src/main/java/org/springframework/data/couchbase/core/CouchbaseOperations.java b/src/main/java/org/springframework/data/couchbase/core/CouchbaseOperations.java
index 33ce0791..8cec3131 100644
--- a/src/main/java/org/springframework/data/couchbase/core/CouchbaseOperations.java
+++ b/src/main/java/org/springframework/data/couchbase/core/CouchbaseOperations.java
@@ -18,6 +18,9 @@ package org.springframework.data.couchbase.core;
 
 import org.springframework.data.couchbase.CouchbaseClientFactory;
 import org.springframework.data.couchbase.core.convert.CouchbaseConverter;
+import org.springframework.data.couchbase.core.query.Query;
+
+import static org.springframework.data.couchbase.repository.support.Util.hasNonZeroVersionProperty;
 
 import com.couchbase.client.java.query.QueryScanConsistency;
 
@@ -50,4 +53,8 @@ public interface CouchbaseOperations extends FluentCouchbaseOperations {
 	 * Returns the default consistency to use for queries
 	 */
 	QueryScanConsistency getConsistency();
+	<T> T save(T entity);
+
+	<T> Long count(Query query, Class<T> domainType);
+
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/CouchbaseTemplate.java b/src/main/java/org/springframework/data/couchbase/core/CouchbaseTemplate.java
index 4bf78121..322bf4f7 100644
--- a/src/main/java/org/springframework/data/couchbase/core/CouchbaseTemplate.java
+++ b/src/main/java/org/springframework/data/couchbase/core/CouchbaseTemplate.java
@@ -16,11 +16,14 @@
 
 package org.springframework.data.couchbase.core;
 
+import static org.springframework.data.couchbase.repository.support.Util.hasNonZeroVersionProperty;
+
 import org.springframework.beans.BeansException;
 import org.springframework.context.ApplicationContext;
 import org.springframework.context.ApplicationContextAware;
 import org.springframework.context.ConfigurableApplicationContext;
 import org.springframework.data.couchbase.CouchbaseClientFactory;
+import org.springframework.data.couchbase.ReactiveCouchbaseClientFactory;
 import org.springframework.data.couchbase.core.convert.CouchbaseConverter;
 import org.springframework.data.couchbase.core.convert.translation.JacksonTranslationService;
 import org.springframework.data.couchbase.core.convert.translation.TranslationService;
@@ -28,6 +31,8 @@ import org.springframework.data.couchbase.core.index.CouchbasePersistentEntityIn
 import org.springframework.data.couchbase.core.mapping.CouchbaseMappingContext;
 import org.springframework.data.couchbase.core.mapping.CouchbasePersistentEntity;
 import org.springframework.data.couchbase.core.mapping.CouchbasePersistentProperty;
+import org.springframework.data.couchbase.core.query.Query;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 import org.springframework.data.mapping.context.MappingContext;
 import org.springframework.lang.Nullable;
 
@@ -49,26 +54,31 @@ public class CouchbaseTemplate implements CouchbaseOperations, ApplicationContex
 	private final CouchbaseTemplateSupport templateSupport;
 	private final MappingContext<? extends CouchbasePersistentEntity<?>, CouchbasePersistentProperty> mappingContext;
 	private final ReactiveCouchbaseTemplate reactiveCouchbaseTemplate;
+	private final QueryScanConsistency scanConsistency;
 	private @Nullable CouchbasePersistentEntityIndexCreator indexCreator;
-	private QueryScanConsistency scanConsistency;
+	private CouchbaseTransactionalOperator couchbaseTransactionalOperator;
 
-	public CouchbaseTemplate(final CouchbaseClientFactory clientFactory, final CouchbaseConverter converter) {
-		this(clientFactory, converter, new JacksonTranslationService());
+	public CouchbaseTemplate(final CouchbaseClientFactory clientFactory,
+							 final ReactiveCouchbaseClientFactory reactiveCouchbaseClientFactory, final CouchbaseConverter converter) {
+		this(clientFactory, reactiveCouchbaseClientFactory, converter, new JacksonTranslationService());
 	}
 
-	public CouchbaseTemplate(final CouchbaseClientFactory clientFactory, final CouchbaseConverter converter,
+	public CouchbaseTemplate(final CouchbaseClientFactory clientFactory,
+							 final ReactiveCouchbaseClientFactory reactiveCouchbaseClientFactory, CouchbaseConverter converter,
 							 final TranslationService translationService) {
-		this(clientFactory, converter, translationService, null);
+		this(clientFactory, reactiveCouchbaseClientFactory, converter, translationService, null);
 	}
 
-	public CouchbaseTemplate(final CouchbaseClientFactory clientFactory, final CouchbaseConverter converter,
+	public CouchbaseTemplate(final CouchbaseClientFactory clientFactory,
+							 final ReactiveCouchbaseClientFactory reactiveCouchbaseClientFactory, final CouchbaseConverter converter,
 							 final TranslationService translationService, QueryScanConsistency scanConsistency) {
 		this.clientFactory = clientFactory;
 		this.converter = converter;
 		this.templateSupport = new CouchbaseTemplateSupport(this, converter, translationService);
-		this.reactiveCouchbaseTemplate = new ReactiveCouchbaseTemplate(clientFactory, converter, translationService,
-				scanConsistency);
+		this.reactiveCouchbaseTemplate = new ReactiveCouchbaseTemplate(reactiveCouchbaseClientFactory, converter,
+				translationService, scanConsistency);
 		this.scanConsistency = scanConsistency;
+
 		this.mappingContext = this.converter.getMappingContext();
 		if (mappingContext instanceof CouchbaseMappingContext) {
 			CouchbaseMappingContext cmc = (CouchbaseMappingContext) mappingContext;
@@ -78,6 +88,20 @@ public class CouchbaseTemplate implements CouchbaseOperations, ApplicationContex
 		}
 	}
 
+	public <T> T save(T entity) {
+		if (hasNonZeroVersionProperty(entity, templateSupport.converter)) {
+			return replaceById((Class<T>) entity.getClass()).one(entity);
+			//} else if (getTransactionalOperator() != null) {
+			//	return insertById((Class<T>) entity.getClass()).one(entity);
+		} else {
+			return upsertById((Class<T>) entity.getClass()).one(entity);
+		}
+	}
+
+	public <T> Long count(Query query, Class<T> domainType) {
+		return findByQuery(domainType).matching(query).count();
+	}
+
 	@Override
 	public <T> ExecutableUpsertById<T> upsertById(final Class<T> domainType) {
 		return new ExecutableUpsertByIdOperationSupport(this).upsertById(domainType);
@@ -210,4 +234,29 @@ public class CouchbaseTemplate implements CouchbaseOperations, ApplicationContex
 		return templateSupport;
 	}
 
+	public CouchbaseTemplate with(CouchbaseTransactionalOperator couchbaseTransactionalOperator) {
+		this.couchbaseTransactionalOperator = couchbaseTransactionalOperator;
+		return this;
+	}
+
+	/**
+	 * Get the TransactionalOperator from <br>
+	 * 1. The template.clientFactory<br>
+	 * 2. The template.threadLocal<br>
+	 * 3. otherwise null<br>
+	 * This can be overriden in the operation method by<br>
+	 * 1. repository.withCollection()
+	 *//*
+	private CouchbaseStuffHandle getTransactionalOperator() {
+		if (this.getCouchbaseClientFactory().getTransactionalOperator() != null) {
+			return this.getCouchbaseClientFactory().getTransactionalOperator();
+		}
+		ReactiveCouchbaseTemplate t = this.reactive();
+		PseudoArgs pArgs = t.getPseudoArgs();
+		if (pArgs != null && pArgs.getTxOp() != null) {
+			return pArgs.getTxOp();
+		}
+		return null;
+	}
+	*/
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/CouchbaseTemplateSupport.java b/src/main/java/org/springframework/data/couchbase/core/CouchbaseTemplateSupport.java
index ffb70fc6..7ce71a51 100644
--- a/src/main/java/org/springframework/data/couchbase/core/CouchbaseTemplateSupport.java
+++ b/src/main/java/org/springframework/data/couchbase/core/CouchbaseTemplateSupport.java
@@ -1,6 +1,5 @@
 /*
-/*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,28 +16,19 @@
 
 package org.springframework.data.couchbase.core;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 import org.springframework.beans.BeansException;
 import org.springframework.context.ApplicationContext;
 import org.springframework.context.ApplicationContextAware;
 import org.springframework.data.couchbase.core.convert.CouchbaseConverter;
-import org.springframework.data.couchbase.core.convert.join.N1qlJoinResolver;
 import org.springframework.data.couchbase.core.convert.translation.TranslationService;
 import org.springframework.data.couchbase.core.mapping.CouchbaseDocument;
-import org.springframework.data.couchbase.core.mapping.CouchbasePersistentEntity;
-import org.springframework.data.couchbase.core.mapping.CouchbasePersistentProperty;
 import org.springframework.data.couchbase.core.mapping.event.AfterConvertCallback;
-import org.springframework.data.couchbase.core.mapping.event.AfterSaveEvent;
 import org.springframework.data.couchbase.core.mapping.event.BeforeConvertCallback;
 import org.springframework.data.couchbase.core.mapping.event.BeforeConvertEvent;
 import org.springframework.data.couchbase.core.mapping.event.BeforeSaveEvent;
-import org.springframework.data.couchbase.core.mapping.event.CouchbaseMappingEvent;
-import org.springframework.data.couchbase.repository.support.MappingCouchbaseEntityInformation;
-import org.springframework.data.mapping.PersistentPropertyAccessor;
+import org.springframework.data.couchbase.repository.support.TransactionResultHolder;
+import org.springframework.data.couchbase.transaction.ReactiveCouchbaseResourceHolder;
 import org.springframework.data.mapping.callback.EntityCallbacks;
-import org.springframework.data.mapping.context.MappingContext;
-import org.springframework.data.mapping.model.ConvertingPropertyAccessor;
 import org.springframework.util.Assert;
 
 /**
@@ -50,23 +40,15 @@ import org.springframework.util.Assert;
  * @author Carlos Espinaco
  * @since 3.0
  */
-class CouchbaseTemplateSupport implements ApplicationContextAware, TemplateSupport {
-
-	private static final Logger LOG = LoggerFactory.getLogger(CouchbaseTemplateSupport.class);
+class CouchbaseTemplateSupport extends AbstractTemplateSupport implements ApplicationContextAware, TemplateSupport {
 
 	private final CouchbaseTemplate template;
-	private final CouchbaseConverter converter;
-	private final MappingContext<? extends CouchbasePersistentEntity<?>, CouchbasePersistentProperty> mappingContext;
-	private final TranslationService translationService;
 	private EntityCallbacks entityCallbacks;
-	private ApplicationContext applicationContext;
 
 	public CouchbaseTemplateSupport(final CouchbaseTemplate template, final CouchbaseConverter converter,
 									final TranslationService translationService) {
+		super(template.reactive(), converter, translationService);
 		this.template = template;
-		this.converter = converter;
-		this.mappingContext = converter.getMappingContext();
-		this.translationService = translationService;
 	}
 
 	@Override
@@ -81,83 +63,39 @@ class CouchbaseTemplateSupport implements ApplicationContextAware, TemplateSuppo
 	}
 
 	@Override
-	public <T> T decodeEntity(String id, String source, long cas, Class<T> entityClass) {
-		final CouchbaseDocument converted = new CouchbaseDocument(id);
-		converted.setId(id);
-		CouchbasePersistentEntity<?> persistentEntity = mappingContext.getRequiredPersistentEntity(entityClass);
-		if (cas != 0 && persistentEntity.getVersionProperty() != null) {
-			converted.put(persistentEntity.getVersionProperty().getName(), cas);
-		}
-
-		T readEntity = converter.read(entityClass, (CouchbaseDocument) translationService.decode(source, converted));
-		final ConvertingPropertyAccessor<T> accessor = getPropertyAccessor(readEntity);
-
-		if (persistentEntity.getVersionProperty() != null) {
-			accessor.setProperty(persistentEntity.getVersionProperty(), cas);
-		}
-		N1qlJoinResolver.handleProperties(persistentEntity, accessor, template.reactive(), id);
-		return accessor.getBean();
+	ReactiveCouchbaseTemplate getReactiveTemplate() {
+		return template.reactive();
 	}
 
 	@Override
-	public Object applyUpdatedCas(final Object entity, CouchbaseDocument converted, final long cas) {
-		Object returnValue;
-		final ConvertingPropertyAccessor<Object> accessor = getPropertyAccessor(entity);
-		final CouchbasePersistentEntity<?> persistentEntity = mappingContext.getRequiredPersistentEntity(entity.getClass());
-		final CouchbasePersistentProperty versionProperty = persistentEntity.getVersionProperty();
-
-		if (versionProperty != null) {
-			accessor.setProperty(versionProperty, cas);
-			returnValue = accessor.getBean();
-		} else {
-			returnValue = entity;
+	public <T> T decodeEntity(String id, String source, long cas, Class<T> entityClass, String scope, String collection,
+							  TransactionResultHolder txHolder) {
+		return decodeEntity(id, source, cas, entityClass, scope, collection, txHolder);
 	}
-		maybeEmitEvent(new AfterSaveEvent(returnValue, converted));
 
-		return returnValue;
+	@Override
+	public <T> T decodeEntity(String id, String source, long cas, Class<T> entityClass, String scope, String collection,
+							  TransactionResultHolder txHolder, ReactiveCouchbaseResourceHolder holder) {
+		return decodeEntityBase(id, source, cas, entityClass, scope, collection, txHolder, holder);
 	}
 
 	@Override
-	public Object applyUpdatedId(final Object entity, Object id) {
-		final ConvertingPropertyAccessor<Object> accessor = getPropertyAccessor(entity);
-		final CouchbasePersistentEntity<?> persistentEntity = mappingContext.getRequiredPersistentEntity(entity.getClass());
-		final CouchbasePersistentProperty idProperty = persistentEntity.getIdProperty();
-
-		if (idProperty != null) {
-			accessor.setProperty(idProperty, id);
-			return accessor.getBean();
-		}
-		return entity;
+	public <T> T applyResult(T entity, CouchbaseDocument converted, Object id, long cas,
+							 TransactionResultHolder txResultHolder) {
+		return applyResult(entity, converted, id, cas,txResultHolder, null);
 	}
 
 	@Override
-	public long getCas(final Object entity) {
-		final ConvertingPropertyAccessor<Object> accessor = getPropertyAccessor(entity);
-		final CouchbasePersistentEntity<?> persistentEntity = mappingContext.getRequiredPersistentEntity(entity.getClass());
-		final CouchbasePersistentProperty versionProperty = persistentEntity.getVersionProperty();
-
-		long cas = 0;
-		if (versionProperty != null) {
-			Object casObject = accessor.getProperty(versionProperty);
-			if (casObject instanceof Number) {
-				cas = ((Number) casObject).longValue();
-			}
-		}
-		return cas;
+	public <T> T applyResult(T entity, CouchbaseDocument converted, Object id, long cas,
+							 TransactionResultHolder txResultHolder, ReactiveCouchbaseResourceHolder holder) {
+		return applyResultBase(entity, converted, id, cas, txResultHolder, holder);
 	}
 
 	@Override
-	public String getJavaNameForEntity(final Class<?> clazz) {
-		final CouchbasePersistentEntity<?> persistentEntity = mappingContext.getRequiredPersistentEntity(clazz);
-		MappingCouchbaseEntityInformation<?, Object> info = new MappingCouchbaseEntityInformation<>(persistentEntity);
-		return info.getJavaType().getName();
+	public <T> Integer getTxResultHolder(T source) {
+		return null;
 	}
 
-	private <T> ConvertingPropertyAccessor<T> getPropertyAccessor(final T source) {
-		CouchbasePersistentEntity<?> entity = mappingContext.getRequiredPersistentEntity(source.getClass());
-		PersistentPropertyAccessor<T> accessor = entity.getPropertyAccessor(source);
-		return new ConvertingPropertyAccessor<>(accessor, converter.getConversionService());
-	}
 
 	@Override
 	public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
@@ -170,7 +108,7 @@ class CouchbaseTemplateSupport implements ApplicationContextAware, TemplateSuppo
 	/**
 	 * Set the {@link EntityCallbacks} instance to use when invoking
 	 * {@link org.springframework.data.mapping.callback.EntityCallback callbacks} like the {@link BeforeConvertCallback}.
-	 * <p/>
+	 * <p>
 	 * Overrides potentially existing {@link EntityCallbacks}.
 	 *
 	 * @param entityCallbacks must not be {@literal null}.
@@ -182,24 +120,6 @@ class CouchbaseTemplateSupport implements ApplicationContextAware, TemplateSuppo
 		this.entityCallbacks = entityCallbacks;
 	}
 
-	public void maybeEmitEvent(CouchbaseMappingEvent<?> event) {
-		if (canPublishEvent()) {
-			try {
-				this.applicationContext.publishEvent(event);
-			} catch (Exception e) {
-				LOG.warn("{} thrown during {}", e, event);
-				throw e;
-			}
-		} else {
-			LOG.info("maybeEmitEvent called, but CouchbaseTemplate not initialized with applicationContext");
-		}
-
-	}
-
-	private boolean canPublishEvent() {
-		return this.applicationContext != null;
-	}
-
 	protected <T> T maybeCallBeforeConvert(T object, String collection) {
 		if (entityCallbacks != null) {
 			return entityCallbacks.callback(BeforeConvertCallback.class, object, collection);
diff --git a/src/main/java/org/springframework/data/couchbase/core/ExecutableFindByAnalyticsOperation.java b/src/main/java/org/springframework/data/couchbase/core/ExecutableFindByAnalyticsOperation.java
index 2aed295f..58e9146e 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ExecutableFindByAnalyticsOperation.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ExecutableFindByAnalyticsOperation.java
@@ -37,7 +37,8 @@ import com.couchbase.client.java.analytics.AnalyticsScanConsistency;
  *
  * @author Christoph Strobl
  * @since 2.0
- */public interface ExecutableFindByAnalyticsOperation {
+ */
+public interface ExecutableFindByAnalyticsOperation {
 
 	/**
 	 * Queries the analytics service.
@@ -114,65 +115,23 @@ import com.couchbase.client.java.analytics.AnalyticsScanConsistency;
 
 	}
 
-	interface FindByAnalyticsWithQuery<T> extends TerminatingFindByAnalytics<T>, WithAnalyticsQuery<T> {
-
-		/**
-		 * Set the filter for the analytics query to be used.
-		 *
-		 * @param query must not be {@literal null}.
-		 * @throws IllegalArgumentException if query is {@literal null}.
-		 */
-		TerminatingFindByAnalytics<T> matching(AnalyticsQuery query);
-
-	}
-
 	/**
 	 * Fluent method to specify options.
 	 *
 	 * @param <T> the entity type to use.
 	 */
-	interface FindByAnalyticsWithOptions<T> extends FindByAnalyticsWithQuery<T>, WithAnalyticsOptions<T> {
+	interface FindByAnalyticsWithOptions<T> extends TerminatingFindByAnalytics<T>, WithAnalyticsOptions<T> {
 		/**
 		 * Fluent method to specify options to use for execution
 		 *
 		 * @param options to use for execution
 		 */
 		@Override
-		FindByAnalyticsWithQuery<T> withOptions(AnalyticsOptions options);
-	}
-
-	/**
-	 * Fluent method to specify the collection.
-	 *
-	 * @param <T> the entity type to use for the results.
-	 */
-	interface FindByAnalyticsInCollection<T> extends FindByAnalyticsWithOptions<T>, InCollection<T> {
-		/**
-		 * With a different collection
-		 *
-		 * @param collection the collection to use.
-		 */
-		@Override
-		FindByAnalyticsWithOptions<T> inCollection(String collection);
-	}
-
-	/**
-	 * Fluent method to specify the scope.
-	 *
-	 * @param <T> the entity type to use for the results.
-	 */
-	interface FindByAnalyticsInScope<T> extends FindByAnalyticsInCollection<T>, InScope<T> {
-		/**
-		 * With a different scope
-		 *
-		 * @param scope the scope to use.
-		 */
-		@Override
-		FindByAnalyticsInCollection<T> inScope(String scope);
+		TerminatingFindByAnalytics<T> withOptions(AnalyticsOptions options);
 	}
 
 	@Deprecated
-	interface FindByAnalyticsConsistentWith<T> extends FindByAnalyticsInScope<T> {
+	interface FindByAnalyticsConsistentWith<T> extends FindByAnalyticsWithOptions<T> {
 
 		/**
 		 * Allows to override the default scan consistency.
@@ -180,7 +139,7 @@ import com.couchbase.client.java.analytics.AnalyticsScanConsistency;
 		 * @param scanConsistency the custom scan consistency to use for this analytics query.
 		 */
 		@Deprecated
-		FindByAnalyticsWithQuery<T> consistentWith(AnalyticsScanConsistency scanConsistency);
+		FindByAnalyticsWithOptions<T> consistentWith(AnalyticsScanConsistency scanConsistency);
 
 	}
 
@@ -194,10 +153,22 @@ import com.couchbase.client.java.analytics.AnalyticsScanConsistency;
 		FindByAnalyticsConsistentWith<T> withConsistency(AnalyticsScanConsistency scanConsistency);
 	}
 
+	interface FindByAnalyticsWithQuery<T> extends FindByAnalyticsWithConsistency<T>, WithAnalyticsQuery<T> {
+
+		/**
+		 * Set the filter for the analytics query to be used.
+		 *
+		 * @param query must not be {@literal null}.
+		 * @throws IllegalArgumentException if query is {@literal null}.
+		 */
+		FindByAnalyticsWithConsistency<T> matching(AnalyticsQuery query);
+
+	}
+
 	/**
 	 * Result type override (Optional).
 	 */
-	interface FindByAnalyticsWithProjection<T> extends FindByAnalyticsWithConsistency<T> {
+	interface FindByAnalyticsWithProjection<T> extends FindByAnalyticsWithQuery<T> {
 
 		/**
 		 * Define the target type fields should be mapped to. <br />
@@ -207,9 +178,39 @@ import com.couchbase.client.java.analytics.AnalyticsScanConsistency;
 		 * @return new instance of {@link FindByAnalyticsWithConsistency}.
 		 * @throws IllegalArgumentException if returnType is {@literal null}.
 		 */
-		<R> FindByAnalyticsWithConsistency<R> as(Class<R> returnType);
+		<R> FindByAnalyticsWithQuery<R> as(Class<R> returnType);
+	}
+
+	/**
+	 * Fluent method to specify the collection.
+	 *
+	 * @param <T> the entity type to use for the results.
+	 */
+	interface FindByAnalyticsInCollection<T> extends FindByAnalyticsWithProjection<T>, InCollection<T> {
+		/**
+		 * With a different collection
+		 *
+		 * @param collection the collection to use.
+		 */
+		@Override
+		FindByAnalyticsWithProjection<T> inCollection(String collection);
+	}
+
+	/**
+	 * Fluent method to specify the scope.
+	 *
+	 * @param <T> the entity type to use for the results.
+	 */
+	interface FindByAnalyticsInScope<T> extends FindByAnalyticsInCollection<T>, InScope<T> {
+		/**
+		 * With a different scope
+		 *
+		 * @param scope the scope to use.
+		 */
+		@Override
+		FindByAnalyticsInCollection<T> inScope(String scope);
 	}
 
-	interface ExecutableFindByAnalytics<T> extends FindByAnalyticsWithProjection<T> {}
+	interface ExecutableFindByAnalytics<T> extends FindByAnalyticsInScope<T> {}
 
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/ExecutableFindByAnalyticsOperationSupport.java b/src/main/java/org/springframework/data/couchbase/core/ExecutableFindByAnalyticsOperationSupport.java
index ad88bc4d..c90fe410 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ExecutableFindByAnalyticsOperationSupport.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ExecutableFindByAnalyticsOperationSupport.java
@@ -83,7 +83,7 @@ public class ExecutableFindByAnalyticsOperationSupport implements ExecutableFind
 		}
 
 		@Override
-		public TerminatingFindByAnalytics<T> matching(final AnalyticsQuery query) {
+		public FindByAnalyticsWithConsistency<T> matching(final AnalyticsQuery query) {
 			return new ExecutableFindByAnalyticsSupport<>(template, domainType, returnType, query, scanConsistency, scope,
 					collection, options);
 		}
@@ -102,7 +102,7 @@ public class ExecutableFindByAnalyticsOperationSupport implements ExecutableFind
 		}
 
 		@Override
-		public FindByAnalyticsWithConsistency<T> inCollection(final String collection) {
+		public FindByAnalyticsWithProjection<T> inCollection(final String collection) {
 			return new ExecutableFindByAnalyticsSupport<>(template, domainType, returnType, query, scanConsistency, scope,
 					collection, options);
 		}
@@ -121,7 +121,7 @@ public class ExecutableFindByAnalyticsOperationSupport implements ExecutableFind
 		}
 
 		@Override
-		public <R> FindByAnalyticsWithConsistency<R> as(final Class<R> returnType) {
+		public <R> FindByAnalyticsWithQuery<R> as(final Class<R> returnType) {
 			Assert.notNull(returnType, "returnType must not be null!");
 			return new ExecutableFindByAnalyticsSupport<>(template, domainType, returnType, query, scanConsistency, scope,
 					collection, options);
diff --git a/src/main/java/org/springframework/data/couchbase/core/ExecutableFindByIdOperation.java b/src/main/java/org/springframework/data/couchbase/core/ExecutableFindByIdOperation.java
index 9cb60eeb..2cb6def4 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ExecutableFindByIdOperation.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ExecutableFindByIdOperation.java
@@ -18,14 +18,16 @@ package org.springframework.data.couchbase.core;
 import java.time.Duration;
 import java.util.Collection;
 
-import org.springframework.data.couchbase.core.support.OneAndAllId;
 import org.springframework.data.couchbase.core.support.InCollection;
+import org.springframework.data.couchbase.core.support.InScope;
+import org.springframework.data.couchbase.core.support.OneAndAllId;
+import org.springframework.data.couchbase.core.support.WithExpiry;
 import org.springframework.data.couchbase.core.support.WithGetOptions;
 import org.springframework.data.couchbase.core.support.WithProjectionId;
-import org.springframework.data.couchbase.core.support.InScope;
+import org.springframework.data.couchbase.core.support.WithTransaction;
 
 import com.couchbase.client.java.kv.GetOptions;
-import org.springframework.data.couchbase.core.support.WithExpiry;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 
 /**
  * Get Operations
@@ -82,54 +84,73 @@ public interface ExecutableFindByIdOperation {
 		TerminatingFindById<T> withOptions(GetOptions options);
 	}
 
+	interface FindByIdWithProjection<T> extends FindByIdWithOptions<T>, WithProjectionId<T> {
 		/**
-	 * Fluent method to specify the collection.
+		 * Load only certain fields for the document.
 		 *
-	 * @param <T> the entity type to use for the results.
+		 * @param fields the projected fields to load.
 		 */
-	interface FindByIdInCollection<T> extends FindByIdWithOptions<T>, InCollection<T> {
+		@Override
+		FindByIdWithOptions<T> project(String... fields);
+	}
+
+	interface FindByIdWithExpiry<T> extends FindByIdWithProjection<T>, WithExpiry<T> {
 		/**
-		 * With a different collection
+		 * Load only certain fields for the document.
 		 *
-		 * @param collection the collection to use.
+		 * @param expiry the projected fields to load.
 		 */
 		@Override
-		FindByIdWithOptions<T> inCollection(String collection);
+		FindByIdWithProjection<T> withExpiry(Duration expiry);
 	}
 
 	/**
-	 * Fluent method to specify the scope.
+	 * Provide attempt context
 	 *
-	 * @param <T> the entity type to use for the results.
+	 * @param <T> the entity type to use for the results
 	 */
-	interface FindByIdInScope<T> extends FindByIdInCollection<T>, InScope<T> {
+	interface FindByIdWithTransaction<T> extends TerminatingFindById<T>, WithTransaction<T> {
 		/**
-		 * With a different scope
+		 * Finds the distinct values for a specified {@literal field} across a single collection
 		 *
-		 * @param scope the scope to use.
+		 * @param txCtx Must not be {@literal null}.
+		 * @return new instance of {@link ExecutableFindById}.
+		 * @throws IllegalArgumentException if field is {@literal null}.
 		 */
 		@Override
-		FindByIdInCollection<T> inScope(String scope);
+		FindByIdWithProjection<T> transaction(CouchbaseTransactionalOperator txCtx);
 	}
 
-	interface FindByIdWithProjection<T> extends FindByIdInScope<T>, WithProjectionId<T> {
+	interface FindByIdTxOrNot<T> extends FindByIdWithExpiry<T>, FindByIdWithTransaction<T> {}
+
 	/**
-		 * Load only certain fields for the document.
+	 * Fluent method to specify the collection.
 	 *
-		 * @param fields the projected fields to load.
+	 * @param <T> the entity type to use for the results.
+	 */
+	interface FindByIdInCollection<T> extends FindByIdTxOrNot<T>, InCollection<T> {
+		/**
+		 * With a different collection
+		 *
+		 * @param collection the collection to use.
 		 */
 		@Override
-		FindByIdInScope<T> project(String... fields);
+		FindByIdTxOrNot<T> inCollection(String collection);
 	}
 
-	interface FindByIdWithExpiry<T> extends FindByIdWithProjection<T>, WithExpiry<T> {
 	/**
-		 * Load only certain fields for the document.
+	 * Fluent method to specify the scope.
 	 *
-		 * @param expiry the projected fields to load.
+	 * @param <T> the entity type to use for the results.
+	 */
+	interface FindByIdInScope<T> extends FindByIdInCollection<T>, InScope<T> {
+		/**
+		 * With a different scope
+		 *
+		 * @param scope the scope to use.
 		 */
 		@Override
-		FindByIdWithProjection<T> withExpiry(Duration expiry);
+		FindByIdInCollection<T> inScope(String scope);
 	}
 
 	/**
@@ -137,6 +158,6 @@ public interface ExecutableFindByIdOperation {
 	 *
 	 * @param <T> the entity type to use for the results
 	 */
-	interface ExecutableFindById<T> extends FindByIdWithExpiry<T> {}
+	interface ExecutableFindById<T> extends FindByIdInScope<T> {}
 
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/ExecutableFindByIdOperationSupport.java b/src/main/java/org/springframework/data/couchbase/core/ExecutableFindByIdOperationSupport.java
index 38cf2716..e1759629 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ExecutableFindByIdOperationSupport.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ExecutableFindByIdOperationSupport.java
@@ -21,6 +21,7 @@ import java.util.Collection;
 import java.util.List;
 
 import org.springframework.data.couchbase.core.ReactiveFindByIdOperationSupport.ReactiveFindByIdSupport;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 import org.springframework.util.Assert;
 
 import com.couchbase.client.java.kv.GetOptions;
@@ -35,7 +36,7 @@ public class ExecutableFindByIdOperationSupport implements ExecutableFindByIdOpe
 
 	@Override
 	public <T> ExecutableFindById<T> findById(Class<T> domainType) {
-		return new ExecutableFindByIdSupport<>(template, domainType, null, null, null, null, null);
+		return new ExecutableFindByIdSupport<>(template, domainType, null, null, null, null, null, null);
 	}
 
 	static class ExecutableFindByIdSupport<T> implements ExecutableFindById<T> {
@@ -47,10 +48,11 @@ public class ExecutableFindByIdOperationSupport implements ExecutableFindByIdOpe
 		private final GetOptions options;
 		private final List<String> fields;
 		private final Duration expiry;
+		private final CouchbaseTransactionalOperator txCtx;
 		private final ReactiveFindByIdSupport<T> reactiveSupport;
 
 		ExecutableFindByIdSupport(CouchbaseTemplate template, Class<T> domainType, String scope, String collection,
-				GetOptions options, List<String> fields, Duration expiry) {
+								  GetOptions options, List<String> fields, Duration expiry, CouchbaseTransactionalOperator txCtx) {
 			this.template = template;
 			this.domainType = domainType;
 			this.scope = scope;
@@ -58,13 +60,16 @@ public class ExecutableFindByIdOperationSupport implements ExecutableFindByIdOpe
 			this.options = options;
 			this.fields = fields;
 			this.expiry = expiry;
+			this.txCtx = txCtx;
 			this.reactiveSupport = new ReactiveFindByIdSupport<>(template.reactive(), domainType, scope, collection, options,
-					fields, expiry, new NonReactiveSupportWrapper(template.support()));
+					fields, expiry, txCtx, new NonReactiveSupportWrapper(template.support()));
 		}
 
 		@Override
 		public T one(final String id) {
-			return reactiveSupport.one(id).block();
+			//Mono.deferContextual(ctx -> { System.err.println("ExecutableFindById.ctx: "+ctx); return Mono.empty();}).block();
+			return reactiveSupport.one(id)/*.contextWrite(TransactionContextManager.getOrCreateContext())
+					.contextWrite(TransactionContextManager.getOrCreateContextHolder())*/.block();
 		}
 
 		@Override
@@ -75,29 +80,35 @@ public class ExecutableFindByIdOperationSupport implements ExecutableFindByIdOpe
 		@Override
 		public TerminatingFindById<T> withOptions(final GetOptions options) {
 			Assert.notNull(options, "Options must not be null.");
-			return new ExecutableFindByIdSupport<>(template, domainType, scope, collection, options, fields, expiry);
+			return new ExecutableFindByIdSupport<>(template, domainType, scope, collection, options, fields, expiry, txCtx);
 		}
 
 		@Override
-		public FindByIdWithOptions<T> inCollection(final String collection) {
-			return new ExecutableFindByIdSupport<>(template, domainType, scope, collection, options, fields, expiry);
+		public FindByIdTxOrNot<T> inCollection(final String collection) {
+			return new ExecutableFindByIdSupport<>(template, domainType, scope, collection, options, fields, expiry, txCtx);
 		}
 
 		@Override
 		public FindByIdInCollection<T> inScope(final String scope) {
-			return new ExecutableFindByIdSupport<>(template, domainType, scope, collection, options, fields, expiry);
+			return new ExecutableFindByIdSupport<>(template, domainType, scope, collection, options, fields, expiry, txCtx);
 		}
 
 		@Override
 		public FindByIdInScope<T> project(String... fields) {
 			Assert.notEmpty(fields, "Fields must not be null.");
-			return new ExecutableFindByIdSupport<>(template, domainType, scope, collection, options, Arrays.asList(fields), expiry);
+			return new ExecutableFindByIdSupport<>(template, domainType, scope, collection, options, Arrays.asList(fields),
+					expiry, txCtx);
 		}
 
 		@Override
 		public FindByIdWithProjection<T> withExpiry(final Duration expiry) {
-			return new ExecutableFindByIdSupport<>(template, domainType, scope, collection, options, fields,
-					expiry);
+			return new ExecutableFindByIdSupport<>(template, domainType, scope, collection, options, fields, expiry, txCtx);
+		}
+
+		@Override
+		public FindByIdWithExpiry<T> transaction(CouchbaseTransactionalOperator txCtx) {
+			Assert.notNull(txCtx, "txCtx must not be null.");
+			return new ExecutableFindByIdSupport<>(template, domainType, scope, collection, options, fields, expiry, txCtx);
 		}
 
 	}
diff --git a/src/main/java/org/springframework/data/couchbase/core/ExecutableFindByQueryOperation.java b/src/main/java/org/springframework/data/couchbase/core/ExecutableFindByQueryOperation.java
index f147dda6..f6219acc 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ExecutableFindByQueryOperation.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ExecutableFindByQueryOperation.java
@@ -29,6 +29,8 @@ import org.springframework.data.couchbase.core.support.WithConsistency;
 import org.springframework.data.couchbase.core.support.WithDistinct;
 import org.springframework.data.couchbase.core.support.WithQuery;
 import org.springframework.data.couchbase.core.support.WithQueryOptions;
+import org.springframework.data.couchbase.core.support.WithTransaction;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 import org.springframework.lang.Nullable;
 
 import com.couchbase.client.java.query.QueryOptions;
@@ -128,42 +130,12 @@ public interface ExecutableFindByQueryOperation {
 
 	}
 
-	/**
-	 * Fluent methods to specify the query
-	 *
-	 * @param <T> the entity type to use for the results.
-	 */
-	interface FindByQueryWithQuery<T> extends TerminatingFindByQuery<T>, WithQuery<T> {
-
-		/**
-		 * Set the filter for the query to be used.
-		 *
-		 * @param query must not be {@literal null}.
-		 * @throws IllegalArgumentException if query is {@literal null}.
-		 */
-		@Override
-		TerminatingFindByQuery<T> matching(Query query);
-
-		/**
-		 * Set the filter {@link QueryCriteriaDefinition criteria} to be used.
-		 *
-		 * @param criteria must not be {@literal null}.
-		 * @return new instance of {@link ExecutableFindByQuery}.
-		 * @throws IllegalArgumentException if criteria is {@literal null}.
-		 */
-		@Override
-		default TerminatingFindByQuery<T> matching(QueryCriteriaDefinition criteria) {
-			return matching(Query.query(criteria));
-		}
-
-	}
-
 	/**
 	 * Fluent method to specify options.
 	 *
 	 * @param <T> the entity type to use for the results.
 	 */
-	interface FindByQueryWithOptions<T> extends FindByQueryWithQuery<T>, WithQueryOptions<T> {
+	interface FindByQueryWithOptions<T> extends TerminatingFindByQuery<T>, WithQueryOptions<T> {
 		/**
 		 * Fluent method to specify options to use for execution
 		 *
@@ -174,66 +146,86 @@ public interface ExecutableFindByQueryOperation {
 	}
 
 	/**
-	 * Fluent method to specify the collection.
+	 * To be removed at the next major release. use WithConsistency instead
 	 *
 	 * @param <T> the entity type to use for the results.
 	 */
-	interface FindByQueryInCollection<T> extends FindByQueryWithOptions<T>, InCollection<T> {
+	@Deprecated
+	interface FindByQueryConsistentWith<T> extends FindByQueryWithOptions<T> {
+
 		/**
-		 * With a different collection
+		 * Allows to override the default scan consistency.
 		 *
-		 * @param collection the collection to use.
+		 * @param scanConsistency the custom scan consistency to use for this query.
 		 */
-		@Override
-		FindByQueryWithOptions<T> inCollection(String collection);
+		@Deprecated
+		FindByQueryWithOptions<T> consistentWith(QueryScanConsistency scanConsistency);
 	}
 
 	/**
-	 * Fluent method to specify the scope.
+	 * Fluent method to specify scan consistency. Scan consistency may also come from an annotation.
 	 *
 	 * @param <T> the entity type to use for the results.
 	 */
-	interface FindByQueryInScope<T> extends FindByQueryInCollection<T>, InScope<T> {
+	interface FindByQueryWithConsistency<T> extends FindByQueryConsistentWith<T>, WithConsistency<T> {
+
 		/**
-		 * With a different scope
+		 * Allows to override the default scan consistency.
 		 *
-		 * @param scope the scope to use.
+		 * @param scanConsistency the custom scan consistency to use for this query.
 		 */
 		@Override
-		FindByQueryInCollection<T> inScope(String scope);
+		FindByQueryConsistentWith<T> withConsistency(QueryScanConsistency scanConsistency);
 	}
 
 	/**
-	 * To be removed at the next major release. use WithConsistency instead
+	 * Fluent method to specify transaction
 	 *
 	 * @param <T> the entity type to use for the results.
 	 */
-	@Deprecated
-	interface FindByQueryConsistentWith<T> extends FindByQueryInScope<T> {
+	interface FindByQueryWithTransaction<T> extends TerminatingFindByQuery<T>, WithTransaction<T> {
 
 		/**
-		 * Allows to override the default scan consistency.
+		 * Finds the distinct values for a specified {@literal field} across a single collection
 		 *
-		 * @param scanConsistency the custom scan consistency to use for this query.
+		 * @param txCtx Must not be {@literal null}.
+		 * @return new instance of {@link ExecutableFindByQuery}.
+		 * @throws IllegalArgumentException if field is {@literal null}.
 		 */
-		@Deprecated
-		FindByQueryInScope<T> consistentWith(QueryScanConsistency scanConsistency);
+		@Override
+		TerminatingFindByQuery<T> transaction(CouchbaseTransactionalOperator txCtx);
 	}
 
+	interface FindByQueryTxOrNot<T> extends FindByQueryWithConsistency<T>, FindByQueryWithTransaction<T> {}
+
 	/**
-	 * Fluent method to specify scan consistency. Scan consistency may also come from an annotation.
+	 * Fluent methods to specify the query
 	 *
 	 * @param <T> the entity type to use for the results.
 	 */
-	interface FindByQueryWithConsistency<T> extends FindByQueryConsistentWith<T>, WithConsistency<T> {
+	interface FindByQueryWithQuery<T> extends FindByQueryTxOrNot<T>, WithQuery<T> {
 
 		/**
-		 * Allows to override the default scan consistency.
+		 * Set the filter for the query to be used.
 		 *
-		 * @param scanConsistency the custom scan consistency to use for this query.
+		 * @param query must not be {@literal null}.
+		 * @throws IllegalArgumentException if query is {@literal null}.
 		 */
 		@Override
-		FindByQueryConsistentWith<T> withConsistency(QueryScanConsistency scanConsistency);
+		FindByQueryTxOrNot<T> matching(Query query);
+
+		/**
+		 * Set the filter {@link QueryCriteriaDefinition criteria} to be used.
+		 *
+		 * @param criteria must not be {@literal null}.
+		 * @return new instance of {@link ExecutableFindByQuery}.
+		 * @throws IllegalArgumentException if criteria is {@literal null}.
+		 */
+		@Override
+		default FindByQueryTxOrNot<T> matching(QueryCriteriaDefinition criteria) {
+			return matching(Query.query(criteria));
+		}
+
 	}
 
 	/**
@@ -241,7 +233,7 @@ public interface ExecutableFindByQueryOperation {
 	 *
 	 * @param <T> the entity type to use for the results.
 	 */
-	interface FindByQueryWithProjection<T> extends FindByQueryWithConsistency<T> {
+	interface FindByQueryWithProjection<T> extends FindByQueryWithQuery<T> {
 
 		/**
 		 * Define the target type fields should be mapped to. <br />
@@ -251,7 +243,7 @@ public interface ExecutableFindByQueryOperation {
 		 * @return new instance of {@link FindByQueryWithProjection}.
 		 * @throws IllegalArgumentException if returnType is {@literal null}.
 		 */
-		<R> FindByQueryWithConsistency<R> as(Class<R> returnType);
+		<R> FindByQueryWithQuery<R> as(Class<R> returnType);
 	}
 
 	/**
@@ -287,7 +279,37 @@ public interface ExecutableFindByQueryOperation {
 		 * @throws IllegalArgumentException if field is {@literal null}.
 		 */
 		@Override
-		FindByQueryWithProjection<T> distinct(String[] distinctFields);
+		FindByQueryWithProjecting<T> distinct(String[] distinctFields);
+	}
+
+	/**
+	 * Fluent method to specify the collection.
+	 *
+	 * @param <T> the entity type to use for the results.
+	 */
+	interface FindByQueryInCollection<T> extends FindByQueryWithDistinct<T>, InCollection<T> {
+		/**
+		 * With a different collection
+		 *
+		 * @param collection the collection to use.
+		 */
+		@Override
+		FindByQueryWithDistinct<T> inCollection(String collection);
+	}
+
+	/**
+	 * Fluent method to specify the scope.
+	 *
+	 * @param <T> the entity type to use for the results.
+	 */
+	interface FindByQueryInScope<T> extends FindByQueryInCollection<T>, InScope<T> {
+		/**
+		 * With a different scope
+		 *
+		 * @param scope the scope to use.
+		 */
+		@Override
+		FindByQueryInCollection<T> inScope(String scope);
 	}
 
 	/**
@@ -295,6 +317,6 @@ public interface ExecutableFindByQueryOperation {
 	 *
 	 * @param <T> the entity type to use for the results
 	 */
-	interface ExecutableFindByQuery<T> extends FindByQueryWithDistinct<T> {}
+	interface ExecutableFindByQuery<T> extends FindByQueryInScope<T> {}
 
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/ExecutableFindByQueryOperationSupport.java b/src/main/java/org/springframework/data/couchbase/core/ExecutableFindByQueryOperationSupport.java
index cffdd571..f793c8b9 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ExecutableFindByQueryOperationSupport.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ExecutableFindByQueryOperationSupport.java
@@ -20,6 +20,7 @@ import java.util.stream.Stream;
 
 import org.springframework.data.couchbase.core.ReactiveFindByQueryOperationSupport.ReactiveFindByQuerySupport;
 import org.springframework.data.couchbase.core.query.Query;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 import org.springframework.util.Assert;
 
 import com.couchbase.client.java.query.QueryOptions;
@@ -44,7 +45,7 @@ public class ExecutableFindByQueryOperationSupport implements ExecutableFindByQu
 	@Override
 	public <T> ExecutableFindByQuery<T> findByQuery(final Class<T> domainType) {
 		return new ExecutableFindByQuerySupport<T>(template, domainType, domainType, ALL_QUERY, null, null, null, null,
-				null, null);
+				null, null, null);
 	}
 
 	static class ExecutableFindByQuerySupport<T> implements ExecutableFindByQuery<T> {
@@ -60,16 +61,18 @@ public class ExecutableFindByQueryOperationSupport implements ExecutableFindByQu
 		private final QueryOptions options;
 		private final String[] distinctFields;
 		private final String[] fields;
+		private final CouchbaseTransactionalOperator txCtx;
 
 		ExecutableFindByQuerySupport(final CouchbaseTemplate template, final Class<?> domainType, final Class<T> returnType,
 									 final Query query, final QueryScanConsistency scanConsistency, final String scope, final String collection,
-				final QueryOptions options, final String[] distinctFields, final String[] fields) {
+									 final QueryOptions options, final String[] distinctFields, final String[] fields,
+									 final CouchbaseTransactionalOperator txCtx) {
 			this.template = template;
 			this.domainType = domainType;
 			this.returnType = returnType;
 			this.query = query;
 			this.reactiveSupport = new ReactiveFindByQuerySupport<T>(template.reactive(), domainType, returnType, query,
-					scanConsistency, scope, collection, options, distinctFields, fields,
+					scanConsistency, scope, collection, options, distinctFields, fields, txCtx,
 					new NonReactiveSupportWrapper(template.support()));
 			this.scanConsistency = scanConsistency;
 			this.scope = scope;
@@ -77,6 +80,7 @@ public class ExecutableFindByQueryOperationSupport implements ExecutableFindByQu
 			this.options = options;
 			this.distinctFields = distinctFields;
 			this.fields = fields;
+			this.txCtx = txCtx;
 		}
 
 		@Override
@@ -95,7 +99,7 @@ public class ExecutableFindByQueryOperationSupport implements ExecutableFindByQu
 		}
 
 		@Override
-		public TerminatingFindByQuery<T> matching(final Query query) {
+		public FindByQueryTxOrNot<T> matching(final Query query) {
 			QueryScanConsistency scanCons;
 			if (query.getScanConsistency() != null) {
 				scanCons = query.getScanConsistency();
@@ -103,27 +107,27 @@ public class ExecutableFindByQueryOperationSupport implements ExecutableFindByQu
 				scanCons = scanConsistency;
 			}
 			return new ExecutableFindByQuerySupport<>(template, domainType, returnType, query, scanCons, scope, collection,
-					options, distinctFields, fields);
+					options, distinctFields, fields, txCtx);
 		}
 
 		@Override
 		@Deprecated
 		public FindByQueryInScope<T> consistentWith(final QueryScanConsistency scanConsistency) {
 			return new ExecutableFindByQuerySupport<>(template, domainType, returnType, query, scanConsistency, scope,
-					collection, options, distinctFields, fields);
+					collection, options, distinctFields, fields, txCtx);
 		}
 
 		@Override
 		public FindByQueryConsistentWith<T> withConsistency(final QueryScanConsistency scanConsistency) {
 			return new ExecutableFindByQuerySupport<>(template, domainType, returnType, query, scanConsistency, scope,
-					collection, options, distinctFields, fields);
+					collection, options, distinctFields, fields, txCtx);
 		}
 
 		@Override
-		public <R> FindByQueryWithConsistency<R> as(final Class<R> returnType) {
+		public <R> FindByQueryWithQuery<R> as(final Class<R> returnType) {
 			Assert.notNull(returnType, "returnType must not be null!");
 			return new ExecutableFindByQuerySupport<>(template, domainType, returnType, query, scanConsistency, scope,
-					collection, options, distinctFields, fields);
+					collection, options, distinctFields, fields, txCtx);
 		}
 
 		@Override
@@ -131,11 +135,11 @@ public class ExecutableFindByQueryOperationSupport implements ExecutableFindByQu
 			Assert.notNull(fields, "Fields must not be null");
 			Assert.isNull(distinctFields, "only one of project(fields) and distinct(distinctFields) can be specified");
 			return new ExecutableFindByQuerySupport<>(template, domainType, returnType, query, scanConsistency, scope,
-					collection, options, distinctFields, fields);
+					collection, options, distinctFields, fields, txCtx);
 		}
 
 		@Override
-		public FindByQueryWithProjection<T> distinct(final String[] distinctFields) {
+		public FindByQueryWithProjecting<T> distinct(final String[] distinctFields) {
 			Assert.notNull(distinctFields, "distinctFields must not be null");
 			Assert.isNull(fields, "only one of project(fields) and distinct(distinctFields) can be specified");
 			// Coming from an annotation, this cannot be null.
@@ -143,7 +147,14 @@ public class ExecutableFindByQueryOperationSupport implements ExecutableFindByQu
 			// So to indicate do not use distinct, we use {"-"} from the annotation, and here we change it to null.
 			String[] dFields = distinctFields.length == 1 && "-".equals(distinctFields[0]) ? null : distinctFields;
 			return new ExecutableFindByQuerySupport<>(template, domainType, returnType, query, scanConsistency, scope,
-					collection, options, dFields, fields);
+					collection, options, dFields, fields, txCtx);
+		}
+
+		@Override
+		public FindByQueryWithDistinct<T> transaction(CouchbaseTransactionalOperator txCtx) {
+			Assert.notNull(txCtx, "txCtx must not be null!");
+			return new ExecutableFindByQuerySupport<>(template, domainType, returnType, query, scanConsistency, scope,
+					collection, options, distinctFields, fields, txCtx);
 		}
 
 		@Override
@@ -169,19 +180,19 @@ public class ExecutableFindByQueryOperationSupport implements ExecutableFindByQu
 		public TerminatingFindByQuery<T> withOptions(final QueryOptions options) {
 			Assert.notNull(options, "Options must not be null.");
 			return new ExecutableFindByQuerySupport<>(template, domainType, returnType, query, scanConsistency, scope,
-					collection, options, distinctFields, fields);
+					collection, options, distinctFields, fields, txCtx);
 		}
 
 		@Override
 		public FindByQueryInCollection<T> inScope(final String scope) {
 			return new ExecutableFindByQuerySupport<>(template, domainType, returnType, query, scanConsistency, scope,
-					collection, options, distinctFields, fields);
+					collection, options, distinctFields, fields, txCtx);
 		}
 
 		@Override
-		public FindByQueryWithConsistency<T> inCollection(final String collection) {
+		public FindByQueryWithDistinct<T> inCollection(final String collection) {
 			return new ExecutableFindByQuerySupport<>(template, domainType, returnType, query, scanConsistency, scope,
-					collection, options, distinctFields, fields);
+					collection, options, distinctFields, fields, txCtx);
 		}
 
 	}
diff --git a/src/main/java/org/springframework/data/couchbase/core/ExecutableInsertByIdOperation.java b/src/main/java/org/springframework/data/couchbase/core/ExecutableInsertByIdOperation.java
index cb198560..aa8f06ca 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ExecutableInsertByIdOperation.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ExecutableInsertByIdOperation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -24,11 +24,13 @@ import org.springframework.data.couchbase.core.support.OneAndAllEntity;
 import org.springframework.data.couchbase.core.support.WithDurability;
 import org.springframework.data.couchbase.core.support.WithExpiry;
 import org.springframework.data.couchbase.core.support.WithInsertOptions;
+import org.springframework.data.couchbase.core.support.WithTransaction;
 
 import com.couchbase.client.core.msg.kv.DurabilityLevel;
 import com.couchbase.client.java.kv.InsertOptions;
 import com.couchbase.client.java.kv.PersistTo;
 import com.couchbase.client.java.kv.ReplicateTo;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 
 /**
  * Insert Operations
@@ -73,8 +75,7 @@ public interface ExecutableInsertByIdOperation {
 	 *
 	 * @param <T> the entity type to use.
 	 */
-	interface InsertByIdWithOptions<T>
-			extends TerminatingInsertById<T>, WithInsertOptions<T> {
+	interface InsertByIdWithOptions<T> extends TerminatingInsertById<T>, WithInsertOptions<T> {
 		/**
 		 * Fluent method to specify options to use for execution.
 		 *
@@ -84,19 +85,42 @@ public interface ExecutableInsertByIdOperation {
 		TerminatingInsertById<T> withOptions(InsertOptions options);
 	}
 
+	interface InsertByIdWithDurability<T> extends InsertByIdWithOptions<T>, WithDurability<T> {
+
+		@Override
+		InsertByIdWithOptions<T> withDurability(DurabilityLevel durabilityLevel);
+
+		@Override
+		InsertByIdWithOptions<T> withDurability(PersistTo persistTo, ReplicateTo replicateTo);
+
+	}
+
+	interface InsertByIdWithExpiry<T> extends InsertByIdWithDurability<T>, WithExpiry<T> {
+
+		@Override
+		InsertByIdWithDurability<T> withExpiry(Duration expiry);
+	}
+
+	interface InsertByIdWithTransaction<T> extends TerminatingInsertById<T>, WithTransaction<T> {
+		@Override
+		InsertByIdWithExpiry<T> transaction(CouchbaseTransactionalOperator txCtx);
+	}
+
+	interface InsertByIdTxOrNot<T> extends InsertByIdWithExpiry<T>, InsertByIdWithTransaction<T> {}
+
 	/**
 	 * Fluent method to specify the collection.
 	 *
 	 * @param <T> the entity type to use for the results.
 	 */
-	interface InsertByIdInCollection<T> extends InsertByIdWithOptions<T>, InCollection<T> {
+	interface InsertByIdInCollection<T> extends InsertByIdTxOrNot<T>, InCollection<T> {
 		/**
 		 * With a different collection
 		 *
 		 * @param collection the collection to use.
 		 */
 		@Override
-		InsertByIdWithOptions<T> inCollection(String collection);
+		InsertByIdTxOrNot<T> inCollection(String collection);
 	}
 
 	/**
@@ -114,27 +138,11 @@ public interface ExecutableInsertByIdOperation {
 		InsertByIdInCollection<T> inScope(String scope);
 	}
 
-	interface InsertByIdWithDurability<T> extends InsertByIdInScope<T>, WithDurability<T> {
-
-		@Override
-		InsertByIdInCollection<T> withDurability(DurabilityLevel durabilityLevel);
-
-		@Override
-		InsertByIdInCollection<T> withDurability(PersistTo persistTo, ReplicateTo replicateTo);
-
-	}
-
-	interface InsertByIdWithExpiry<T> extends InsertByIdWithDurability<T>, WithExpiry<T> {
-
-		@Override
-		InsertByIdWithDurability<T> withExpiry(Duration expiry);
-	}
-
 	/**
 	 * Provides methods for constructing KV insert operations in a fluent way.
 	 *
 	 * @param <T> the entity type to insert
 	 */
-	interface ExecutableInsertById<T> extends InsertByIdWithExpiry<T> {}
+	interface ExecutableInsertById<T> extends InsertByIdInScope<T> {}
 
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/ExecutableInsertByIdOperationSupport.java b/src/main/java/org/springframework/data/couchbase/core/ExecutableInsertByIdOperationSupport.java
index 52031af2..2fc06a1d 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ExecutableInsertByIdOperationSupport.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ExecutableInsertByIdOperationSupport.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,6 +19,7 @@ import java.time.Duration;
 import java.util.Collection;
 
 import org.springframework.data.couchbase.core.ReactiveInsertByIdOperationSupport.ReactiveInsertByIdSupport;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 import org.springframework.util.Assert;
 
 import com.couchbase.client.core.msg.kv.DurabilityLevel;
@@ -38,7 +39,7 @@ public class ExecutableInsertByIdOperationSupport implements ExecutableInsertByI
 	public <T> ExecutableInsertById<T> insertById(final Class<T> domainType) {
 		Assert.notNull(domainType, "DomainType must not be null!");
 		return new ExecutableInsertByIdSupport<>(template, domainType, null, null, null, PersistTo.NONE, ReplicateTo.NONE,
-				DurabilityLevel.NONE, null);
+				DurabilityLevel.NONE, null, null);
 	}
 
 	static class ExecutableInsertByIdSupport<T> implements ExecutableInsertById<T> {
@@ -52,11 +53,12 @@ public class ExecutableInsertByIdOperationSupport implements ExecutableInsertByI
 		private final ReplicateTo replicateTo;
 		private final DurabilityLevel durabilityLevel;
 		private final Duration expiry;
+		private final CouchbaseTransactionalOperator txCtx;
 		private final ReactiveInsertByIdSupport<T> reactiveSupport;
 
 		ExecutableInsertByIdSupport(final CouchbaseTemplate template, final Class<T> domainType, final String scope,
 									final String collection, final InsertOptions options, final PersistTo persistTo, final ReplicateTo replicateTo,
-				final DurabilityLevel durabilityLevel, final Duration expiry) {
+									final DurabilityLevel durabilityLevel, final Duration expiry, final CouchbaseTransactionalOperator txCtx) {
 			this.template = template;
 			this.domainType = domainType;
 			this.scope = scope;
@@ -66,8 +68,10 @@ public class ExecutableInsertByIdOperationSupport implements ExecutableInsertByI
 			this.replicateTo = replicateTo;
 			this.durabilityLevel = durabilityLevel;
 			this.expiry = expiry;
+			this.txCtx = txCtx;
 			this.reactiveSupport = new ReactiveInsertByIdSupport<>(template.reactive(), domainType, scope, collection,
-					options, persistTo, replicateTo, durabilityLevel, expiry, new NonReactiveSupportWrapper(template.support()));
+					options, persistTo, replicateTo, durabilityLevel, expiry, txCtx,
+					new NonReactiveSupportWrapper(template.support()));
 		}
 
 		@Override
@@ -84,41 +88,48 @@ public class ExecutableInsertByIdOperationSupport implements ExecutableInsertByI
 		public TerminatingInsertById<T> withOptions(final InsertOptions options) {
 			Assert.notNull(options, "Options must not be null.");
 			return new ExecutableInsertByIdSupport<>(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, expiry);
+					durabilityLevel, expiry, txCtx);
 		}
 
 		@Override
 		public InsertByIdInCollection<T> inScope(final String scope) {
 			return new ExecutableInsertByIdSupport<>(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, expiry);
+					durabilityLevel, expiry, txCtx);
 		}
 
 		@Override
-		public InsertByIdWithOptions<T> inCollection(final String collection) {
+		public InsertByIdTxOrNot<T> inCollection(final String collection) {
 			return new ExecutableInsertByIdSupport<>(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, expiry);
+					durabilityLevel, expiry, txCtx);
 		}
 
 		@Override
-		public InsertByIdInCollection<T> withDurability(final DurabilityLevel durabilityLevel) {
+		public InsertByIdInScope<T> withDurability(final DurabilityLevel durabilityLevel) {
 			Assert.notNull(durabilityLevel, "Durability Level must not be null.");
 			return new ExecutableInsertByIdSupport<>(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, expiry);
+					durabilityLevel, expiry, txCtx);
 		}
 
 		@Override
-		public InsertByIdInCollection<T> withDurability(final PersistTo persistTo, final ReplicateTo replicateTo) {
+		public InsertByIdInScope<T> withDurability(final PersistTo persistTo, final ReplicateTo replicateTo) {
 			Assert.notNull(persistTo, "PersistTo must not be null.");
 			Assert.notNull(replicateTo, "ReplicateTo must not be null.");
 			return new ExecutableInsertByIdSupport<>(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, expiry);
+					durabilityLevel, expiry, txCtx);
 		}
 
 		@Override
 		public InsertByIdWithDurability<T> withExpiry(final Duration expiry) {
 			Assert.notNull(expiry, "expiry must not be null.");
 			return new ExecutableInsertByIdSupport<>(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, expiry);
+					durabilityLevel, expiry, txCtx);
+		}
+
+		@Override
+		public InsertByIdWithExpiry<T> transaction(final CouchbaseTransactionalOperator txCtx) {
+			Assert.notNull(txCtx, "txCtx must not be null.");
+			return new ExecutableInsertByIdSupport<>(template, domainType, scope, collection, options, persistTo, replicateTo,
+					durabilityLevel, expiry, txCtx);
 		}
 
 	}
diff --git a/src/main/java/org/springframework/data/couchbase/core/ExecutableRemoveByIdOperation.java b/src/main/java/org/springframework/data/couchbase/core/ExecutableRemoveByIdOperation.java
index eb9cb214..ffb916a8 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ExecutableRemoveByIdOperation.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ExecutableRemoveByIdOperation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -21,13 +21,16 @@ import java.util.List;
 import org.springframework.data.couchbase.core.support.InCollection;
 import org.springframework.data.couchbase.core.support.InScope;
 import org.springframework.data.couchbase.core.support.OneAndAllId;
+import org.springframework.data.couchbase.core.support.WithCas;
 import org.springframework.data.couchbase.core.support.WithDurability;
 import org.springframework.data.couchbase.core.support.WithRemoveOptions;
+import org.springframework.data.couchbase.core.support.WithTransaction;
 
 import com.couchbase.client.core.msg.kv.DurabilityLevel;
 import com.couchbase.client.java.kv.PersistTo;
 import com.couchbase.client.java.kv.RemoveOptions;
 import com.couchbase.client.java.kv.ReplicateTo;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 
 /**
  * Remove Operations on KV service.
@@ -61,6 +64,14 @@ public interface ExecutableRemoveByIdOperation {
 		@Override
 		RemoveResult one(String id);
 
+		/**
+		 * Remove one document based on the entity.  Transactions need the entity for the cas.
+		 *
+		 * @param entity the document ID.
+		 * @return result of the remove
+		 */
+		RemoveResult oneEntity(Object entity);
+
 		/**
 		 * Remove the documents in the collection.
 		 *
@@ -70,6 +81,14 @@ public interface ExecutableRemoveByIdOperation {
 		@Override
 		List<RemoveResult> all(Collection<String> ids);
 
+		/**
+		 * Remove documents based on the entities. Transactions need the entity for the cas.
+		 *
+		 * @param entities to remove.
+		 * @return result of the remove
+		 */
+		List<RemoveResult> allEntities(Collection<Object> entities);
+
 	}
 
 	/**
@@ -85,17 +104,39 @@ public interface ExecutableRemoveByIdOperation {
 		TerminatingRemoveById withOptions(RemoveOptions options);
 	}
 
+	interface RemoveByIdWithDurability extends RemoveByIdWithOptions, WithDurability<RemoveResult> {
+
+		@Override
+		RemoveByIdWithOptions withDurability(DurabilityLevel durabilityLevel);
+
+		@Override
+		RemoveByIdWithOptions withDurability(PersistTo persistTo, ReplicateTo replicateTo);
+
+	}
+
+	interface RemoveByIdWithCas extends RemoveByIdWithDurability, WithCas<RemoveResult> {
+		@Override
+		RemoveByIdWithDurability withCas(Long cas);
+	}
+
+	interface RemoveByIdWithTransaction extends TerminatingRemoveById, WithTransaction<RemoveResult> {
+		@Override
+		TerminatingRemoveById transaction(CouchbaseTransactionalOperator txCtx);
+	}
+
+	interface RemoveByIdTxOrNot extends RemoveByIdWithCas, RemoveByIdWithTransaction {}
+
 	/**
 	 * Fluent method to specify the collection.
 	 */
-	interface RemoveByIdInCollection extends RemoveByIdWithOptions, InCollection<Object> {
+	interface RemoveByIdInCollection extends RemoveByIdTxOrNot, InCollection<Object> {
 		/**
 		 * With a different collection
 		 *
 		 * @param collection the collection to use.
 		 */
 		@Override
-		RemoveByIdWithOptions inCollection(String collection);
+		RemoveByIdTxOrNot inCollection(String collection);
 	}
 
 	/**
@@ -111,24 +152,9 @@ public interface ExecutableRemoveByIdOperation {
 		RemoveByIdInCollection inScope(String scope);
 	}
 
-	interface RemoveByIdWithDurability extends RemoveByIdInScope, WithDurability<RemoveResult> {
-
-		@Override
-		RemoveByIdInCollection withDurability(DurabilityLevel durabilityLevel);
-
-		@Override
-		RemoveByIdInCollection withDurability(PersistTo persistTo, ReplicateTo replicateTo);
-
-	}
-
-	interface RemoveByIdWithCas extends RemoveByIdWithDurability {
-
-		RemoveByIdWithDurability withCas(Long cas);
-	}
-
 	/**
 	 * Provides methods for constructing remove operations in a fluent way.
 	 */
-	interface ExecutableRemoveById extends RemoveByIdWithCas {}
+	interface ExecutableRemoveById extends RemoveByIdInScope {}
 
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/ExecutableRemoveByIdOperationSupport.java b/src/main/java/org/springframework/data/couchbase/core/ExecutableRemoveByIdOperationSupport.java
index 9f79dad3..c5a9e34f 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ExecutableRemoveByIdOperationSupport.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ExecutableRemoveByIdOperationSupport.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,6 +19,7 @@ import java.util.Collection;
 import java.util.List;
 
 import org.springframework.data.couchbase.core.ReactiveRemoveByIdOperationSupport.ReactiveRemoveByIdSupport;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 import org.springframework.util.Assert;
 
 import com.couchbase.client.core.msg.kv.DurabilityLevel;
@@ -43,7 +44,7 @@ public class ExecutableRemoveByIdOperationSupport implements ExecutableRemoveByI
 	@Override
 	public ExecutableRemoveById removeById(Class<?> domainType) {
 		return new ExecutableRemoveByIdSupport(template, domainType, null, null, null, PersistTo.NONE, ReplicateTo.NONE,
-				DurabilityLevel.NONE, null);
+				DurabilityLevel.NONE, null, null);
 	}
 
 	static class ExecutableRemoveByIdSupport implements ExecutableRemoveById {
@@ -57,11 +58,12 @@ public class ExecutableRemoveByIdOperationSupport implements ExecutableRemoveByI
 		private final ReplicateTo replicateTo;
 		private final DurabilityLevel durabilityLevel;
 		private final Long cas;
+		private final CouchbaseTransactionalOperator txCtx;
 		private final ReactiveRemoveByIdSupport reactiveRemoveByIdSupport;
 
 		ExecutableRemoveByIdSupport(final CouchbaseTemplate template, final Class<?> domainType, final String scope,
 									final String collection, final RemoveOptions options, final PersistTo persistTo, final ReplicateTo replicateTo,
-				final DurabilityLevel durabilityLevel, Long cas) {
+									final DurabilityLevel durabilityLevel, Long cas, CouchbaseTransactionalOperator txCtx) {
 			this.template = template;
 			this.domainType = domainType;
 			this.scope = scope;
@@ -71,8 +73,9 @@ public class ExecutableRemoveByIdOperationSupport implements ExecutableRemoveByI
 			this.replicateTo = replicateTo;
 			this.durabilityLevel = durabilityLevel;
 			this.reactiveRemoveByIdSupport = new ReactiveRemoveByIdSupport(template.reactive(), domainType, scope, collection,
-					options, persistTo, replicateTo, durabilityLevel, cas);
+					options, persistTo, replicateTo, durabilityLevel, cas, txCtx);
 			this.cas = cas;
+			this.txCtx = txCtx;
 		}
 
 		@Override
@@ -80,50 +83,68 @@ public class ExecutableRemoveByIdOperationSupport implements ExecutableRemoveByI
 			return reactiveRemoveByIdSupport.one(id).block();
 		}
 
+		@Override
+		public RemoveResult oneEntity(final Object entity) {
+			return reactiveRemoveByIdSupport.oneEntity(entity).block();
+		}
+
 		@Override
 		public List<RemoveResult> all(final Collection<String> ids) {
 			return reactiveRemoveByIdSupport.all(ids).collectList().block();
 		}
 
 		@Override
-		public RemoveByIdWithOptions inCollection(final String collection) {
+		public List<RemoveResult> allEntities(final Collection<Object> entities) {
+			return reactiveRemoveByIdSupport.allEntities(entities).collectList().block();
+		}
+
+
+		@Override
+		public RemoveByIdTxOrNot inCollection(final String collection) {
 			return new ExecutableRemoveByIdSupport(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, cas);
+					durabilityLevel, cas, txCtx);
 		}
 
 		@Override
-		public RemoveByIdInCollection withDurability(final DurabilityLevel durabilityLevel) {
+		public RemoveByIdInScope withDurability(final DurabilityLevel durabilityLevel) {
 			Assert.notNull(durabilityLevel, "Durability Level must not be null.");
 			return new ExecutableRemoveByIdSupport(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, cas);
+					durabilityLevel, cas, txCtx);
 		}
 
 		@Override
-		public RemoveByIdInCollection withDurability(final PersistTo persistTo, final ReplicateTo replicateTo) {
+		public RemoveByIdInScope withDurability(final PersistTo persistTo, final ReplicateTo replicateTo) {
 			Assert.notNull(persistTo, "PersistTo must not be null.");
 			Assert.notNull(replicateTo, "ReplicateTo must not be null.");
 			return new ExecutableRemoveByIdSupport(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, cas);
+					durabilityLevel, cas, txCtx);
 		}
 
 		@Override
 		public TerminatingRemoveById withOptions(final RemoveOptions options) {
 			Assert.notNull(options, "Options must not be null.");
 			return new ExecutableRemoveByIdSupport(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, cas);
+					durabilityLevel, cas, txCtx);
 		}
 
 		@Override
 		public RemoveByIdInCollection inScope(final String scope) {
 			return new ExecutableRemoveByIdSupport(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, cas);
+					durabilityLevel, cas, txCtx);
 		}
 
 		@Override
 		public RemoveByIdWithDurability withCas(Long cas) {
 			return new ExecutableRemoveByIdSupport(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, cas);
+					durabilityLevel, cas, txCtx);
+		}
+
+		@Override
+		public RemoveByIdWithCas transaction(CouchbaseTransactionalOperator txCtx) {
+			return new ExecutableRemoveByIdSupport(template, domainType, scope, collection, options, persistTo, replicateTo,
+					durabilityLevel, cas, txCtx);
 		}
+
 	}
 
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/ExecutableRemoveByQueryOperation.java b/src/main/java/org/springframework/data/couchbase/core/ExecutableRemoveByQueryOperation.java
index a6bfdf0c..0fe7ed12 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ExecutableRemoveByQueryOperation.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ExecutableRemoveByQueryOperation.java
@@ -21,12 +21,13 @@ import org.springframework.data.couchbase.core.query.Query;
 import org.springframework.data.couchbase.core.query.QueryCriteriaDefinition;
 import org.springframework.data.couchbase.core.support.InCollection;
 import org.springframework.data.couchbase.core.support.InScope;
-import org.springframework.data.couchbase.core.support.WithConsistency;
 import org.springframework.data.couchbase.core.support.WithQuery;
 import org.springframework.data.couchbase.core.support.WithQueryOptions;
+import org.springframework.data.couchbase.core.support.WithTransaction;
 
 import com.couchbase.client.java.query.QueryOptions;
 import com.couchbase.client.java.query.QueryScanConsistency;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 
 /**
  * RemoveBy Query Operations
@@ -56,32 +57,58 @@ public interface ExecutableRemoveByQueryOperation {
 	}
 
 	/**
-	 * Fluent methods to specify the query
+	 * Fluent method to specify options.
 	 *
-	 * @param <T> the entity type.
+	 * @param <T> the entity type to use for the results.
 	 */
-	interface RemoveByQueryWithQuery<T> extends TerminatingRemoveByQuery<T>, WithQuery<T> {
+	interface RemoveByQueryWithOptions<T> extends TerminatingRemoveByQuery<T>, WithQueryOptions<RemoveResult> {
+		/**
+		 * Fluent method to specify options to use for execution
+		 *
+		 * @param options to use for execution
+		 */
+		TerminatingRemoveByQuery<T> withOptions(QueryOptions options);
+	}
 
-		TerminatingRemoveByQuery<T> matching(Query query);
+	@Deprecated
+	interface RemoveByQueryConsistentWith<T> extends RemoveByQueryWithOptions<T> {
+
+		@Deprecated
+		RemoveByQueryWithOptions<T> consistentWith(QueryScanConsistency scanConsistency);
 
-		default TerminatingRemoveByQuery<T> matching(QueryCriteriaDefinition criteria) {
-			return matching(Query.query(criteria));
 	}
 
+	interface RemoveByQueryWithConsistency<T> extends RemoveByQueryConsistentWith<T>/*, WithConsistency<T> */{
+		//@Override
+		RemoveByQueryConsistentWith<T> withConsistency(QueryScanConsistency scanConsistency);
+
 	}
 
 	/**
-	 * Fluent method to specify options.
+	 * Fluent method to specify the transaction
 	 *
 	 * @param <T> the entity type to use for the results.
 	 */
-	interface RemoveByQueryWithOptions<T> extends RemoveByQueryWithQuery<T>, WithQueryOptions<RemoveResult> {
+	interface RemoveByQueryWithTransaction<T> extends TerminatingRemoveByQuery<T>, WithTransaction<RemoveResult> {
+		@Override
+		TerminatingRemoveByQuery<T> transaction(CouchbaseTransactionalOperator txCtx);
+	}
+
+	interface RemoveByQueryWithTxOrNot<T> extends RemoveByQueryWithConsistency<T>, RemoveByQueryWithTransaction<T> {}
+
 	/**
-		 * Fluent method to specify options to use for execution
+	 * Fluent methods to specify the query
 	 *
-		 * @param options to use for execution
+	 * @param <T> the entity type.
 	 */
-		RemoveByQueryWithQuery<T> withOptions(QueryOptions options);
+	interface RemoveByQueryWithQuery<T> extends RemoveByQueryWithTxOrNot<T>, WithQuery<T> {
+
+		RemoveByQueryWithTxOrNot<T> matching(Query query);
+
+		default RemoveByQueryWithTxOrNot<T> matching(QueryCriteriaDefinition criteria) {
+			return matching(Query.query(criteria));
+		}
+
 	}
 
 	/**
@@ -89,13 +116,13 @@ public interface ExecutableRemoveByQueryOperation {
 	 *
 	 * @param <T> the entity type to use for the results.
 	 */
-	interface RemoveByQueryInCollection<T> extends RemoveByQueryWithOptions<T>, InCollection<Object> {
+	interface RemoveByQueryInCollection<T> extends RemoveByQueryWithQuery<T>, InCollection<Object> {
 		/**
 		 * With a different collection
 		 *
 		 * @param collection the collection to use.
 		 */
-		RemoveByQueryWithOptions<T> inCollection(String collection);
+		RemoveByQueryWithQuery<T> inCollection(String collection);
 	}
 
 	/**
@@ -112,25 +139,11 @@ public interface ExecutableRemoveByQueryOperation {
 		RemoveByQueryInCollection<T> inScope(String scope);
 	}
 
-	@Deprecated
-	interface RemoveByQueryConsistentWith<T> extends RemoveByQueryInScope<T> {
-
-		@Deprecated
-		RemoveByQueryInScope<T> consistentWith(QueryScanConsistency scanConsistency);
-
-	}
-
-	interface RemoveByQueryWithConsistency<T> extends RemoveByQueryConsistentWith<T>, WithConsistency<T> {
-		@Override
-		RemoveByQueryConsistentWith<T> withConsistency(QueryScanConsistency scanConsistency);
-
-	}
-
 	/**
 	 * Provides methods for constructing query operations in a fluent way.
 	 *
 	 * @param <T> the entity type.
 	 */
-	interface ExecutableRemoveByQuery<T> extends RemoveByQueryWithConsistency<T> {}
+	interface ExecutableRemoveByQuery<T> extends RemoveByQueryInScope<T> {}
 
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/ExecutableRemoveByQueryOperationSupport.java b/src/main/java/org/springframework/data/couchbase/core/ExecutableRemoveByQueryOperationSupport.java
index a97c62ba..81007b7a 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ExecutableRemoveByQueryOperationSupport.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ExecutableRemoveByQueryOperationSupport.java
@@ -19,6 +19,7 @@ import java.util.List;
 
 import org.springframework.data.couchbase.core.ReactiveRemoveByQueryOperationSupport.ReactiveRemoveByQuerySupport;
 import org.springframework.data.couchbase.core.query.Query;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 import org.springframework.util.Assert;
 
 import com.couchbase.client.java.query.QueryOptions;
@@ -36,7 +37,7 @@ public class ExecutableRemoveByQueryOperationSupport implements ExecutableRemove
 
 	@Override
 	public <T> ExecutableRemoveByQuery<T> removeByQuery(Class<T> domainType) {
-		return new ExecutableRemoveByQuerySupport<>(template, domainType, ALL_QUERY, null, null, null, null);
+		return new ExecutableRemoveByQuerySupport<>(template, domainType, ALL_QUERY, null, null, null, null, null);
 	}
 
 	static class ExecutableRemoveByQuerySupport<T> implements ExecutableRemoveByQuery<T> {
@@ -49,18 +50,21 @@ public class ExecutableRemoveByQueryOperationSupport implements ExecutableRemove
 		private final String scope;
 		private final String collection;
 		private final QueryOptions options;
+		private final CouchbaseTransactionalOperator txCtx;
 
 		ExecutableRemoveByQuerySupport(final CouchbaseTemplate template, final Class<T> domainType, final Query query,
-				final QueryScanConsistency scanConsistency, String scope, String collection, QueryOptions options) {
+									   final QueryScanConsistency scanConsistency, String scope, String collection, QueryOptions options,
+									   CouchbaseTransactionalOperator txCtx) {
 			this.template = template;
 			this.domainType = domainType;
 			this.query = query;
 			this.reactiveSupport = new ReactiveRemoveByQuerySupport<>(template.reactive(), domainType, query, scanConsistency,
-					scope, collection, options);
+					scope, collection, options, txCtx);
 			this.scanConsistency = scanConsistency;
 			this.scope = scope;
 			this.collection = collection;
 			this.options = options;
+			this.txCtx = txCtx;
 		}
 
 		@Override
@@ -69,42 +73,49 @@ public class ExecutableRemoveByQueryOperationSupport implements ExecutableRemove
 		}
 
 		@Override
-		public TerminatingRemoveByQuery<T> matching(final Query query) {
+		public RemoveByQueryWithTxOrNot<T> matching(final Query query) {
 			return new ExecutableRemoveByQuerySupport<>(template, domainType, query, scanConsistency, scope, collection,
-					options);
+					options, txCtx);
 		}
 
 		@Override
 		@Deprecated
 		public RemoveByQueryInScope<T> consistentWith(final QueryScanConsistency scanConsistency) {
 			return new ExecutableRemoveByQuerySupport<>(template, domainType, query, scanConsistency, scope, collection,
-					options);
+					options, txCtx);
 		}
 
 		@Override
 		public RemoveByQueryConsistentWith<T> withConsistency(final QueryScanConsistency scanConsistency) {
 			return new ExecutableRemoveByQuerySupport<>(template, domainType, query, scanConsistency, scope, collection,
-					options);
+					options, txCtx);
 		}
 
 		@Override
-		public RemoveByQueryWithConsistency<T> inCollection(final String collection) {
+		public RemoveByQueryWithQuery<T> inCollection(final String collection) {
 			return new ExecutableRemoveByQuerySupport<>(template, domainType, query, scanConsistency, scope, collection,
-					options);
+					options, txCtx);
 		}
 
 		@Override
 		public RemoveByQueryWithQuery<T> withOptions(final QueryOptions options) {
 			Assert.notNull(options, "Options must not be null.");
 			return new ExecutableRemoveByQuerySupport<>(template, domainType, query, scanConsistency, scope, collection,
-					options);
+					options, txCtx);
 		}
 
 		@Override
 		public RemoveByQueryInCollection<T> inScope(final String scope) {
 			return new ExecutableRemoveByQuerySupport<>(template, domainType, query, scanConsistency, scope, collection,
-					options);
+					options, txCtx);
 		}
+
+		@Override
+		public TerminatingRemoveByQuery<T> transaction(final CouchbaseTransactionalOperator txCtx) {
+			return new ExecutableRemoveByQuerySupport<>(template, domainType, query, scanConsistency, scope, collection,
+					options, txCtx);
+		}
+
 	}
 
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/ExecutableReplaceByIdOperation.java b/src/main/java/org/springframework/data/couchbase/core/ExecutableReplaceByIdOperation.java
index 51ce8e98..4aa8a39c 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ExecutableReplaceByIdOperation.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ExecutableReplaceByIdOperation.java
@@ -24,11 +24,13 @@ import org.springframework.data.couchbase.core.support.OneAndAllEntity;
 import org.springframework.data.couchbase.core.support.WithDurability;
 import org.springframework.data.couchbase.core.support.WithExpiry;
 import org.springframework.data.couchbase.core.support.WithReplaceOptions;
+import org.springframework.data.couchbase.core.support.WithTransaction;
 
 import com.couchbase.client.core.msg.kv.DurabilityLevel;
 import com.couchbase.client.java.kv.PersistTo;
 import com.couchbase.client.java.kv.ReplaceOptions;
 import com.couchbase.client.java.kv.ReplicateTo;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 
 /**
  * Replace Operations
@@ -83,19 +85,41 @@ public interface ExecutableReplaceByIdOperation {
 		TerminatingReplaceById<T> withOptions(ReplaceOptions options);
 	}
 
+	interface ReplaceByIdWithDurability<T> extends ReplaceByIdWithOptions<T>, WithDurability<T> {
+		@Override
+		ReplaceByIdWithOptions<T> withDurability(DurabilityLevel durabilityLevel);
+
+		@Override
+		ReplaceByIdWithOptions<T> withDurability(PersistTo persistTo, ReplicateTo replicateTo);
+
+	}
+
+	interface ReplaceByIdWithExpiry<T> extends ReplaceByIdWithDurability<T>, WithExpiry<T> {
+		@Override
+		ReplaceByIdWithDurability<T> withExpiry(final Duration expiry);
+	}
+
+	interface ReplaceByIdWithTransaction<T> extends TerminatingReplaceById<T>, WithTransaction<T> {
+		// todo gpx is this staying?  It's confusing when doing ops.replaceById() inside @Transactional to get this transaction() method - unclear as a user whether I need to call it or not
+		@Override
+		TerminatingReplaceById<T> transaction(CouchbaseTransactionalOperator txCtx);
+	}
+
+	interface ReplaceByIdTxOrNot<T> extends ReplaceByIdWithExpiry<T>, ReplaceByIdWithTransaction<T> {}
+
 	/**
 	 * Fluent method to specify the collection.
 	 *
 	 * @param <T> the entity type to use for the results.
 	 */
-	interface ReplaceByIdInCollection<T> extends ReplaceByIdWithOptions<T>, InCollection<T> {
+	interface ReplaceByIdInCollection<T> extends ReplaceByIdTxOrNot<T>, InCollection<T> {
 		/**
 		 * With a different collection
 		 *
 		 * @param collection the collection to use.
 		 */
 		@Override
-		ReplaceByIdWithOptions<T> inCollection(String collection);
+		ReplaceByIdTxOrNot<T> inCollection(String collection);
 	}
 
 	/**
@@ -113,24 +137,11 @@ public interface ExecutableReplaceByIdOperation {
 		ReplaceByIdInCollection<T> inScope(String scope);
 	}
 
-	interface ReplaceByIdWithDurability<T> extends ReplaceByIdInScope<T>, WithDurability<T> {
-		@Override
-		ReplaceByIdInScope<T> withDurability(DurabilityLevel durabilityLevel);
-		@Override
-		ReplaceByIdInScope<T> withDurability(PersistTo persistTo, ReplicateTo replicateTo);
-
-	}
-
-	interface ReplaceByIdWithExpiry<T> extends ReplaceByIdWithDurability<T>, WithExpiry<T> {
-		@Override
-		ReplaceByIdWithDurability<T> withExpiry(final Duration expiry);
-	}
-
 	/**
 	 * Provides methods for constructing KV replace operations in a fluent way.
 	 *
 	 * @param <T> the entity type to replace
 	 */
-	interface ExecutableReplaceById<T> extends ReplaceByIdWithExpiry<T> {}
+	interface ExecutableReplaceById<T> extends ReplaceByIdInScope<T> {}
 
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/ExecutableReplaceByIdOperationSupport.java b/src/main/java/org/springframework/data/couchbase/core/ExecutableReplaceByIdOperationSupport.java
index ef47eb94..751a5bf7 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ExecutableReplaceByIdOperationSupport.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ExecutableReplaceByIdOperationSupport.java
@@ -19,6 +19,7 @@ import java.time.Duration;
 import java.util.Collection;
 
 import org.springframework.data.couchbase.core.ReactiveReplaceByIdOperationSupport.ReactiveReplaceByIdSupport;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 import org.springframework.util.Assert;
 
 import com.couchbase.client.core.msg.kv.DurabilityLevel;
@@ -38,7 +39,7 @@ public class ExecutableReplaceByIdOperationSupport implements ExecutableReplaceB
 	public <T> ExecutableReplaceById<T> replaceById(final Class<T> domainType) {
 		Assert.notNull(domainType, "DomainType must not be null!");
 		return new ExecutableReplaceByIdSupport<>(template, domainType, null, null, null, PersistTo.NONE, ReplicateTo.NONE,
-				DurabilityLevel.NONE, null);
+				DurabilityLevel.NONE, null, null);
 	}
 
 	static class ExecutableReplaceByIdSupport<T> implements ExecutableReplaceById<T> {
@@ -52,11 +53,12 @@ public class ExecutableReplaceByIdOperationSupport implements ExecutableReplaceB
 		private final ReplicateTo replicateTo;
 		private final DurabilityLevel durabilityLevel;
 		private final Duration expiry;
+		private final CouchbaseTransactionalOperator txCtx;
 		private final ReactiveReplaceByIdSupport<T> reactiveSupport;
 
 		ExecutableReplaceByIdSupport(final CouchbaseTemplate template, final Class<T> domainType, final String scope,
 									 final String collection, ReplaceOptions options, final PersistTo persistTo, final ReplicateTo replicateTo,
-				final DurabilityLevel durabilityLevel, final Duration expiry) {
+									 final DurabilityLevel durabilityLevel, final Duration expiry, final CouchbaseTransactionalOperator txCtx) {
 			this.template = template;
 			this.domainType = domainType;
 			this.scope = scope;
@@ -66,8 +68,10 @@ public class ExecutableReplaceByIdOperationSupport implements ExecutableReplaceB
 			this.replicateTo = replicateTo;
 			this.durabilityLevel = durabilityLevel;
 			this.expiry = expiry;
+			this.txCtx = txCtx;
 			this.reactiveSupport = new ReactiveReplaceByIdSupport<>(template.reactive(), domainType, scope, collection,
-					options, persistTo, replicateTo, durabilityLevel, expiry, new NonReactiveSupportWrapper(template.support()));
+					options, persistTo, replicateTo, durabilityLevel, expiry, txCtx,
+					new NonReactiveSupportWrapper(template.support()));
 		}
 
 		@Override
@@ -81,16 +85,16 @@ public class ExecutableReplaceByIdOperationSupport implements ExecutableReplaceB
 		}
 
 		@Override
-		public ReplaceByIdWithOptions<T> inCollection(final String collection) {
+		public ReplaceByIdTxOrNot<T> inCollection(final String collection) {
 			return new ExecutableReplaceByIdSupport<>(template, domainType, scope, collection, options, persistTo,
-					replicateTo, durabilityLevel, expiry);
+					replicateTo, durabilityLevel, expiry, txCtx);
 		}
 
 		@Override
 		public ReplaceByIdInScope<T> withDurability(final DurabilityLevel durabilityLevel) {
 			Assert.notNull(durabilityLevel, "Durability Level must not be null.");
 			return new ExecutableReplaceByIdSupport<>(template, domainType, scope, collection, options, persistTo,
-					replicateTo, durabilityLevel, expiry);
+					replicateTo, durabilityLevel, expiry, txCtx);
 		}
 
 		@Override
@@ -98,27 +102,34 @@ public class ExecutableReplaceByIdOperationSupport implements ExecutableReplaceB
 			Assert.notNull(persistTo, "PersistTo must not be null.");
 			Assert.notNull(replicateTo, "ReplicateTo must not be null.");
 			return new ExecutableReplaceByIdSupport<>(template, domainType, scope, collection, options, persistTo,
-					replicateTo, durabilityLevel, expiry);
+					replicateTo, durabilityLevel, expiry, txCtx);
 		}
 
 		@Override
 		public ReplaceByIdWithDurability<T> withExpiry(final Duration expiry) {
 			Assert.notNull(expiry, "expiry must not be null.");
 			return new ExecutableReplaceByIdSupport<>(template, domainType, scope, collection, options, persistTo,
-					replicateTo, durabilityLevel, expiry);
+					replicateTo, durabilityLevel, expiry, txCtx);
+		}
+
+		@Override
+		public ReplaceByIdWithExpiry<T> transaction(final CouchbaseTransactionalOperator txCtx) {
+			Assert.notNull(txCtx, "txCtx must not be null.");
+			return new ExecutableReplaceByIdSupport<>(template, domainType, scope, collection, options, persistTo,
+					replicateTo, durabilityLevel, expiry, txCtx);
 		}
 
 		@Override
 		public TerminatingReplaceById<T> withOptions(final ReplaceOptions options) {
 			Assert.notNull(options, "Options must not be null.");
 			return new ExecutableReplaceByIdSupport<>(template, domainType, scope, collection, options, persistTo,
-					replicateTo, durabilityLevel, expiry);
+					replicateTo, durabilityLevel, expiry, txCtx);
 		}
 
 		@Override
 		public ReplaceByIdInCollection<T> inScope(final String scope) {
 			return new ExecutableReplaceByIdSupport<>(template, domainType, scope, collection, options, persistTo,
-					replicateTo, durabilityLevel, expiry);
+					replicateTo, durabilityLevel, expiry, txCtx);
 		}
 
 	}
diff --git a/src/main/java/org/springframework/data/couchbase/core/ExecutableUpsertByIdOperation.java b/src/main/java/org/springframework/data/couchbase/core/ExecutableUpsertByIdOperation.java
index 0831f8eb..56f93d02 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ExecutableUpsertByIdOperation.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ExecutableUpsertByIdOperation.java
@@ -83,19 +83,32 @@ public interface ExecutableUpsertByIdOperation {
 		TerminatingUpsertById<T> withOptions(UpsertOptions options);
 	}
 
+	interface UpsertByIdWithDurability<T> extends UpsertByIdWithOptions<T>, WithDurability<T> {
+		@Override
+		UpsertByIdWithOptions<T> withDurability(DurabilityLevel durabilityLevel);
+
+		@Override
+		UpsertByIdWithOptions<T> withDurability(PersistTo persistTo, ReplicateTo replicateTo);
+	}
+
+	interface UpsertByIdWithExpiry<T> extends UpsertByIdWithDurability<T>, WithExpiry<T> {
+		@Override
+		UpsertByIdWithDurability<T> withExpiry(Duration expiry);
+	}
+
 	/**
 	 * Fluent method to specify the collection.
 	 *
 	 * @param <T> the entity type to use for the results.
 	 */
-	interface UpsertByIdInCollection<T> extends UpsertByIdWithOptions<T>, InCollection<T> {
+	interface UpsertByIdInCollection<T> extends UpsertByIdWithExpiry<T>, InCollection<T> {
 		/**
 		 * With a different collection
 		 *
 		 * @param collection the collection to use.
 		 */
 		@Override
-		UpsertByIdWithOptions<T> inCollection(String collection);
+		UpsertByIdWithExpiry<T> inCollection(String collection);
 	}
 
 	/**
@@ -113,25 +126,11 @@ public interface ExecutableUpsertByIdOperation {
 		UpsertByIdInCollection<T> inScope(String scope);
 	}
 
-	interface UpsertByIdWithDurability<T> extends UpsertByIdInScope<T>, WithDurability<T> {
-		@Override
-		UpsertByIdInScope<T> withDurability(DurabilityLevel durabilityLevel);
-
-		@Override
-		UpsertByIdInScope<T> withDurability(PersistTo persistTo, ReplicateTo replicateTo);
-
-	}
-
-	interface UpsertByIdWithExpiry<T> extends UpsertByIdWithDurability<T>, WithExpiry<T> {
-		@Override
-		UpsertByIdWithDurability<T> withExpiry(Duration expiry);
-	}
-
 	/**
 	 * Provides methods for constructing KV operations in a fluent way.
 	 *
 	 * @param <T> the entity type to upsert
 	 */
-	interface ExecutableUpsertById<T> extends UpsertByIdWithExpiry<T> {}
+	interface ExecutableUpsertById<T> extends UpsertByIdInScope<T> {}
 
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/ExecutableUpsertByIdOperationSupport.java b/src/main/java/org/springframework/data/couchbase/core/ExecutableUpsertByIdOperationSupport.java
index 61b7a394..7dd548b7 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ExecutableUpsertByIdOperationSupport.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ExecutableUpsertByIdOperationSupport.java
@@ -94,7 +94,7 @@ public class ExecutableUpsertByIdOperationSupport implements ExecutableUpsertByI
 		}
 
 		@Override
-		public UpsertByIdWithOptions<T> inCollection(final String collection) {
+		public UpsertByIdWithExpiry<T> inCollection(final String collection) {
 			return new ExecutableUpsertByIdSupport<>(template, domainType, scope, collection, options, persistTo, replicateTo,
 					durabilityLevel, expiry);
 		}
diff --git a/src/main/java/org/springframework/data/couchbase/core/GenericSupport.java b/src/main/java/org/springframework/data/couchbase/core/GenericSupport.java
new file mode 100644
index 00000000..adf8f015
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/core/GenericSupport.java
@@ -0,0 +1,64 @@
+package org.springframework.data.couchbase.core;
+
+import com.couchbase.client.core.transaction.CoreTransactionAttemptContext;
+import reactor.core.publisher.Mono;
+
+import java.util.function.Function;
+
+import org.springframework.data.couchbase.core.mapping.CouchbaseDocument;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
+import org.springframework.lang.Nullable;
+
+import com.couchbase.client.core.annotation.Stability;
+import com.couchbase.client.java.ReactiveCollection;
+
+// todo gp better name
+@Stability.Internal
+class GenericSupportHelper {
+	public final CouchbaseDocument converted;
+	public final Long cas;
+	public final ReactiveCollection collection;
+	public final @Nullable CoreTransactionAttemptContext ctx;
+
+	public GenericSupportHelper(CouchbaseDocument doc, Long cas, ReactiveCollection collection,
+			@Nullable CoreTransactionAttemptContext ctx) {
+		this.converted = doc;
+		this.cas = cas;
+		this.collection = collection;
+		this.ctx = ctx;
+	}
+}
+
+// todo gp better name
+@Stability.Internal
+public class GenericSupport {
+	public static <T> Mono<T> one(Mono<ReactiveCouchbaseTemplate> tmpl, CouchbaseTransactionalOperator transactionalOperator,
+			String scopeName, String collectionName, ReactiveTemplateSupport support, T object,
+			Function<GenericSupportHelper, Mono<T>> nonTransactional, Function<GenericSupportHelper, Mono<T>> transactional) {
+		// todo gp how safe is this? I think we can switch threads potentially
+		// Optional<TransactionAttemptContext> ctxr = Optional.ofNullable((TransactionAttemptContext)
+		// org.springframework.transaction.support.TransactionSynchronizationManager.getResource(TransactionAttemptContext.class));
+
+		return tmpl.flatMap(template -> template.getCouchbaseClientFactory().withScope(scopeName)
+				.getCollection(collectionName).flatMap(collection -> support.encodeEntity(object)
+						.flatMap(converted -> tmpl.flatMap(tp -> tp.getCouchbaseClientFactory().getTransactionResources(null).flatMap(s -> {
+							GenericSupportHelper gsh = new GenericSupportHelper(converted, support.getCas(object),
+									collection.reactive(), s.getCore() != null ? s.getCore()
+											: (transactionalOperator != null ? transactionalOperator.getAttemptContext() : null));
+							if (gsh.ctx == null) {
+								System.err.println("non-tx");
+								return nonTransactional.apply(gsh);
+							} else {
+								System.err.println("tx");
+								return transactional.apply(gsh);
+							}
+						})).onErrorMap(throwable -> {
+							if (throwable instanceof RuntimeException) {
+								return template.potentiallyConvertRuntimeException((RuntimeException) throwable);
+							} else {
+								return throwable;
+							}
+						}))));
+	}
+
+}
diff --git a/src/main/java/org/springframework/data/couchbase/core/NonReactiveSupportWrapper.java b/src/main/java/org/springframework/data/couchbase/core/NonReactiveSupportWrapper.java
index 6e64ecb3..2020a0d4 100644
--- a/src/main/java/org/springframework/data/couchbase/core/NonReactiveSupportWrapper.java
+++ b/src/main/java/org/springframework/data/couchbase/core/NonReactiveSupportWrapper.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2021 the original author or authors.
+ * Copyright 2021-2022 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,10 +15,12 @@
  */
 package org.springframework.data.couchbase.core;
 
+import org.springframework.data.couchbase.core.convert.translation.TranslationService;
+import org.springframework.data.couchbase.transaction.ReactiveCouchbaseResourceHolder;
 import reactor.core.publisher.Mono;
 
 import org.springframework.data.couchbase.core.mapping.CouchbaseDocument;
-import org.springframework.data.couchbase.core.mapping.event.CouchbaseMappingEvent;
+import org.springframework.data.couchbase.repository.support.TransactionResultHolder;
 
 /**
  * Wrapper of {@link TemplateSupport} methods to adapt them to {@link ReactiveTemplateSupport}.
@@ -40,32 +42,52 @@ public class NonReactiveSupportWrapper implements ReactiveTemplateSupport {
 	}
 
 	@Override
-	public <T> Mono<T> decodeEntity(String id, String source, long cas, Class<T> entityClass) {
-		return Mono.fromSupplier(() -> support.decodeEntity(id, source, cas, entityClass));
+	public <T> Mono<T> decodeEntity(String id, String source, long cas, Class<T> entityClass, String scope, String collection,
+									TransactionResultHolder txResultHolder) {
+		return decodeEntity(id, source, cas, entityClass, scope, collection, txResultHolder, null);
 	}
 
 	@Override
-	public Mono<Object> applyUpdatedCas(Object entity, CouchbaseDocument converted, long cas) {
-		return Mono.fromSupplier(() -> support.applyUpdatedCas(entity, converted, cas));
+	public <T> Mono<T> decodeEntity(String id, String source, long cas, Class<T> entityClass, String scope, String collection,
+									TransactionResultHolder txResultHolder, ReactiveCouchbaseResourceHolder holder) {
+		return Mono.fromSupplier(() -> support.decodeEntity(id, source, cas, entityClass, scope, collection, txResultHolder, holder));
 	}
 
 	@Override
-	public Mono<Object> applyUpdatedId(Object entity, Object id) {
-		return Mono.fromSupplier(() -> support.applyUpdatedId(entity, id));
+	public <T> Mono<T> applyResult(T entity, CouchbaseDocument converted, Object id, Long cas,
+								   TransactionResultHolder txResultHolder) {
+		return Mono.fromSupplier(() -> support.applyResult(entity, converted, id, cas, txResultHolder));
 	}
 
+	@Override
+	public <T> Mono<T> applyResult(T entity, CouchbaseDocument converted, Object id, Long cas,
+								   TransactionResultHolder txResultHolder, ReactiveCouchbaseResourceHolder holder) {
+		return Mono.fromSupplier(() -> support.applyResult(entity, converted, id, cas, txResultHolder, holder));
+	}
+
+
 	@Override
 	public Long getCas(Object entity) {
 		return support.getCas(entity);
 	}
 
+	@Override
+	public Object getId(Object entity) {
+		return support.getId(entity);
+	}
+
 	@Override
 	public String getJavaNameForEntity(Class<?> clazz) {
 		return support.getJavaNameForEntity(clazz);
 	}
 
 	@Override
-	public void maybeEmitEvent(CouchbaseMappingEvent<?> event) {
-		support.maybeEmitEvent(event);
+	public <T> Integer getTxResultHolder(T source) {
+		return support.getTxResultHolder(source);
+	}
+
+	@Override
+	public TranslationService getTranslationService() {
+		return support.getTranslationService();
 	}
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/ReactiveCouchbaseOperations.java b/src/main/java/org/springframework/data/couchbase/core/ReactiveCouchbaseOperations.java
index 81b8cfde..25d39e85 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ReactiveCouchbaseOperations.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ReactiveCouchbaseOperations.java
@@ -16,7 +16,10 @@
 package org.springframework.data.couchbase.core;
 
 import org.springframework.data.couchbase.CouchbaseClientFactory;
+import org.springframework.data.couchbase.ReactiveCouchbaseClientFactory;
 import org.springframework.data.couchbase.core.convert.CouchbaseConverter;
+import org.springframework.data.couchbase.core.query.Query;
+import reactor.core.publisher.Mono;
 
 import com.couchbase.client.java.query.QueryScanConsistency;
 
@@ -47,7 +50,11 @@ public interface ReactiveCouchbaseOperations extends ReactiveFluentCouchbaseOper
 	/**
 	 * Returns the underlying client factory.
 	 */
-	CouchbaseClientFactory getCouchbaseClientFactory();
+	ReactiveCouchbaseClientFactory getCouchbaseClientFactory();
+
+	<T> Mono<T> save(T entity);
+
+	<T> Mono<Long> count(Query query, Class<T> personClass);
     
     /**
      * @return the default consistency to use for queries
diff --git a/src/main/java/org/springframework/data/couchbase/core/ReactiveCouchbaseTemplate.java b/src/main/java/org/springframework/data/couchbase/core/ReactiveCouchbaseTemplate.java
index 260bbd44..4450da16 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ReactiveCouchbaseTemplate.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ReactiveCouchbaseTemplate.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,17 +16,35 @@
 
 package org.springframework.data.couchbase.core;
 
+import org.springframework.data.couchbase.transaction.ReactiveCouchbaseResourceHolder;
+import reactor.core.publisher.Mono;
+
+import java.util.function.Consumer;
+
 import org.springframework.beans.BeansException;
 import org.springframework.context.ApplicationContext;
 import org.springframework.context.ApplicationContextAware;
+import org.springframework.context.ApplicationListener;
 import org.springframework.dao.DataAccessException;
 import org.springframework.dao.support.PersistenceExceptionTranslator;
 import org.springframework.data.couchbase.CouchbaseClientFactory;
+import org.springframework.data.couchbase.ReactiveCouchbaseClientFactory;
 import org.springframework.data.couchbase.core.convert.CouchbaseConverter;
 import org.springframework.data.couchbase.core.convert.translation.JacksonTranslationService;
 import org.springframework.data.couchbase.core.convert.translation.TranslationService;
+import org.springframework.data.couchbase.core.mapping.CouchbasePersistentEntity;
+import org.springframework.data.couchbase.core.mapping.CouchbasePersistentProperty;
+import org.springframework.data.couchbase.core.query.Query;
 import org.springframework.data.couchbase.core.support.PseudoArgs;
-
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
+import org.springframework.data.couchbase.transaction.ReactiveCouchbaseClientUtils;
+import org.springframework.data.couchbase.transaction.SessionSynchronization;
+import org.springframework.data.mapping.context.MappingContextEvent;
+import org.springframework.util.Assert;
+import org.springframework.util.ReflectionUtils;
+
+import com.couchbase.client.core.transaction.CoreTransactionAttemptContext;
+import com.couchbase.client.java.ClusterInterface;
 import com.couchbase.client.java.Collection;
 import com.couchbase.client.java.query.QueryScanConsistency;
 
@@ -40,24 +58,31 @@ import com.couchbase.client.java.query.QueryScanConsistency;
  */
 public class ReactiveCouchbaseTemplate implements ReactiveCouchbaseOperations, ApplicationContextAware {
 
-	private final CouchbaseClientFactory clientFactory;
+	private final ReactiveCouchbaseClientFactory clientFactory;
 	private final CouchbaseConverter converter;
 	private final PersistenceExceptionTranslator exceptionTranslator;
 	private final ReactiveCouchbaseTemplateSupport templateSupport;
 	private ThreadLocal<PseudoArgs<?>> threadLocalArgs = new ThreadLocal<>();
 	private QueryScanConsistency scanConsistency;
 
-	public ReactiveCouchbaseTemplate(final CouchbaseClientFactory clientFactory, final CouchbaseConverter converter) {
-		this(clientFactory, converter, new JacksonTranslationService());
+	public ReactiveCouchbaseTemplate with(CouchbaseTransactionalOperator txOp) {
+		// TODO: why does txOp go on the clientFactory? can't we just put it on the template??
+		return new ReactiveCouchbaseTemplate(getCouchbaseClientFactory().with(txOp), getConverter(),
+				support().getTranslationService(), getConsistency());
 	}
 
-	public ReactiveCouchbaseTemplate(final CouchbaseClientFactory clientFactory, final CouchbaseConverter converter,
-			final TranslationService translationService) {
-		this(clientFactory, converter, translationService, null);
+	public CouchbaseTransactionalOperator txOperator() {
+		return clientFactory.getTransactionalOperator();
 	}
 
-	public ReactiveCouchbaseTemplate(final CouchbaseClientFactory clientFactory, final CouchbaseConverter converter,
-			final TranslationService translationService, QueryScanConsistency scanConsistency) {
+	public ReactiveCouchbaseTemplate(final ReactiveCouchbaseClientFactory clientFactory,
+									 final CouchbaseConverter converter) {
+		this(clientFactory, converter, new JacksonTranslationService(), null);
+	}
+
+	public ReactiveCouchbaseTemplate(final ReactiveCouchbaseClientFactory clientFactory,
+									 final CouchbaseConverter converter, final TranslationService translationService,
+									 final QueryScanConsistency scanConsistency) {
 		this.clientFactory = clientFactory;
 		this.converter = converter;
 		this.exceptionTranslator = clientFactory.getExceptionTranslator();
@@ -65,6 +90,49 @@ public class ReactiveCouchbaseTemplate implements ReactiveCouchbaseOperations, A
 		this.scanConsistency = scanConsistency;
 	}
 
+	// public ReactiveCouchbaseTemplate(final CouchbaseClientFactory clientFactory, final CouchbaseConverter converter) {
+	// this(clientFactory, converter, new JacksonTranslationService());
+	// }
+
+	// public ReactiveCouchbaseTemplate(final ReactiveCouchbaseClientFactory clientFactory, final CouchbaseConverter
+	// converter,
+	// final TranslationService translationService) {
+	// this.clientFactory = clientFactory;
+	// this.converter = converter;
+	// this.exceptionTranslator = this.clientFactory.getExceptionTranslator();
+	// this.templateSupport = new ReactiveCouchbaseTemplateSupport(this, converter, translationService);
+	// }
+
+	public <T> Mono<T> save(T entity) {
+		Assert.notNull(entity, "Entity must not be null!");
+		Mono<T> result;
+		final CouchbasePersistentEntity<?> mapperEntity = getConverter().getMappingContext()
+				.getPersistentEntity(entity.getClass());
+		final CouchbasePersistentProperty versionProperty = mapperEntity.getVersionProperty();
+		final boolean versionPresent = versionProperty != null;
+		final Long version = versionProperty == null || versionProperty.getField() == null ? null
+				: (Long) ReflectionUtils.getField(versionProperty.getField(), entity);
+		final boolean existingDocument = version != null && version > 0;
+
+		Class clazz = entity.getClass();
+
+		if (!versionPresent) { // the entity doesn't have a version property
+			// No version field - no cas
+			result = (Mono<T>) upsertById(clazz).one(entity);
+		} else if (existingDocument) { // there is a version property, and it is non-zero
+			// Updating existing document with cas
+			result = (Mono<T>) replaceById(clazz).one(entity);
+		} else { // there is a version property, but it's zero or not set.
+			// Creating new document
+			result = (Mono<T>) insertById(clazz).one(entity);
+		}
+		return result;
+	}
+
+	public <T> Mono<Long> count(Query query, Class<T> domainType) {
+		return findByQuery(domainType).matching(query).all().count();
+	}
+
 	@Override
 	public <T> ReactiveFindById<T> findById(Class<T> domainType) {
 		return new ReactiveFindByIdOperationSupport(this).findById(domainType);
@@ -127,16 +195,16 @@ public class ReactiveCouchbaseTemplate implements ReactiveCouchbaseOperations, A
 
 	@Override
 	public String getBucketName() {
-		return clientFactory.getBucket().name();
+		return clientFactory.getBucket().block().name();
 	}
 
 	@Override
 	public String getScopeName() {
-		return clientFactory.getScope().name();
+		return clientFactory.getScope().block().name();
 	}
 
 	@Override
-	public CouchbaseClientFactory getCouchbaseClientFactory() {
+	public ReactiveCouchbaseClientFactory getCouchbaseClientFactory() {
 		return clientFactory;
 	}
 
@@ -147,7 +215,7 @@ public class ReactiveCouchbaseTemplate implements ReactiveCouchbaseOperations, A
 	 * @return the collection instance.
 	 */
 	public Collection getCollection(final String collectionName) {
-		return clientFactory.getCollection(collectionName);
+		return clientFactory.getCollection(collectionName).block();
 	}
 
 	@Override
@@ -166,7 +234,8 @@ public class ReactiveCouchbaseTemplate implements ReactiveCouchbaseOperations, A
 	 * @param ex the exception to translate
 	 */
 	RuntimeException potentiallyConvertRuntimeException(final RuntimeException ex) {
-		RuntimeException resolved = exceptionTranslator.translateExceptionIfPossible(ex);
+		RuntimeException resolved = exceptionTranslator != null ? exceptionTranslator.translateExceptionIfPossible(ex)
+				: null;
 		return resolved == null ? ex : resolved;
 	}
 
@@ -198,4 +267,190 @@ public class ReactiveCouchbaseTemplate implements ReactiveCouchbaseOperations, A
 		return scanConsistency;
 	}
 
+	protected Mono<ClusterInterface> doGetDatabase() {
+		return ReactiveCouchbaseClientUtils.getDatabase(clientFactory, SessionSynchronization.ON_ACTUAL_TRANSACTION);
+	}
+
+	protected Mono<ReactiveCouchbaseTemplate> doGetTemplate() {
+		return ReactiveCouchbaseClientUtils.getTemplate(clientFactory, SessionSynchronization.ON_ACTUAL_TRANSACTION,
+				this.getConverter());
+	}
+
+	/*
+	private <T> Flux<T> withSession(ReactiveSessionCallback<T> action, ClientSession session) {
+
+		ReactiveSessionBoundCouchbaseTemplate operations = new ReactiveSessionBoundCouchbaseTemplate(session,
+				ReactiveCouchbaseTemplate.this);
+
+		return Flux.from(action.doInSession(operations)) //
+				.contextWrite(ctx -> ReactiveMongoContext.setSession(ctx, Mono.just(session)));
+	}
+	*/
+	/*
+	 * (non-Javadoc)
+	 * @see org.springframework.data.mongodb.core.ReactiveMongoOperations#withSession(com.mongodb.session.ClientSession)
+	 */
+	public ReactiveCouchbaseOperations withCore(ReactiveCouchbaseResourceHolder core) {
+		return new ReactiveSessionBoundCouchbaseTemplate(core, ReactiveCouchbaseTemplate.this);
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * @see org.springframework.data.mongodb.core.ReactiveMongoOperations#withSession(com.mongodb.ClientSessionOptions)
+	 */
+	/*
+	@Override
+	public ReactiveSessionScoped withSession(ClientSessionOptions sessionOptions) {
+		return withSession(mongoDatabaseFactory.getSession(sessionOptions));
+	}
+
+	 */
+
+	/**
+	 * {@link CouchbaseTemplate} extension bound to a specific {@link CoreTransactionAttemptContext} that is applied when
+	 * interacting with the server through the driver API. <br />
+	 * The prepare steps for {} and {} proxy the target and invoke the desired target method matching the actual arguments
+	 * plus a {@link CoreTransactionAttemptContext}.
+	 *
+	 * @author Christoph Strobl
+	 * @since 2.1
+	 */
+	static class ReactiveSessionBoundCouchbaseTemplate extends ReactiveCouchbaseTemplate {
+
+		private final ReactiveCouchbaseTemplate delegate;
+		private final ReactiveCouchbaseResourceHolder holder;
+
+		/**
+		 * @param holder must not be {@literal null}.
+		 * @param that must not be {@literal null}.
+		 */
+		ReactiveSessionBoundCouchbaseTemplate(ReactiveCouchbaseResourceHolder holder, ReactiveCouchbaseTemplate that) {
+
+			super(that.clientFactory.withCore(holder), that.getConverter());
+
+			this.delegate = that;
+			this.holder = holder;
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * @see org.springframework.data.mongodb.core.ReactiveMongoTemplate#getCollection(java.lang.String)
+		 */
+		@Override
+		public Collection getCollection(String collectionName) {
+
+			// native MongoDB objects that offer methods with ClientSession must not be proxied.
+			return delegate.getCollection(collectionName);
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * @see org.springframework.data.mongodb.core.ReactiveMongoTemplate#getMongoDatabase()
+		 */
+		@Override
+		public ReactiveCouchbaseClientFactory getCouchbaseClientFactory() {
+
+			// native MongoDB objects that offer methods with ClientSession must not be proxied.
+			return delegate.getCouchbaseClientFactory();
+		}
+	}
+
+	class IndexCreatorEventListener implements ApplicationListener<MappingContextEvent<?, ?>> {
+
+		final Consumer<Throwable> subscriptionExceptionHandler;
+
+		public IndexCreatorEventListener(Consumer<Throwable> subscriptionExceptionHandler) {
+			this.subscriptionExceptionHandler = subscriptionExceptionHandler;
+		}
+
+		@Override
+		public void onApplicationEvent(MappingContextEvent<?, ?> event) {
+
+			if (!event.wasEmittedBy(converter.getMappingContext())) {
+				return;
+			}
+
+			// PersistentEntity<?, ?> entity = event.getPersistentEntity();
+
+			// Double check type as Spring infrastructure does not consider nested generics
+			// if (entity instanceof MongoPersistentEntity) {
+			// onCheckForIndexes((MongoPersistentEntity<?>) entity, subscriptionExceptionHandler);
+			// }
+		}
+	}
+
+	/**
+	 * Get the TransactionalOperator from <br>
+	 * 1. The template.clientFactory<br>
+	 * 2. The template.threadLocal<br>
+	 * 3. otherwise null<br>
+	 * This can be overriden in the operation method by<br>
+	 * 1. repository.withCollection()
+	 */
+	/*
+	private CouchbaseStuffHandle getTransactionalOperator() {
+		if (this.getCouchbaseClientFactory().getTransactionalOperator() != null) {
+			return this.getCouchbaseClientFactory().getTransactionalOperator();
+		}
+		ReactiveCouchbaseTemplate t = this;
+		PseudoArgs pArgs = t.getPseudoArgs();
+		if (pArgs != null && pArgs.getTxOp() != null) {
+			return pArgs.getTxOp();
+		}
+		return null;
+	}
+	 */
+	/**
+	 * Value object chaining together a given source document with its mapped representation and the collection to persist
+	 * it to.
+	 *
+	 * @param <T>
+	 * @author Christoph Strobl
+	 * @since 2.2
+	 */
+	/*
+	private static class PersistableEntityModel<T> {
+	
+		private final T source;
+		private final @Nullable
+		Document target;
+		private final String collection;
+	
+		private PersistableEntityModel(T source, @Nullable Document target, String collection) {
+	
+			this.source = source;
+			this.target = target;
+			this.collection = collection;
+		}
+	
+		static <T> PersistableEntityModel<T> of(T source, String collection) {
+			return new PersistableEntityModel<>(source, null, collection);
+		}
+	
+		static <T> PersistableEntityModel<T> of(T source, Document target, String collection) {
+			return new PersistableEntityModel<>(source, target, collection);
+		}
+	
+		PersistableEntityModel<T> mutate(T source) {
+			return new PersistableEntityModel(source, target, collection);
+		}
+	
+		PersistableEntityModel<T> addTargetDocument(Document target) {
+			return new PersistableEntityModel(source, target, collection);
+		}
+	
+		T getSource() {
+			return source;
+		}
+	
+		@Nullable
+		Document getTarget() {
+			return target;
+		}
+	
+		String getCollection() {
+			return collection;
+		}
+	
+	 */
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/ReactiveCouchbaseTemplateSupport.java b/src/main/java/org/springframework/data/couchbase/core/ReactiveCouchbaseTemplateSupport.java
index d2f9d69a..7d73839c 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ReactiveCouchbaseTemplateSupport.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ReactiveCouchbaseTemplateSupport.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,31 +16,22 @@
 
 package org.springframework.data.couchbase.core;
 
+import org.springframework.data.couchbase.repository.support.TransactionResultHolder;
+import org.springframework.data.couchbase.transaction.ReactiveCouchbaseResourceHolder;
 import reactor.core.publisher.Mono;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 import org.springframework.beans.BeansException;
 import org.springframework.context.ApplicationContext;
 import org.springframework.context.ApplicationContextAware;
 import org.springframework.data.couchbase.core.convert.CouchbaseConverter;
-import org.springframework.data.couchbase.core.convert.join.N1qlJoinResolver;
 import org.springframework.data.couchbase.core.convert.translation.TranslationService;
 import org.springframework.data.couchbase.core.mapping.CouchbaseDocument;
-import org.springframework.data.couchbase.core.mapping.CouchbasePersistentEntity;
-import org.springframework.data.couchbase.core.mapping.CouchbasePersistentProperty;
-import org.springframework.data.couchbase.core.mapping.event.AfterSaveEvent;
 import org.springframework.data.couchbase.core.mapping.event.BeforeConvertEvent;
 import org.springframework.data.couchbase.core.mapping.event.BeforeSaveEvent;
-import org.springframework.data.couchbase.core.mapping.event.CouchbaseMappingEvent;
 import org.springframework.data.couchbase.core.mapping.event.ReactiveAfterConvertCallback;
 import org.springframework.data.couchbase.core.mapping.event.ReactiveBeforeConvertCallback;
-import org.springframework.data.couchbase.repository.support.MappingCouchbaseEntityInformation;
-import org.springframework.data.mapping.PersistentPropertyAccessor;
 import org.springframework.data.mapping.callback.EntityCallbacks;
 import org.springframework.data.mapping.callback.ReactiveEntityCallbacks;
-import org.springframework.data.mapping.context.MappingContext;
-import org.springframework.data.mapping.model.ConvertingPropertyAccessor;
 import org.springframework.util.Assert;
 
 /**
@@ -49,23 +40,16 @@ import org.springframework.util.Assert;
  * @author Carlos Espinaco
  * @since 4.2
  */
-class ReactiveCouchbaseTemplateSupport implements ApplicationContextAware, ReactiveTemplateSupport {
-
-	private static final Logger LOG = LoggerFactory.getLogger(ReactiveCouchbaseTemplateSupport.class);
+class ReactiveCouchbaseTemplateSupport extends AbstractTemplateSupport
+		implements ApplicationContextAware, ReactiveTemplateSupport {
 
 	private final ReactiveCouchbaseTemplate template;
-	private final CouchbaseConverter converter;
-	private final MappingContext<? extends CouchbasePersistentEntity<?>, CouchbasePersistentProperty> mappingContext;
-	private final TranslationService translationService;
 	private ReactiveEntityCallbacks reactiveEntityCallbacks;
-	private ApplicationContext applicationContext;
 
 	public ReactiveCouchbaseTemplateSupport(final ReactiveCouchbaseTemplate template, final CouchbaseConverter converter,
 											final TranslationService translationService) {
+		super(template, converter, translationService);
 		this.template = template;
-		this.converter = converter;
-		this.mappingContext = converter.getMappingContext();
-		this.translationService = translationService;
 	}
 
 	@Override
@@ -80,89 +64,38 @@ class ReactiveCouchbaseTemplateSupport implements ApplicationContextAware, React
 	}
 
 	@Override
-	public <T> Mono<T> decodeEntity(String id, String source, long cas, Class<T> entityClass) {
-		return Mono.fromSupplier(() -> {
-			final CouchbaseDocument converted = new CouchbaseDocument(id);
-			converted.setId(id);
-			CouchbasePersistentEntity<?> persistentEntity = mappingContext.getRequiredPersistentEntity(entityClass);
-			if (cas != 0 && persistentEntity.getVersionProperty() != null) {
-				converted.put(persistentEntity.getVersionProperty().getName(), cas);
-			}
-
-			T readEntity = converter.read(entityClass, (CouchbaseDocument) translationService.decode(source, converted));
-			final ConvertingPropertyAccessor<T> accessor = getPropertyAccessor(readEntity);
-
-			if (persistentEntity.getVersionProperty() != null) {
-				accessor.setProperty(persistentEntity.getVersionProperty(), cas);
-			}
-			N1qlJoinResolver.handleProperties(persistentEntity, accessor, template, id);
-			return accessor.getBean();
-		});
+	ReactiveCouchbaseTemplate getReactiveTemplate() {
+		return template;
 	}
 
 	@Override
-	public Mono<Object> applyUpdatedCas(final Object entity, CouchbaseDocument converted, final long cas) {
-		return Mono.fromSupplier(() -> {
-			Object returnValue;
-			final ConvertingPropertyAccessor<Object> accessor = getPropertyAccessor(entity);
-			final CouchbasePersistentEntity<?> persistentEntity = mappingContext
-					.getRequiredPersistentEntity(entity.getClass());
-			final CouchbasePersistentProperty versionProperty = persistentEntity.getVersionProperty();
-
-			if (versionProperty != null) {
-				accessor.setProperty(versionProperty, cas);
-				returnValue = accessor.getBean();
-			} else {
-				returnValue = entity;
-			}
-			maybeEmitEvent(new AfterSaveEvent(returnValue, converted));
-			return returnValue;
-		});
+	public <T> Mono<T> decodeEntity(String id, String source, long cas, Class<T> entityClass, String scope, String collection,
+									TransactionResultHolder txResultHolder) {
+		return decodeEntity(id, source, cas, entityClass, scope, collection, txResultHolder, null);
 	}
 
 	@Override
-	public Mono<Object> applyUpdatedId(final Object entity, Object id) {
-		return Mono.fromSupplier(() -> {
-			final ConvertingPropertyAccessor<Object> accessor = getPropertyAccessor(entity);
-			final CouchbasePersistentEntity<?> persistentEntity = mappingContext
-					.getRequiredPersistentEntity(entity.getClass());
-			final CouchbasePersistentProperty idProperty = persistentEntity.getIdProperty();
-
-			if (idProperty != null) {
-				accessor.setProperty(idProperty, id);
-				return accessor.getBean();
-			}
-			return entity;
-		});
+	public <T> Mono<T> decodeEntity(String id, String source, long cas, Class<T> entityClass, String scope, String collection,
+									TransactionResultHolder txResultHolder, ReactiveCouchbaseResourceHolder holder) {
+		return Mono.fromSupplier(() -> decodeEntityBase(id, source, cas, entityClass, scope, collection, txResultHolder, holder));
 	}
 
-	@Override
-	public Long getCas(final Object entity) {
-		final ConvertingPropertyAccessor<Object> accessor = getPropertyAccessor(entity);
-		final CouchbasePersistentEntity<?> persistentEntity = mappingContext.getRequiredPersistentEntity(entity.getClass());
-		final CouchbasePersistentProperty versionProperty = persistentEntity.getVersionProperty();
 
-		long cas = 0;
-		if (versionProperty != null) {
-			Object casObject = accessor.getProperty(versionProperty);
-			if (casObject instanceof Number) {
-				cas = ((Number) casObject).longValue();
-			}
-		}
-		return cas;
+	@Override
+	public <T> Mono<T> applyResult(T entity, CouchbaseDocument converted, Object id, Long cas,
+								   TransactionResultHolder txResultHolder) {
+		return applyResult(entity, converted, id, cas, txResultHolder, null);
 	}
 
 	@Override
-	public String getJavaNameForEntity(final Class<?> clazz) {
-		final CouchbasePersistentEntity<?> persistentEntity = mappingContext.getRequiredPersistentEntity(clazz);
-		MappingCouchbaseEntityInformation<?, Object> info = new MappingCouchbaseEntityInformation<>(persistentEntity);
-		return info.getJavaType().getName();
+	public <T> Mono<T> applyResult(T entity, CouchbaseDocument converted, Object id, Long cas,
+								   TransactionResultHolder txResultHolder, ReactiveCouchbaseResourceHolder holder) {
+		return Mono.fromSupplier(() -> applyResultBase(entity, converted, id, cas, txResultHolder, holder));
 	}
 
-	private <T> ConvertingPropertyAccessor<T> getPropertyAccessor(final T source) {
-		CouchbasePersistentEntity<?> entity = mappingContext.getRequiredPersistentEntity(source.getClass());
-		PersistentPropertyAccessor<T> accessor = entity.getPropertyAccessor(source);
-		return new ConvertingPropertyAccessor<>(accessor, converter.getConversionService());
+	@Override
+	public <T> Integer getTxResultHolder(T source) {
+		return null;
 	}
 
 	@Override
@@ -177,7 +110,7 @@ class ReactiveCouchbaseTemplateSupport implements ApplicationContextAware, React
 	 * Set the {@link ReactiveEntityCallbacks} instance to use when invoking
 	 * {@link org.springframework.data.mapping.callback.ReactiveEntityCallbacks callbacks} like the
 	 * {@link ReactiveBeforeConvertCallback}.
-	 * <p/>
+	 * <p>
 	 * Overrides potentially existing {@link EntityCallbacks}.
 	 *
 	 * @param reactiveEntityCallbacks must not be {@literal null}.
@@ -188,24 +121,6 @@ class ReactiveCouchbaseTemplateSupport implements ApplicationContextAware, React
 		this.reactiveEntityCallbacks = reactiveEntityCallbacks;
 	}
 
-	public void maybeEmitEvent(CouchbaseMappingEvent<?> event) {
-		if (canPublishEvent()) {
-			try {
-				this.applicationContext.publishEvent(event);
-			} catch (Exception e) {
-				LOG.warn("{} thrown during {}", e, event);
-				throw e;
-			}
-		} else {
-			LOG.info("maybeEmitEvent called, but ReactiveCouchbaseTemplate not initialized with applicationContext");
-		}
-
-	}
-
-	private boolean canPublishEvent() {
-		return this.applicationContext != null;
-	}
-
 	protected <T> Mono<T> maybeCallBeforeConvert(T object, String collection) {
 		if (reactiveEntityCallbacks != null) {
 			return reactiveEntityCallbacks.callback(ReactiveBeforeConvertCallback.class, object, collection);
diff --git a/src/main/java/org/springframework/data/couchbase/core/ReactiveExistsByIdOperationSupport.java b/src/main/java/org/springframework/data/couchbase/core/ReactiveExistsByIdOperationSupport.java
index 56b64282..77829993 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ReactiveExistsByIdOperationSupport.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ReactiveExistsByIdOperationSupport.java
@@ -71,11 +71,13 @@ public class ReactiveExistsByIdOperationSupport implements ReactiveExistsByIdOpe
 
 		@Override
 		public Mono<Boolean> one(final String id) {
-			PseudoArgs<ExistsOptions> pArgs = new PseudoArgs<>(template, scope, collection, options, domainType);
+			PseudoArgs<ExistsOptions> pArgs = new PseudoArgs<>(template, scope, collection, options, null, domainType);
 			LOG.trace("existsById {}", pArgs);
-			return Mono.just(id)
+
+			return TransactionalSupport.verifyNotInTransaction(template.doGetTemplate(), "existsById")
+					.then(Mono.just(id))
 					.flatMap(docId -> template.getCouchbaseClientFactory().withScope(pArgs.getScope())
-							.getCollection(pArgs.getCollection()).reactive().exists(id, buildOptions(pArgs.getOptions()))
+							.getBlockingCollection(pArgs.getCollection()).reactive().exists(id, buildOptions(pArgs.getOptions()))
 							.map(ExistsResult::exists))
 					.onErrorMap(throwable -> {
 						if (throwable instanceof RuntimeException) {
@@ -102,7 +104,7 @@ public class ReactiveExistsByIdOperationSupport implements ReactiveExistsByIdOpe
 		}
 
 		@Override
-		public TerminatingExistsById withOptions(final ExistsOptions options) {
+		public ExistsByIdInScope withOptions(final ExistsOptions options) {
 			Assert.notNull(options, "Options must not be null.");
 			return new ReactiveExistsByIdSupport(template, domainType, scope, collection, options);
 		}
diff --git a/src/main/java/org/springframework/data/couchbase/core/ReactiveFindByAnalyticsOperation.java b/src/main/java/org/springframework/data/couchbase/core/ReactiveFindByAnalyticsOperation.java
index 1d661b30..2d9f1251 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ReactiveFindByAnalyticsOperation.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ReactiveFindByAnalyticsOperation.java
@@ -88,24 +88,12 @@ public interface ReactiveFindByAnalyticsOperation {
 
 	}
 
-	interface FindByAnalyticsWithQuery<T> extends TerminatingFindByAnalytics<T>, WithAnalyticsQuery<T> {
-
-		/**
-		 * Set the filter for the analytics query to be used.
-		 *
-		 * @param query must not be {@literal null}.
-		 * @throws IllegalArgumentException if query is {@literal null}.
-		 */
-		TerminatingFindByAnalytics<T> matching(AnalyticsQuery query);
-
-	}
-
 	/**
 	 * Fluent method to specify options.
 	 *
 	 * @param <T> the entity type to use.
 	 */
-	interface FindByAnalyticsWithOptions<T> extends FindByAnalyticsWithQuery<T>, WithAnalyticsOptions<T> {
+	interface FindByAnalyticsWithOptions<T> extends TerminatingFindByAnalytics<T>, WithAnalyticsOptions<T> {
 		/**
 		 * Fluent method to specify options to use for execution
 		 *
@@ -115,65 +103,47 @@ public interface ReactiveFindByAnalyticsOperation {
 		TerminatingFindByAnalytics<T> withOptions(AnalyticsOptions options);
 	}
 
-	/**
-	 * Fluent method to specify the collection.
-	 *
-	 * @param <T> the entity type to use for the results.
-	 */
-	interface FindByAnalyticsInCollection<T> extends FindByAnalyticsWithOptions<T>, InCollection<T> {
-		/**
-		 * With a different collection
-		 *
-		 * @param collection the collection to use.
-		 */
-		@Override
-		FindByAnalyticsWithOptions<T> inCollection(String collection);
-	}
+	@Deprecated
+	interface FindByAnalyticsConsistentWith<T> extends FindByAnalyticsWithOptions<T> {
 
 		/**
-	 * Fluent method to specify the scope.
-	 *
-	 * @param <T> the entity type to use for the results.
-	 */
-	interface FindByAnalyticsInScope<T> extends FindByAnalyticsInCollection<T>, InScope<T> {
-		/**
-		 * With a different scope
+		 * Allows to override the default scan consistency.
 		 *
-		 * @param scope the scope to use.
+		 * @param scanConsistency the custom scan consistency to use for this analytics query.
 		 */
-		@Override
-		FindByAnalyticsInCollection<T> inScope(String scope);
+		@Deprecated
+		FindByAnalyticsWithOptions<T> consistentWith(AnalyticsScanConsistency scanConsistency);
+
 	}
 
-	@Deprecated
-	interface FindByAnalyticsConsistentWith<T> extends FindByAnalyticsInScope<T> {
+	interface FindByAnalyticsWithConsistency<T> extends FindByAnalyticsConsistentWith<T>, WithAnalyticsConsistency<T> {
 
 		/**
 		 * Allows to override the default scan consistency.
 		 *
 		 * @param scanConsistency the custom scan consistency to use for this analytics query.
 		 */
-		@Deprecated
-		FindByAnalyticsWithQuery<T> consistentWith(AnalyticsScanConsistency scanConsistency);
+		@Override
+		FindByAnalyticsConsistentWith<T> withConsistency(AnalyticsScanConsistency scanConsistency);
 
 	}
 
-	interface FindByAnalyticsWithConsistency<T> extends FindByAnalyticsInScope<T>, WithAnalyticsConsistency<T> {
+	interface FindByAnalyticsWithQuery<T> extends FindByAnalyticsWithConsistency<T>, WithAnalyticsQuery<T> {
 
 		/**
-		 * Allows to override the default scan consistency.
+		 * Set the filter for the analytics query to be used.
 		 *
-		 * @param scanConsistency the custom scan consistency to use for this analytics query.
+		 * @param query must not be {@literal null}.
+		 * @throws IllegalArgumentException if query is {@literal null}.
 		 */
-		@Override
-		FindByAnalyticsWithQuery<T> withConsistency(AnalyticsScanConsistency scanConsistency);
+		FindByAnalyticsWithConsistency<T> matching(AnalyticsQuery query);
 
 	}
 
 	/**
 	 * Result type override (Optional).
 	 */
-	interface FindByAnalyticsWithProjection<T> extends FindByAnalyticsWithConsistency<T> {
+	interface FindByAnalyticsWithProjection<T> extends FindByAnalyticsWithQuery<T> {
 
 		/**
 		 * Define the target type fields should be mapped to. <br />
@@ -183,9 +153,39 @@ public interface ReactiveFindByAnalyticsOperation {
 		 * @return new instance of {@link FindByAnalyticsWithConsistency}.
 		 * @throws IllegalArgumentException if returnType is {@literal null}.
 		 */
-		<R> FindByAnalyticsWithConsistency<R> as(Class<R> returnType);
+		<R> FindByAnalyticsWithQuery<R> as(Class<R> returnType);
+	}
+
+	/**
+	 * Fluent method to specify the collection.
+	 *
+	 * @param <T> the entity type to use for the results.
+	 */
+	interface FindByAnalyticsInCollection<T> extends FindByAnalyticsWithProjection<T>, InCollection<T> {
+		/**
+		 * With a different collection
+		 *
+		 * @param collection the collection to use.
+		 */
+		@Override
+		FindByAnalyticsWithProjection<T> inCollection(String collection);
+	}
+
+	/**
+	 * Fluent method to specify the scope.
+	 *
+	 * @param <T> the entity type to use for the results.
+	 */
+	interface FindByAnalyticsInScope<T> extends FindByAnalyticsInCollection<T>, InScope<T> {
+		/**
+		 * With a different scope
+		 *
+		 * @param scope the scope to use.
+		 */
+		@Override
+		FindByAnalyticsInCollection<T> inScope(String scope);
 	}
 
-	interface ReactiveFindByAnalytics<T> extends FindByAnalyticsWithProjection<T>, FindByAnalyticsConsistentWith<T> {}
+	interface ReactiveFindByAnalytics<T> extends FindByAnalyticsInScope<T> {}
 
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/ReactiveFindByAnalyticsOperationSupport.java b/src/main/java/org/springframework/data/couchbase/core/ReactiveFindByAnalyticsOperationSupport.java
index 53cce70d..ea47bc77 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ReactiveFindByAnalyticsOperationSupport.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ReactiveFindByAnalyticsOperationSupport.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -70,7 +70,7 @@ public class ReactiveFindByAnalyticsOperationSupport implements ReactiveFindByAn
 		}
 
 		@Override
-		public TerminatingFindByAnalytics<T> matching(AnalyticsQuery query) {
+		public FindByAnalyticsWithConsistency<T> matching(AnalyticsQuery query) {
 			return new ReactiveFindByAnalyticsSupport<>(template, domainType, returnType, query, scanConsistency, scope,
 					collection, options, support);
 		}
@@ -89,7 +89,7 @@ public class ReactiveFindByAnalyticsOperationSupport implements ReactiveFindByAn
 		}
 
 		@Override
-		public <R> FindByAnalyticsWithConsistency<R> as(final Class<R> returnType) {
+		public <R> FindByAnalyticsWithQuery<R> as(final Class<R> returnType) {
 			Assert.notNull(returnType, "returnType must not be null!");
 			return new ReactiveFindByAnalyticsSupport<>(template, domainType, returnType, query, scanConsistency, scope,
 					collection, options, support);
@@ -109,8 +109,9 @@ public class ReactiveFindByAnalyticsOperationSupport implements ReactiveFindByAn
 		public Flux<T> all() {
 			return Flux.defer(() -> {
 				String statement = assembleEntityQuery(false);
-				return template.getCouchbaseClientFactory().getCluster().reactive()
-						.analyticsQuery(statement, buildAnalyticsOptions()).onErrorMap(throwable -> {
+				return TransactionalSupport.verifyNotInTransaction(template.doGetTemplate(), "findByAnalytics")
+						.then(template.getCouchbaseClientFactory().getCluster().block().reactive()
+						.analyticsQuery(statement, buildAnalyticsOptions())).onErrorMap(throwable -> {
 							if (throwable instanceof RuntimeException) {
 								return template.potentiallyConvertRuntimeException((RuntimeException) throwable);
 							} else {
@@ -133,7 +134,7 @@ public class ReactiveFindByAnalyticsOperationSupport implements ReactiveFindByAn
 							cas = row.getLong(TemplateUtils.SELECT_CAS);
 							row.removeKey(TemplateUtils.SELECT_ID);
 							row.removeKey(TemplateUtils.SELECT_CAS);
-							return support.decodeEntity(id, row.toString(), cas, returnType);
+							return support.decodeEntity(id, row.toString(), cas, returnType, null, null, null);
 						});
 			});
 		}
@@ -142,14 +143,15 @@ public class ReactiveFindByAnalyticsOperationSupport implements ReactiveFindByAn
 		public Mono<Long> count() {
 			return Mono.defer(() -> {
 				String statement = assembleEntityQuery(true);
-				return template.getCouchbaseClientFactory().getCluster().reactive()
+				return template.getCouchbaseClientFactory().getBlockingCluster().reactive()
 						.analyticsQuery(statement, buildAnalyticsOptions()).onErrorMap(throwable -> {
 							if (throwable instanceof RuntimeException) {
 								return template.potentiallyConvertRuntimeException((RuntimeException) throwable);
 							} else {
 								return throwable;
 							}
-						}).flatMapMany(ReactiveAnalyticsResult::rowsAsObject).map(row -> row.getLong("__count")).next();
+						}).flatMapMany(ReactiveAnalyticsResult::rowsAsObject)
+						.map(row -> row.getLong(row.getNames().iterator().next())).next();
 			});
 		}
 
@@ -172,7 +174,7 @@ public class ReactiveFindByAnalyticsOperationSupport implements ReactiveFindByAn
 		}
 
 		@Override
-		public FindByAnalyticsWithConsistency<T> inCollection(final String collection) {
+		public FindByAnalyticsWithProjection<T> inCollection(final String collection) {
 			return new ReactiveFindByAnalyticsSupport<>(template, domainType, returnType, query, scanConsistency, scope,
 					collection, options, support);
 		}
diff --git a/src/main/java/org/springframework/data/couchbase/core/ReactiveFindByIdOperation.java b/src/main/java/org/springframework/data/couchbase/core/ReactiveFindByIdOperation.java
index 5e9983b0..4e54be96 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ReactiveFindByIdOperation.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ReactiveFindByIdOperation.java
@@ -15,6 +15,7 @@
  */
 package org.springframework.data.couchbase.core;
 
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 
@@ -27,11 +28,12 @@ import org.springframework.data.couchbase.core.support.OneAndAllIdReactive;
 import org.springframework.data.couchbase.core.support.WithExpiry;
 import org.springframework.data.couchbase.core.support.WithGetOptions;
 import org.springframework.data.couchbase.core.support.WithProjectionId;
+import org.springframework.data.couchbase.core.support.WithTransaction;
 
 import com.couchbase.client.java.kv.GetOptions;
 
 /**
- * Get Operations
+ * Get Operations - method/interface chaining is from the bottom up.
  *
  * @author Christoph Strobl
  * @since 2.0
@@ -67,7 +69,21 @@ public interface ReactiveFindByIdOperation {
 		 * @return the list of found entities.
 		 */
 		Flux<? extends T> all(Collection<String> ids);
+	}
 
+	/**
+	 * Provide transaction
+	 *
+	 * @param <T> the entity type to use for the results
+	 */
+	interface FindByIdWithTransaction<T> extends TerminatingFindById<T>, WithTransaction<T> {
+		/**
+		 * Provide transaction
+		 *
+		 * @param txCtx
+		 * @return
+		 */
+		TerminatingFindById<T> transaction(CouchbaseTransactionalOperator txCtx);
 	}
 
 	/**
@@ -85,62 +101,67 @@ public interface ReactiveFindByIdOperation {
 		TerminatingFindById<T> withOptions(GetOptions options);
 	}
 
+	interface FindByIdWithProjection<T> extends FindByIdWithOptions<T>, WithProjectionId<T> {
 		/**
-	 * Fluent method to specify the collection.
+		 * Load only certain fields for the document.
 		 *
-	 * @param <T> the entity type to use for the results.
+		 * @param fields the projected fields to load.
 		 */
-	interface FindByIdInCollection<T> extends FindByIdWithOptions<T>, InCollection<T> {
+		FindByIdWithOptions<T> project(String... fields);
+	}
+
+	interface FindByIdWithExpiry<T> extends FindByIdWithProjection<T>, WithExpiry<T> {
 		/**
-		 * With a different collection
+		 * Load only certain fields for the document.
 		 *
-		 * @param collection the collection to use.
+		 * @param expiry the projected fields to load.
 		 */
 		@Override
-		FindByIdWithOptions<T> inCollection(String collection);
+		FindByIdWithProjection<T> withExpiry(Duration expiry);
 	}
 
 	/**
-	 * Fluent method to specify the scope.
+	 * Interface to that can produce either transactional or non-transactional operations.
 	 *
 	 * @param <T> the entity type to use for the results.
 	 */
-	interface FindByIdInScope<T> extends FindByIdInCollection<T>, InScope<T> {
+	interface FindByIdTxOrNot<T> extends FindByIdWithTransaction<T>, FindByIdWithExpiry<T> {}
+
 	/**
-		 * With a different scope
+	 * Fluent method to specify the collection.
 	 *
-		 * @param scope the scope to use.
+	 * @param <T> the entity type to use for the results.
+	 */
+	interface FindByIdInCollection<T> extends FindByIdTxOrNot<T>, InCollection<T> {
+		/**
+		 * With a different collection
+		 *
+		 * @param collection the collection to use.
 		 */
 		@Override
-		FindByIdInCollection<T> inScope(String scope);
+		FindByIdTxOrNot<T> inCollection(String collection);
 	}
 
-	interface FindByIdWithProjection<T> extends FindByIdInScope<T>, WithProjectionId<T> {
-
 	/**
-		 * Load only certain fields for the document.
+	 * Fluent method to specify the scope.
 	 *
-		 * @param fields the projected fields to load.
+	 * @param <T> the entity type to use for the results.
 	 */
-		FindByIdInCollection<T> project(String... fields);
-
-	}
-
-	interface FindByIdWithExpiry<T> extends FindByIdWithProjection<T>, WithExpiry<T> {
+	interface FindByIdInScope<T> extends FindByIdInCollection<T>, InScope<T> {
 		/**
-		 * Load only certain fields for the document.
+		 * With a different scope
 		 *
-		 * @param expiry the projected fields to load.
+		 * @param scope the scope to use.
 		 */
 		@Override
-		FindByIdWithProjection<T> withExpiry(Duration expiry);
+		FindByIdInCollection<T> inScope(String scope);
 	}
 
 	/**
 	 * Provides methods for constructing query operations in a fluent way.
 	 *
-	 * @param <T> the entity type to use for the results
+	 * @param <T> the entity type.
 	 */
-	interface ReactiveFindById<T> extends FindByIdWithExpiry<T> {}
+	interface ReactiveFindById<T> extends FindByIdInScope<T> {};
 
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/ReactiveFindByIdOperationSupport.java b/src/main/java/org/springframework/data/couchbase/core/ReactiveFindByIdOperationSupport.java
index c23737ef..475b719c 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ReactiveFindByIdOperationSupport.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ReactiveFindByIdOperationSupport.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,10 +16,16 @@
 package org.springframework.data.couchbase.core;
 
 import static com.couchbase.client.java.kv.GetAndTouchOptions.getAndTouchOptions;
+import static com.couchbase.client.java.transactions.internal.ConverterUtil.makeCollectionIdentifier;
 
+import com.couchbase.client.core.transaction.CoreTransactionGetResult;
+import com.couchbase.client.java.transactions.TransactionGetResult;
+import org.springframework.data.couchbase.repository.support.TransactionResultHolder;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 
+import java.lang.reflect.Method;
+import java.nio.charset.StandardCharsets;
 import java.time.Duration;
 import java.util.Arrays;
 import java.util.Collection;
@@ -29,6 +35,7 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.springframework.data.couchbase.core.mapping.CouchbasePersistentEntity;
 import org.springframework.data.couchbase.core.support.PseudoArgs;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 import org.springframework.util.Assert;
 
 import com.couchbase.client.core.error.DocumentNotFoundException;
@@ -49,7 +56,7 @@ public class ReactiveFindByIdOperationSupport implements ReactiveFindByIdOperati
 
 	@Override
 	public <T> ReactiveFindById<T> findById(Class<T> domainType) {
-		return new ReactiveFindByIdSupport<>(template, domainType, null, null, null, null, null, template.support());
+		return new ReactiveFindByIdSupport<>(template, domainType, null, null, null, null, null, null, template.support());
 	}
 
 	static class ReactiveFindByIdSupport<T> implements ReactiveFindById<T> {
@@ -60,11 +67,13 @@ public class ReactiveFindByIdOperationSupport implements ReactiveFindByIdOperati
 		private final String collection;
 		private final CommonOptions<?> options;
 		private final List<String> fields;
+		private final CouchbaseTransactionalOperator txCtx;
 		private final ReactiveTemplateSupport support;
 		private final Duration expiry;
 
 		ReactiveFindByIdSupport(ReactiveCouchbaseTemplate template, Class<T> domainType, String scope, String collection,
-				CommonOptions<?> options, List<String> fields, Duration expiry, ReactiveTemplateSupport support) {
+								CommonOptions<?> options, List<String> fields, Duration expiry, CouchbaseTransactionalOperator txCtx,
+								ReactiveTemplateSupport support) {
 			this.template = template;
 			this.domainType = domainType;
 			this.scope = scope;
@@ -72,6 +81,7 @@ public class ReactiveFindByIdOperationSupport implements ReactiveFindByIdOperati
 			this.options = options;
 			this.fields = fields;
 			this.expiry = expiry;
+			this.txCtx = txCtx;
 			this.support = support;
 		}
 
@@ -79,24 +89,42 @@ public class ReactiveFindByIdOperationSupport implements ReactiveFindByIdOperati
 		public Mono<T> one(final String id) {
 
 			CommonOptions<?> gOptions = initGetOptions();
-			PseudoArgs<?> pArgs = new PseudoArgs(template, scope, collection, gOptions, domainType);
+			PseudoArgs<?> pArgs = new PseudoArgs(template, scope, collection, gOptions, txCtx, domainType);
 			LOG.trace("findById {}", pArgs);
 
-			return Mono.just(id).flatMap(docId -> {
-				ReactiveCollection reactive = template.getCouchbaseClientFactory().withScope(pArgs.getScope())
-						.getCollection(pArgs.getCollection()).reactive();
+			ReactiveCollection rc = template.getCouchbaseClientFactory().withScope(pArgs.getScope())
+					.getBlockingCollection(pArgs.getCollection()).reactive();
+
+			// this will get me a template with a session holding tx
+			Mono<ReactiveCouchbaseTemplate> tmpl = template.doGetTemplate();
+
+			Mono<T> reactiveEntity = tmpl.flatMap(tp -> tp.getCouchbaseClientFactory().getTransactionResources(null)
+					.flatMap(s -> {
+						System.err.println("Session: "+s);
+						//Mono<T> reactiveEntity =  Mono.defer(() -> {
+						if (s == null || s.getCore() == null) {
 							if (pArgs.getOptions() instanceof GetAndTouchOptions) {
-					return reactive.getAndTouch(docId, expiryToUse(), (GetAndTouchOptions) pArgs.getOptions());
+								return rc.getAndTouch(id, expiryToUse(), (GetAndTouchOptions) pArgs.getOptions())
+										.flatMap(result -> support.decodeEntity(id, result.contentAs(String.class), result.cas(), domainType,
+												pArgs.getScope(), pArgs.getCollection(), null));
 							} else {
-					return reactive.get(docId, (GetOptions) pArgs.getOptions());
+								return rc.get(id, (GetOptions) pArgs.getOptions())
+										.flatMap(result -> support.decodeEntity(id, result.contentAs(String.class), result.cas(), domainType,
+												pArgs.getScope(), pArgs.getCollection(), null));
 							}
-			}).flatMap(result -> support.decodeEntity(id, result.contentAs(String.class), result.cas(), domainType))
-					.onErrorResume(throwable -> {
-						if (throwable instanceof RuntimeException) {
+						} else {
+							return  s.getCore().get(makeCollectionIdentifier(rc.async()), id)
+									.flatMap( result -> {
+										return support.decodeEntity(id, new String(result.contentAsBytes(), StandardCharsets.UTF_8), result.cas(), domainType, pArgs.getScope(),
+												pArgs.getCollection(), new TransactionResultHolder(result), null);
+									});
+						}
+					}));
+
+			return reactiveEntity.onErrorResume(throwable -> {
 				if (throwable instanceof DocumentNotFoundException) {
 					return Mono.empty();
 				}
-						}
 				return Mono.error(throwable);
 			}).onErrorMap(throwable -> {
 				if (throwable instanceof RuntimeException) {
@@ -105,6 +133,7 @@ public class ReactiveFindByIdOperationSupport implements ReactiveFindByIdOperati
 					return throwable;
 				}
 			});
+
 		}
 
 		@Override
@@ -113,31 +142,42 @@ public class ReactiveFindByIdOperationSupport implements ReactiveFindByIdOperati
 		}
 
 		@Override
-		public TerminatingFindById<T> withOptions(final GetOptions options) {
+		public FindByIdInScope<T> withOptions(final GetOptions options) {
 			Assert.notNull(options, "Options must not be null.");
-			return new ReactiveFindByIdSupport<>(template, domainType, scope, collection, options, fields, expiry, support);
+			return new ReactiveFindByIdSupport<>(template, domainType, scope, collection, options, fields, expiry, txCtx,
+					support);
 		}
 
 		@Override
-		public FindByIdWithOptions<T> inCollection(final String collection) {
-			return new ReactiveFindByIdSupport<>(template, domainType, scope, collection, options, fields, expiry, support);
+		public FindByIdInCollection<T> inCollection(final String collection) {
+			return new ReactiveFindByIdSupport<>(template, domainType, scope, collection, options, fields, expiry, txCtx,
+					support);
 		}
 
 		@Override
 		public FindByIdInCollection<T> inScope(final String scope) {
-			return new ReactiveFindByIdSupport<>(template, domainType, scope, collection, options, fields, expiry, support);
+			return new ReactiveFindByIdSupport<>(template, domainType, scope, collection, options, fields, expiry, txCtx,
+					support);
 		}
 
 		@Override
-		public FindByIdInScope<T> project(String... fields) {
+		public FindByIdWithOptions<T> project(String... fields) {
 			Assert.notNull(fields, "Fields must not be null");
 			return new ReactiveFindByIdSupport<>(template, domainType, scope, collection, options, Arrays.asList(fields),
-					expiry, support);
+					expiry, txCtx, support);
 		}
 
 		@Override
 		public FindByIdWithProjection<T> withExpiry(final Duration expiry) {
-			return new ReactiveFindByIdSupport<>(template, domainType, scope, collection, options, fields, expiry, support);
+			return new ReactiveFindByIdSupport<>(template, domainType, scope, collection, options, fields, expiry, txCtx,
+					support);
+		}
+
+		@Override
+		public FindByIdWithProjection<T> transaction(CouchbaseTransactionalOperator txCtx) {
+			Assert.notNull(txCtx, "txCtx must not be null");
+			return new ReactiveFindByIdSupport<>(template, domainType, scope, collection, options, fields, expiry, txCtx,
+					support);
 		}
 
 		private CommonOptions<?> initGetOptions() {
@@ -172,6 +212,7 @@ public class ReactiveFindByIdOperationSupport implements ReactiveFindByIdOperati
 			}
 			return expiryToUse;
 		}
+
 	}
 
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/ReactiveFindByQueryOperation.java b/src/main/java/org/springframework/data/couchbase/core/ReactiveFindByQueryOperation.java
index 9a839ed7..89df6ae9 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ReactiveFindByQueryOperation.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ReactiveFindByQueryOperation.java
@@ -15,6 +15,7 @@
  */
 package org.springframework.data.couchbase.core;
 
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 
@@ -28,6 +29,7 @@ import org.springframework.data.couchbase.core.support.WithConsistency;
 import org.springframework.data.couchbase.core.support.WithDistinct;
 import org.springframework.data.couchbase.core.support.WithQuery;
 import org.springframework.data.couchbase.core.support.WithQueryOptions;
+import org.springframework.data.couchbase.core.support.WithTransaction;
 
 import com.couchbase.client.java.query.QueryOptions;
 import com.couchbase.client.java.query.QueryScanConsistency;
@@ -92,94 +94,99 @@ public interface ReactiveFindByQueryOperation {
 	}
 
 	/**
-	 * Fluent methods to filter by query
+	 * Fluent method to specify options.
 	 *
 	 * @param <T> the entity type to use for the results.
 	 */
-	interface FindByQueryWithQuery<T> extends TerminatingFindByQuery<T>, WithQuery<T> {
+	interface FindByQueryWithOptions<T> extends TerminatingFindByQuery<T>, WithQueryOptions<T> {
+		/**
+		 * @param options options to use for execution
+		 */
+		TerminatingFindByQuery<T> withOptions(QueryOptions options);
+	}
 
 	/**
-		 * Set the filter {@link Query} to be used.
+	 * To be removed at the next major release. use WithConsistency instead
 	 *
-		 * @param query must not be {@literal null}.
-		 * @throws IllegalArgumentException if query is {@literal null}.
+	 * @param <T> the entity type to use for the results.
 	 */
-		TerminatingFindByQuery<T> matching(Query query);
+	@Deprecated
+	interface FindByQueryConsistentWith<T> extends FindByQueryWithOptions<T> {
 
 		/**
-		 * Set the filter {@link QueryCriteriaDefinition criteria} to be used.
+		 * Allows to override the default scan consistency.
 		 *
-		 * @param criteria must not be {@literal null}.
-		 * @return new instance of {@link TerminatingFindByQuery}.
-		 * @throws IllegalArgumentException if criteria is {@literal null}.
+		 * @param scanConsistency the custom scan consistency to use for this query.
 		 */
-		default TerminatingFindByQuery<T> matching(QueryCriteriaDefinition criteria) {
-			return matching(Query.query(criteria));
-		}
-
+		@Deprecated
+		FindByQueryWithOptions<T> consistentWith(QueryScanConsistency scanConsistency);
 	}
 
 	/**
-	 * Fluent method to specify options.
+	 * Fluent method to specify scan consistency. Scan consistency may also come from an annotation.
 	 *
 	 * @param <T> the entity type to use for the results.
 	 */
-	interface FindByQueryWithOptions<T> extends FindByQueryWithQuery<T>, WithQueryOptions<T> {
+	interface FindByQueryWithConsistency<T> extends FindByQueryConsistentWith<T>, WithConsistency<T> {
+
 		/**
-		 * @param options options to use for execution
+		 * Allows to override the default scan consistency.
+		 *
+		 * @param scanConsistency the custom scan consistency to use for this query.
 		 */
-		TerminatingFindByQuery<T> withOptions(QueryOptions options);
+		FindByQueryConsistentWith<T> withConsistency(QueryScanConsistency scanConsistency);
+
 	}
 
 	/**
-	 * Fluent method to specify the collection
+	 * Fluent method to add transactions
 	 *
 	 * @param <T> the entity type to use for the results.
 	 */
-	interface FindByQueryInCollection<T> extends FindByQueryWithOptions<T>, InCollection<T> {
-		FindByQueryWithOptions<T> inCollection(String collection);
-	}
+	interface FindByQueryWithTransaction<T> extends TerminatingFindByQuery<T>, WithTransaction<T> {
 
 		/**
-	 * Fluent method to specify the scope
+		 * Finds the distinct values for a specified {@literal field} across a single {@link } or view.
 		 *
-	 * @param <T> the entity type to use for the results.
+		 * @param txCtx Must not be {@literal null}.
+		 * @return new instance of {@link ReactiveFindByQuery}.
+		 * @throws IllegalArgumentException if field is {@literal null}.
 		 */
-	interface FindByQueryInScope<T> extends FindByQueryInCollection<T>, InScope<T> {
-		FindByQueryInCollection<T> inScope(String scope);
+		TerminatingFindByQuery<T> transaction(CouchbaseTransactionalOperator txCtx);
 	}
 
 	/**
-	 * To be removed at the next major release. use WithConsistency instead
+	 * Fluent interface for operations with or without a transaction.
 	 *
 	 * @param <T> the entity type to use for the results.
 	 */
-	@Deprecated
-	interface FindByQueryConsistentWith<T> extends FindByQueryInScope<T> {
+	interface FindByQueryTxOrNot<T> extends FindByQueryWithConsistency<T>, FindByQueryWithTransaction<T> {}
 
 	/**
-		 * Allows to override the default scan consistency.
+	 * Fluent methods to filter by query
 	 *
-		 * @param scanConsistency the custom scan consistency to use for this query.
+	 * @param <T> the entity type to use for the results.
 	 */
-		@Deprecated
-		FindByQueryInScope<T> consistentWith(QueryScanConsistency scanConsistency);
-
-	}
+	interface FindByQueryWithQuery<T> extends FindByQueryTxOrNot<T>, WithQuery<T> {
 
 		/**
-	 * Fluent method to specify scan consistency. Scan consistency may also come from an annotation.
+		 * Set the filter {@link Query} to be used.
 		 *
-	 * @param <T> the entity type to use for the results.
+		 * @param query must not be {@literal null}.
+		 * @throws IllegalArgumentException if query is {@literal null}.
 		 */
-	interface FindByQueryWithConsistency<T> extends FindByQueryConsistentWith<T>, WithConsistency<T> {
+		FindByQueryTxOrNot<T> matching(Query query);
 
 		/**
-		 * Allows to override the default scan consistency.
+		 * Set the filter {@link QueryCriteriaDefinition criteria} to be used.
 		 *
-		 * @param scanConsistency the custom scan consistency to use for this query.
+		 * @param criteria must not be {@literal null}.
+		 * @return new instance of {@link TerminatingFindByQuery}.
+		 * @throws IllegalArgumentException if criteria is {@literal null}.
 		 */
-		FindByQueryConsistentWith<T> withConsistency(QueryScanConsistency scanConsistency);
+		default FindByQueryTxOrNot<T> matching(QueryCriteriaDefinition criteria) {
+			return matching(Query.query(criteria));
+		}
 
 	}
 
@@ -188,7 +195,7 @@ public interface ReactiveFindByQueryOperation {
 	 *
 	 * @param <T> the entity type to use for the results.
 	 */
-	interface FindByQueryWithProjection<T> extends FindByQueryWithConsistency<T> {
+	interface FindByQueryWithProjection<T> extends FindByQueryWithQuery<T> {
 
 		/**
 		 * Define the target type fields should be mapped to. <br />
@@ -198,7 +205,7 @@ public interface ReactiveFindByQueryOperation {
 		 * @return new instance of {@link FindByQueryWithProjection}.
 		 * @throws IllegalArgumentException if returnType is {@literal null}.
 		 */
-		<R> FindByQueryWithConsistency<R> as(Class<R> returnType);
+		<R> FindByQueryWithQuery<R> as(Class<R> returnType);
 	}
 
 	/**
@@ -233,7 +240,25 @@ public interface ReactiveFindByQueryOperation {
 		 * @return new instance of {@link ReactiveFindByQuery}.
 		 * @throws IllegalArgumentException if field is {@literal null}.
 		 */
-		FindByQueryWithProjection<T> distinct(String[] distinctFields);
+		FindByQueryWithProjecting<T> distinct(String[] distinctFields);
+	}
+
+	/**
+	 * Fluent method to specify the collection
+	 *
+	 * @param <T> the entity type to use for the results.
+	 */
+	interface FindByQueryInCollection<T> extends FindByQueryWithDistinct<T>, InCollection<T> {
+		FindByQueryWithDistinct<T> inCollection(String collection);
+	}
+
+	/**
+	 * Fluent method to specify the scope
+	 *
+	 * @param <T> the entity type to use for the results.
+	 */
+	interface FindByQueryInScope<T> extends FindByQueryInCollection<T>, InScope<T> {
+		FindByQueryInCollection<T> inScope(String scope);
 	}
 
 	/**
@@ -241,6 +266,6 @@ public interface ReactiveFindByQueryOperation {
 	 *
 	 * @param <T> the entity type to use for the results
 	 */
-	interface ReactiveFindByQuery<T> extends FindByQueryWithDistinct<T> {}
+	interface ReactiveFindByQuery<T> extends FindByQueryInScope<T> {}
 
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/ReactiveFindByQueryOperationSupport.java b/src/main/java/org/springframework/data/couchbase/core/ReactiveFindByQueryOperationSupport.java
index d5dd83cc..8e0ccf31 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ReactiveFindByQueryOperationSupport.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ReactiveFindByQueryOperationSupport.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,20 +15,27 @@
  */
 package org.springframework.data.couchbase.core;
 
+import com.couchbase.client.java.transactions.AttemptContextReactiveAccessor;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
+import org.springframework.data.couchbase.ReactiveCouchbaseClientFactory;
+import org.springframework.data.couchbase.core.query.OptionsBuilder;
 import org.springframework.data.couchbase.core.query.Query;
 import org.springframework.data.couchbase.core.support.PseudoArgs;
 import org.springframework.data.couchbase.core.support.TemplateUtils;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 import org.springframework.util.Assert;
 
 import com.couchbase.client.core.error.CouchbaseException;
+import com.couchbase.client.java.ReactiveScope;
 import com.couchbase.client.java.query.QueryOptions;
 import com.couchbase.client.java.query.QueryScanConsistency;
 import com.couchbase.client.java.query.ReactiveQueryResult;
+import com.couchbase.client.java.transactions.TransactionQueryOptions;
+import com.couchbase.client.java.transactions.TransactionQueryResult;
 
 /**
  * {@link ReactiveFindByQueryOperation} implementations for Couchbase.
@@ -50,7 +57,7 @@ public class ReactiveFindByQueryOperationSupport implements ReactiveFindByQueryO
 	@Override
 	public <T> ReactiveFindByQuery<T> findByQuery(final Class<T> domainType) {
 		return new ReactiveFindByQuerySupport<>(template, domainType, domainType, ALL_QUERY, null, null, null, null, null,
-				null, template.support());
+				null, null, template.support());
 	}
 
 	static class ReactiveFindByQuerySupport<T> implements ReactiveFindByQuery<T> {
@@ -65,12 +72,13 @@ public class ReactiveFindByQueryOperationSupport implements ReactiveFindByQueryO
 		private final String[] distinctFields;
 		private final String[] fields;
 		private final QueryOptions options;
+		private final CouchbaseTransactionalOperator txCtx;
 		private final ReactiveTemplateSupport support;
 
 		ReactiveFindByQuerySupport(final ReactiveCouchbaseTemplate template, final Class<?> domainType,
 								   final Class<T> returnType, final Query query, final QueryScanConsistency scanConsistency, final String scope,
-				final String collection, final QueryOptions options, final String[] distinctFields, final String[] fields,
-				final ReactiveTemplateSupport support) {
+								   final String collection, final QueryOptions options, final String[] distinctFields, String[] fields,
+								   final CouchbaseTransactionalOperator txCtx, final ReactiveTemplateSupport support) {
 			Assert.notNull(domainType, "domainType must not be null!");
 			Assert.notNull(returnType, "returnType must not be null!");
 			this.template = template;
@@ -84,6 +92,7 @@ public class ReactiveFindByQueryOperationSupport implements ReactiveFindByQueryO
 			this.distinctFields = distinctFields;
 			this.fields = fields;
 			this.support = support;
+			this.txCtx = txCtx;
 		}
 
 		@Override
@@ -96,45 +105,45 @@ public class ReactiveFindByQueryOperationSupport implements ReactiveFindByQueryO
 				scanCons = scanConsistency;
 			}
 			return new ReactiveFindByQuerySupport<>(template, domainType, returnType, query, scanCons, scope, collection,
-					options, distinctFields, fields, support);
+					options, distinctFields, fields, txCtx, support);
 		}
 
 		@Override
-		public TerminatingFindByQuery<T> withOptions(final QueryOptions options) {
+		public FindByQueryWithQuery<T> withOptions(final QueryOptions options) {
 			Assert.notNull(options, "Options must not be null.");
 			return new ReactiveFindByQuerySupport<>(template, domainType, returnType, query, scanConsistency, scope,
-					collection, options, distinctFields, fields, support);
+					collection, options, distinctFields, fields, txCtx, support);
 		}
 
 		@Override
 		public FindByQueryInCollection<T> inScope(final String scope) {
 			return new ReactiveFindByQuerySupport<>(template, domainType, returnType, query, scanConsistency, scope,
-					collection, options, distinctFields, fields, support);
+					collection, options, distinctFields, fields, txCtx, support);
 		}
 
 		@Override
-		public FindByQueryWithConsistency<T> inCollection(final String collection) {
+		public FindByQueryWithDistinct<T> inCollection(final String collection) {
 			return new ReactiveFindByQuerySupport<>(template, domainType, returnType, query, scanConsistency, scope,
-					collection, options, distinctFields, fields, support);
+					collection, options, distinctFields, fields, txCtx, support);
 		}
 
 		@Override
 		@Deprecated
-		public FindByQueryConsistentWith<T> consistentWith(QueryScanConsistency scanConsistency) {
+		public FindByQueryWithOptions<T> consistentWith(QueryScanConsistency scanConsistency) {
 			return new ReactiveFindByQuerySupport<>(template, domainType, returnType, query, scanConsistency, scope,
-					collection, options, distinctFields, fields, support);
+					collection, options, distinctFields, fields, txCtx, support);
 		}
 
 		@Override
 		public FindByQueryWithConsistency<T> withConsistency(QueryScanConsistency scanConsistency) {
 			return new ReactiveFindByQuerySupport<>(template, domainType, returnType, query, scanConsistency, scope,
-					collection, options, distinctFields, fields, support);
+					collection, options, distinctFields, fields, txCtx, support);
 		}
 
-		public <R> FindByQueryWithConsistency<R> as(Class<R> returnType) {
+		public <R> FindByQueryWithProjecting<R> as(Class<R> returnType) {
 			Assert.notNull(returnType, "returnType must not be null!");
 			return new ReactiveFindByQuerySupport<>(template, domainType, returnType, query, scanConsistency, scope,
-					collection, options, distinctFields, fields, support);
+					collection, options, distinctFields, fields, txCtx, support);
 		}
 
 		@Override
@@ -142,7 +151,7 @@ public class ReactiveFindByQueryOperationSupport implements ReactiveFindByQueryO
 			Assert.notNull(fields, "Fields must not be null");
 			Assert.isNull(distinctFields, "only one of project(fields) and distinct(distinctFields) can be specified");
 			return new ReactiveFindByQuerySupport<>(template, domainType, returnType, query, scanConsistency, scope,
-					collection, options, distinctFields, fields, support);
+					collection, options, distinctFields, fields, txCtx, support);
 		}
 
 		@Override
@@ -154,7 +163,14 @@ public class ReactiveFindByQueryOperationSupport implements ReactiveFindByQueryO
 			// So to indicate do not use distinct, we use {"-"} from the annotation, and here we change it to null.
 			String[] dFields = distinctFields.length == 1 && "-".equals(distinctFields[0]) ? null : distinctFields;
 			return new ReactiveFindByQuerySupport<>(template, domainType, returnType, query, scanConsistency, scope,
-					collection, options, dFields, fields, support);
+					collection, options, dFields, fields, txCtx, support);
+		}
+
+		@Override
+		public FindByQueryWithTransaction<T> transaction(CouchbaseTransactionalOperator txCtx) {
+			Assert.notNull(txCtx, "txCtx must not be null!");
+			return new ReactiveFindByQuerySupport<>(template, domainType, returnType, query, scanConsistency, scope,
+					collection, options, distinctFields, fields, txCtx, support);
 		}
 
 		@Override
@@ -169,41 +185,55 @@ public class ReactiveFindByQueryOperationSupport implements ReactiveFindByQueryO
 
 		@Override
 		public Flux<T> all() {
-			PseudoArgs<QueryOptions> pArgs = new PseudoArgs(template, scope, collection, options, domainType);
+			PseudoArgs<QueryOptions> pArgs = new PseudoArgs(template, scope, collection, options, txCtx, domainType);
 			String statement = assembleEntityQuery(false, distinctFields, pArgs.getCollection());
 			LOG.trace("findByQuery {} statement: {}", pArgs, statement);
-			Mono<ReactiveQueryResult> allResult = pArgs.getScope() == null
-					? template.getCouchbaseClientFactory().getCluster().reactive().query(statement,
-							buildOptions(pArgs.getOptions()))
-					: template.getCouchbaseClientFactory().withScope(pArgs.getScope()).getScope().reactive().query(statement,
-							buildOptions(pArgs.getOptions()));
-			return Flux.defer(() -> allResult.onErrorMap(throwable -> {
+
+			ReactiveCouchbaseClientFactory clientFactory = template.getCouchbaseClientFactory();
+			ReactiveScope rs = clientFactory.getBlockingScope(pArgs.getScope()).reactive();
+			Mono<ReactiveCouchbaseTemplate> tmpl = template.doGetTemplate();
+
+			Mono<Object> allResult = tmpl.flatMap(tp -> tp.getCouchbaseClientFactory().getTransactionResources(null).flatMap(s -> {
+				if (s.getCore() == null) {
+					QueryOptions opts = buildOptions(pArgs.getOptions());
+					return pArgs.getScope() == null ? clientFactory.getCluster().block().reactive().query(statement, opts)
+							: rs.query(statement, opts);
+				} else {
+					TransactionQueryOptions opts = buildTransactionOptions(pArgs.getOptions());
+					return (AttemptContextReactiveAccessor.createReactiveTransactionAttemptContext(s.getCore(),
+							clientFactory.getCluster().block().environment().jsonSerializer())).query(statement, opts);
+				}
+			}));
+
+			return allResult.onErrorMap(throwable -> {
 				if (throwable instanceof RuntimeException) {
 					return template.potentiallyConvertRuntimeException((RuntimeException) throwable);
 				} else {
 					return throwable;
 				}
-			}).flatMapMany(ReactiveQueryResult::rowsAsObject).flatMap(row -> {
+			}).flatMapMany(o -> o instanceof ReactiveQueryResult ? ((ReactiveQueryResult) o).rowsAsObject()
+					: Flux.fromIterable(((TransactionQueryResult) o).rowsAsObject())).flatMap(row -> {
 				String id = "";
 				long cas = 0;
 				if (!query.isDistinct() && distinctFields == null) {
 					if (row.getString(TemplateUtils.SELECT_ID) == null) {
-						return Flux.error(new CouchbaseException(
-								"query did not project " + TemplateUtils.SELECT_ID + ". Either use #{#n1ql.selectEntity} or project "
-										+ TemplateUtils.SELECT_ID + " and " + TemplateUtils.SELECT_CAS + " : " + statement));
+						return Flux.error(new CouchbaseException("query did not project " + TemplateUtils.SELECT_ID
+								+ ". Either use #{#n1ql.selectEntity} or project " + TemplateUtils.SELECT_ID + " and "
+								+ TemplateUtils.SELECT_CAS + " : " + statement));
 					}
 					id = row.getString(TemplateUtils.SELECT_ID);
 					if (row.getLong(TemplateUtils.SELECT_CAS) == null) {
-						return Flux.error(new CouchbaseException(
-								"query did not project " + TemplateUtils.SELECT_CAS + ". Either use #{#n1ql.selectEntity} or project "
-										+ TemplateUtils.SELECT_ID + " and " + TemplateUtils.SELECT_CAS + " : " + statement));
+						return Flux.error(new CouchbaseException("query did not project " + TemplateUtils.SELECT_CAS
+								+ ". Either use #{#n1ql.selectEntity} or project " + TemplateUtils.SELECT_ID + " and "
+								+ TemplateUtils.SELECT_CAS + " : " + statement));
 					}
 					cas = row.getLong(TemplateUtils.SELECT_CAS);
 					row.removeKey(TemplateUtils.SELECT_ID);
 					row.removeKey(TemplateUtils.SELECT_CAS);
 				}
-				return support.decodeEntity(id, row.toString(), cas, returnType);
-			}));
+				return support.decodeEntity(id, row.toString(), cas, returnType, pArgs.getScope(), pArgs.getCollection(),
+						null);
+			});
 		}
 
 		public QueryOptions buildOptions(QueryOptions options) {
@@ -211,24 +241,42 @@ public class ReactiveFindByQueryOperationSupport implements ReactiveFindByQueryO
 			return query.buildQueryOptions(options, qsc);
 		}
 
+		private TransactionQueryOptions buildTransactionOptions(QueryOptions options) {
+			TransactionQueryOptions opts = OptionsBuilder.buildTransactionQueryOptions(buildOptions(options));
+			return opts;
+		}
+
 		@Override
 		public Mono<Long> count() {
-			PseudoArgs<QueryOptions> pArgs = new PseudoArgs(template, scope, collection, options, domainType);
+			PseudoArgs<QueryOptions> pArgs = new PseudoArgs(template, scope, collection, options, txCtx, domainType);
 			String statement = assembleEntityQuery(true, distinctFields, pArgs.getCollection());
 			LOG.trace("findByQuery {} statement: {}", pArgs, statement);
-			Mono<ReactiveQueryResult> countResult = pArgs.getScope() == null
-					? template.getCouchbaseClientFactory().getCluster().reactive().query(statement,
-							buildOptions(pArgs.getOptions()))
-					: template.getCouchbaseClientFactory().withScope(pArgs.getScope()).getScope().reactive().query(statement,
-							buildOptions(pArgs.getOptions()));
-			return Mono.defer(() -> countResult.onErrorMap(throwable -> {
+
+			ReactiveCouchbaseClientFactory clientFactory = template.getCouchbaseClientFactory();
+			ReactiveScope rs = clientFactory.getBlockingScope(pArgs.getScope()).reactive();
+			Mono<ReactiveCouchbaseTemplate> tmpl = template.doGetTemplate();
+
+			Mono<Object> allResult = tmpl.flatMap(tp -> tp.getCouchbaseClientFactory().getTransactionResources(null).flatMap(s -> {
+				if (s.getCore() == null) {
+					QueryOptions opts = buildOptions(pArgs.getOptions());
+					return pArgs.getScope() == null ? clientFactory.getBlockingCluster().reactive().query(statement, opts)
+							: rs.query(statement, opts);
+				} else {
+					TransactionQueryOptions opts = buildTransactionOptions(pArgs.getOptions());
+					return (AttemptContextReactiveAccessor.createReactiveTransactionAttemptContext(s.getCore(),
+							clientFactory.getBlockingCluster().environment().jsonSerializer())).query(statement, opts);
+				}
+			}));
+
+			return allResult.onErrorMap(throwable -> {
 						if (throwable instanceof RuntimeException) {
 							return template.potentiallyConvertRuntimeException((RuntimeException) throwable);
 						} else {
 							return throwable;
 						}
-			}).flatMapMany(ReactiveQueryResult::rowsAsObject).map(row -> row.getLong(row.getNames().iterator().next()))
-					.next());
+					}).flatMapMany(o -> o instanceof ReactiveQueryResult ? ((ReactiveQueryResult) o).rowsAsObject()
+							: Flux.fromIterable(((TransactionQueryResult) o).rowsAsObject()))
+					.map(row -> row.getLong(row.getNames().iterator().next())).elementAt(0);
 		}
 
 		@Override
diff --git a/src/main/java/org/springframework/data/couchbase/core/ReactiveFindFromReplicasByIdOperationSupport.java b/src/main/java/org/springframework/data/couchbase/core/ReactiveFindFromReplicasByIdOperationSupport.java
index 88cdcd61..cadca383 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ReactiveFindFromReplicasByIdOperationSupport.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ReactiveFindFromReplicasByIdOperationSupport.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -72,12 +72,14 @@ public class ReactiveFindFromReplicasByIdOperationSupport implements ReactiveFin
 			if (garOptions.build().transcoder() == null) {
 				garOptions.transcoder(RawJsonTranscoder.INSTANCE);
 			}
-			PseudoArgs<GetAnyReplicaOptions> pArgs = new PseudoArgs<>(template, scope, collection, garOptions, domainType);
+			PseudoArgs<GetAnyReplicaOptions> pArgs = new PseudoArgs<>(template, scope, collection, garOptions, null,
+					domainType);
 			LOG.trace("getAnyReplica {}", pArgs);
-			return Mono.just(id)
+			return TransactionalSupport.verifyNotInTransaction(template.doGetTemplate(), "findFromReplicasById")
+					.then(Mono.just(id))
 					.flatMap(docId -> template.getCouchbaseClientFactory().withScope(pArgs.getScope())
-							.getCollection(pArgs.getCollection()).reactive().getAnyReplica(docId, pArgs.getOptions()))
-					.flatMap(result -> support.decodeEntity(id, result.contentAs(String.class), result.cas(), returnType))
+							.getBlockingCollection(pArgs.getCollection()).reactive().getAnyReplica(docId, pArgs.getOptions()))
+            .flatMap(result -> support.decodeEntity(id, result.contentAs(String.class), result.cas(), returnType, pArgs.getScope(), pArgs.getCollection(), null))
 					.onErrorMap(throwable -> {
 						if (throwable instanceof RuntimeException) {
 							return template.potentiallyConvertRuntimeException((RuntimeException) throwable);
diff --git a/src/main/java/org/springframework/data/couchbase/core/ReactiveInsertByIdOperation.java b/src/main/java/org/springframework/data/couchbase/core/ReactiveInsertByIdOperation.java
index 953eff0e..a2818d21 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ReactiveInsertByIdOperation.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ReactiveInsertByIdOperation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,6 +15,7 @@
  */
 package org.springframework.data.couchbase.core;
 
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 
@@ -27,6 +28,7 @@ import org.springframework.data.couchbase.core.support.OneAndAllEntityReactive;
 import org.springframework.data.couchbase.core.support.WithDurability;
 import org.springframework.data.couchbase.core.support.WithExpiry;
 import org.springframework.data.couchbase.core.support.WithInsertOptions;
+import org.springframework.data.couchbase.core.support.WithTransaction;
 
 import com.couchbase.client.core.msg.kv.DurabilityLevel;
 import com.couchbase.client.java.kv.InsertOptions;
@@ -84,17 +86,43 @@ public interface ReactiveInsertByIdOperation {
 		TerminatingInsertById<T> withOptions(InsertOptions options);
 	}
 
+	interface InsertByIdWithDurability<T> extends InsertByIdWithOptions<T>, WithDurability<T> {
+
+		@Override
+		InsertByIdInCollection<T> withDurability(DurabilityLevel durabilityLevel);
+
+		@Override
+		InsertByIdInCollection<T> withDurability(PersistTo persistTo, ReplicateTo replicateTo);
+
+	}
+
+	interface InsertByIdWithExpiry<T> extends InsertByIdWithDurability<T>, WithExpiry<T> {
+
+		@Override
+		InsertByIdWithDurability<T> withExpiry(Duration expiry);
+	}
+
+	interface InsertByIdWithTransaction<T> extends TerminatingInsertById<T>, WithTransaction<T> {
+		@Override
+		InsertByIdWithDurability<T> transaction(CouchbaseTransactionalOperator txCtx);
+	}
+
 	/**
 	 * Fluent method to specify the collection.
 	 */
-	interface InsertByIdInCollection<T> extends InsertByIdWithOptions<T>, InCollection<T> {
+	interface InsertByIdTxOrNot<T> extends InsertByIdWithTransaction<T>, InsertByIdWithExpiry<T> {}
+
+	/**
+	 * Fluent method to specify the collection.
+	 */
+	interface InsertByIdInCollection<T> extends InsertByIdTxOrNot<T>, InCollection<T> {
 		/**
 		 * With a different collection
 		 *
 		 * @param collection the collection to use.
 		 */
 		@Override
-		InsertByIdWithOptions<T> inCollection(String collection);
+		InsertByIdTxOrNot<T> inCollection(String collection);
 	}
 
 	/**
@@ -110,27 +138,11 @@ public interface ReactiveInsertByIdOperation {
 		InsertByIdInCollection<T> inScope(String scope);
 	}
 
-	interface InsertByIdWithDurability<T> extends InsertByIdInScope<T>, WithDurability<T> {
-
-		@Override
-		InsertByIdInCollection<T> withDurability(DurabilityLevel durabilityLevel);
-
-		@Override
-		InsertByIdInCollection<T> withDurability(PersistTo persistTo, ReplicateTo replicateTo);
-
-	}
-
-	interface InsertByIdWithExpiry<T> extends InsertByIdWithDurability<T>, WithExpiry<T> {
-
-		@Override
-		InsertByIdWithDurability<T> withExpiry(Duration expiry);
-	}
-
 	/**
 	 * Provides methods for constructing KV insert operations in a fluent way.
 	 *
 	 * @param <T> the entity type to insert
 	 */
-	interface ReactiveInsertById<T> extends InsertByIdWithExpiry<T> {}
+	interface ReactiveInsertById<T> extends InsertByIdInScope<T> {}
 
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/ReactiveInsertByIdOperationSupport.java b/src/main/java/org/springframework/data/couchbase/core/ReactiveInsertByIdOperationSupport.java
index 7514e8ba..4de3a5f3 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ReactiveInsertByIdOperationSupport.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ReactiveInsertByIdOperationSupport.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,9 +15,11 @@
  */
 package org.springframework.data.couchbase.core;
 
+import com.couchbase.client.core.transaction.CoreTransactionGetResult;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 
+import java.lang.reflect.Method;
 import java.time.Duration;
 import java.util.Collection;
 
@@ -26,6 +28,9 @@ import org.slf4j.LoggerFactory;
 import org.springframework.data.couchbase.core.mapping.CouchbaseDocument;
 import org.springframework.data.couchbase.core.query.OptionsBuilder;
 import org.springframework.data.couchbase.core.support.PseudoArgs;
+import org.springframework.data.couchbase.repository.support.TransactionResultHolder;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
+import org.springframework.transaction.reactive.TransactionalOperator;
 import org.springframework.util.Assert;
 
 import com.couchbase.client.core.msg.kv.DurabilityLevel;
@@ -33,6 +38,8 @@ import com.couchbase.client.java.kv.InsertOptions;
 import com.couchbase.client.java.kv.PersistTo;
 import com.couchbase.client.java.kv.ReplicateTo;
 
+import static com.couchbase.client.java.transactions.internal.ConverterUtil.makeCollectionIdentifier;
+
 public class ReactiveInsertByIdOperationSupport implements ReactiveInsertByIdOperation {
 
 	private final ReactiveCouchbaseTemplate template;
@@ -46,7 +53,7 @@ public class ReactiveInsertByIdOperationSupport implements ReactiveInsertByIdOpe
 	public <T> ReactiveInsertById<T> insertById(final Class<T> domainType) {
 		Assert.notNull(domainType, "DomainType must not be null!");
 		return new ReactiveInsertByIdSupport<>(template, domainType, null, null, null, PersistTo.NONE, ReplicateTo.NONE,
-				DurabilityLevel.NONE, null, template.support());
+				DurabilityLevel.NONE, null, (TransactionalOperator) null, template.support());
 	}
 
 	static class ReactiveInsertByIdSupport<T> implements ReactiveInsertById<T> {
@@ -60,11 +67,32 @@ public class ReactiveInsertByIdOperationSupport implements ReactiveInsertByIdOpe
 		private final ReplicateTo replicateTo;
 		private final DurabilityLevel durabilityLevel;
 		private final Duration expiry;
+		private final CouchbaseTransactionalOperator txCtx;
+		private final TransactionalOperator txOp;
 		private final ReactiveTemplateSupport support;
 
 		ReactiveInsertByIdSupport(final ReactiveCouchbaseTemplate template, final Class<T> domainType, final String scope,
 								  final String collection, final InsertOptions options, final PersistTo persistTo, final ReplicateTo replicateTo,
-				final DurabilityLevel durabilityLevel, Duration expiry, ReactiveTemplateSupport support) {
+								  final DurabilityLevel durabilityLevel, Duration expiry, CouchbaseTransactionalOperator txCtx,
+								  ReactiveTemplateSupport support) {
+			this.template = template;
+			this.domainType = domainType;
+			this.scope = scope;
+			this.collection = collection;
+			this.options = options;
+			this.persistTo = persistTo;
+			this.replicateTo = replicateTo;
+			this.durabilityLevel = durabilityLevel;
+			this.expiry = expiry;
+			this.txCtx = txCtx;
+			this.txOp = null;
+			this.support = support;
+		}
+
+		ReactiveInsertByIdSupport(final ReactiveCouchbaseTemplate template, final Class<T> domainType, final String scope,
+								  final String collection, final InsertOptions options, final PersistTo persistTo, final ReplicateTo replicateTo,
+								  final DurabilityLevel durabilityLevel, Duration expiry, TransactionalOperator txOp,
+								  ReactiveTemplateSupport support) {
 			this.template = template;
 			this.domainType = domainType;
 			this.scope = scope;
@@ -74,28 +102,60 @@ public class ReactiveInsertByIdOperationSupport implements ReactiveInsertByIdOpe
 			this.replicateTo = replicateTo;
 			this.durabilityLevel = durabilityLevel;
 			this.expiry = expiry;
+			this.txCtx = null;
+			this.txOp = txOp;
 			this.support = support;
 		}
 
 		@Override
 		public Mono<T> one(T object) {
-			PseudoArgs<InsertOptions> pArgs = new PseudoArgs(template, scope, collection, options, domainType);
+			PseudoArgs<InsertOptions> pArgs = new PseudoArgs(template, scope, collection, options, txCtx, domainType);
 			LOG.trace("insertById {}", pArgs);
-			return Mono.just(object).flatMap(support::encodeEntity)
-					.flatMap(converted -> template.getCouchbaseClientFactory().withScope(pArgs.getScope())
-							.getCollection(pArgs.getCollection()).reactive()
-							.insert(converted.getId(), converted.export(), buildOptions(pArgs.getOptions(), converted))
-							.flatMap(result -> support.applyUpdatedId(object, converted.getId())
-									.flatMap(updatedObject -> support.applyUpdatedCas(updatedObject, converted, result.cas()))))
-					.onErrorMap(throwable -> {
-						if (throwable instanceof RuntimeException) {
-							return template.potentiallyConvertRuntimeException((RuntimeException) throwable);
-						} else {
-							return throwable;
-						}
+			System.err.println("txOp: " + pArgs.getTxOp());
+			Mono<ReactiveCouchbaseTemplate> tmpl = template.doGetTemplate();
+
+			return TransactionalSupport.one(tmpl, pArgs.getTxOp(), pArgs.getScope(), pArgs.getCollection(), support, object,
+					(TransactionalSupportHelper support) -> support.collection
+							.insert(support.converted.getId(), support.converted.export(),
+									buildOptions(pArgs.getOptions(), support.converted))
+							.flatMap(result -> this.support.applyResult(object, support.converted, support.converted.getId(),
+									result.cas(), null)),
+					(TransactionalSupportHelper support) -> {
+						rejectInvalidTransactionalOptions();
+
+						return support.ctx
+								.insert(makeCollectionIdentifier(support.collection.async()), support.converted.getId(),
+										template.getCouchbaseClientFactory().getBlockingCluster().environment().transcoder()
+												.encode(support.converted.export()).encoded())
+								.flatMap(result -> this.support.applyResult(object, support.converted, support.converted.getId(),
+										getCas(result), new TransactionResultHolder(result), null));
 					});
 		}
 
+		private void rejectInvalidTransactionalOptions() {
+			if ((this.persistTo != null && this.persistTo != PersistTo.NONE) || (this.replicateTo != null && this.replicateTo != ReplicateTo.NONE)) {
+				throw new IllegalArgumentException("withDurability PersistTo and ReplicateTo overload is not supported in a transaction");
+			}
+			if (this.expiry != null) {
+				throw new IllegalArgumentException("withExpiry is not supported in a transaction");
+			}
+			if (this.options != null) {
+				throw new IllegalArgumentException("withOptions is not supported in a transaction");
+			}
+		}
+
+		private Long getCas(CoreTransactionGetResult getResult) {
+			CoreTransactionGetResult internal;
+			try {
+				// Method method = CoreTransactionGetResult.class.getDeclaredMethod("internal");
+				// method.setAccessible(true);
+				// internal = (CoreTransactionGetResult) method.invoke(getResult);
+			} catch (Throwable err) {
+				throw new RuntimeException(err);
+			}
+			return getResult.cas();
+		}
+
 		@Override
 		public Flux<? extends T> all(Collection<? extends T> objects) {
 			return Flux.fromIterable(objects).flatMap(this::one);
@@ -109,42 +169,52 @@ public class ReactiveInsertByIdOperationSupport implements ReactiveInsertByIdOpe
 		public TerminatingInsertById<T> withOptions(final InsertOptions options) {
 			Assert.notNull(options, "Options must not be null.");
 			return new ReactiveInsertByIdSupport<>(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, expiry, support);
+					durabilityLevel, expiry, txCtx, support);
 		}
 
 		@Override
 		public InsertByIdInCollection<T> inScope(final String scope) {
 			return new ReactiveInsertByIdSupport<>(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, expiry, support);
+					durabilityLevel, expiry, txCtx, support);
 		}
 
 		@Override
-		public InsertByIdWithOptions<T> inCollection(final String collection) {
+		public InsertByIdTxOrNot<T> inCollection(final String collection) {
 			return new ReactiveInsertByIdSupport<>(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, expiry, support);
+					durabilityLevel, expiry, txCtx, support);
 		}
 
 		@Override
-		public InsertByIdInCollection<T> withDurability(final DurabilityLevel durabilityLevel) {
+		public InsertByIdInScope<T> withDurability(final DurabilityLevel durabilityLevel) {
 			Assert.notNull(durabilityLevel, "Durability Level must not be null.");
 			return new ReactiveInsertByIdSupport<>(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, expiry, support);
+					durabilityLevel, expiry, txCtx, support);
 		}
 
+		// todo gpx need to figure out how to handle options re transactions. E.g. many non-transactional insert options,
+		// like this, aren't supported
 		@Override
-		public InsertByIdInCollection<T> withDurability(final PersistTo persistTo, final ReplicateTo replicateTo) {
+		public InsertByIdInScope<T> withDurability(final PersistTo persistTo, final ReplicateTo replicateTo) {
 			Assert.notNull(persistTo, "PersistTo must not be null.");
 			Assert.notNull(replicateTo, "ReplicateTo must not be null.");
 			return new ReactiveInsertByIdSupport<>(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, expiry, support);
+					durabilityLevel, expiry, txCtx, support);
 		}
 
 		@Override
 		public InsertByIdWithDurability<T> withExpiry(final Duration expiry) {
 			Assert.notNull(expiry, "expiry must not be null.");
 			return new ReactiveInsertByIdSupport<>(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, expiry, support);
+					durabilityLevel, expiry, txCtx, support);
 		}
+
+		@Override
+		public InsertByIdWithExpiry<T> transaction(final CouchbaseTransactionalOperator txCtx) {
+			Assert.notNull(txCtx, "txCtx must not be null.");
+			return new ReactiveInsertByIdSupport<>(template, domainType, scope, collection, options, persistTo, replicateTo,
+					durabilityLevel, expiry, txCtx, support);
+		}
+
 	}
 
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/ReactiveRemoveByIdOperation.java b/src/main/java/org/springframework/data/couchbase/core/ReactiveRemoveByIdOperation.java
index 561be70e..c827b02c 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ReactiveRemoveByIdOperation.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ReactiveRemoveByIdOperation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,6 +15,7 @@
  */
 package org.springframework.data.couchbase.core;
 
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 
@@ -25,6 +26,7 @@ import org.springframework.data.couchbase.core.support.InScope;
 import org.springframework.data.couchbase.core.support.OneAndAllIdReactive;
 import org.springframework.data.couchbase.core.support.WithDurability;
 import org.springframework.data.couchbase.core.support.WithRemoveOptions;
+import org.springframework.data.couchbase.core.support.WithTransaction;
 
 import com.couchbase.client.core.msg.kv.DurabilityLevel;
 import com.couchbase.client.java.kv.PersistTo;
@@ -63,6 +65,13 @@ public interface ReactiveRemoveByIdOperation {
 		@Override
 		Mono<RemoveResult> one(String id);
 
+		/**
+		 * Remove one document. Requires whole entity for transaction to have the cas.
+		 *
+		 * @param entity the entity
+		 * @return result of the remove
+		 */
+		Mono<RemoveResult> oneEntity(Object entity);
 		/**
 		 * Remove the documents in the collection.
 		 *
@@ -71,6 +80,13 @@ public interface ReactiveRemoveByIdOperation {
 		 */
 		@Override
 		Flux<RemoveResult> all(Collection<String> ids);
+		/**
+		 * Remove the documents in the collection.  Requires whole entity for transaction to have the cas.
+		 *
+		 * @param ids the document IDs.
+		 * @return result of the removes.
+		 */
+		Flux<RemoveResult> allEntities(Collection<Object> ids);
 
 	}
 
@@ -86,22 +102,42 @@ public interface ReactiveRemoveByIdOperation {
 		TerminatingRemoveById withOptions(RemoveOptions options);
 	}
 
+	interface RemoveByIdWithDurability extends RemoveByIdWithOptions, WithDurability<RemoveResult> {
+		@Override
+		RemoveByIdInCollection withDurability(DurabilityLevel durabilityLevel);
+
+		@Override
+		RemoveByIdInCollection withDurability(PersistTo persistTo, ReplicateTo replicateTo);
+
+	}
+
+	interface RemoveByIdWithCas extends RemoveByIdWithDurability {
+
+		RemoveByIdWithDurability withCas(Long cas);
+	}
+
+	interface RemoveByIdWithTransaction extends RemoveByIdWithCas, WithTransaction<RemoveResult> {
+		RemoveByIdWithCas transaction(CouchbaseTransactionalOperator txCtx);
+	}
+
+	interface RemoveByIdTxOrNot extends RemoveByIdWithCas, RemoveByIdWithTransaction {}
+
 	/**
 	 * Fluent method to specify the collection.
 	 */
-	interface RemoveByIdInCollection extends RemoveByIdWithOptions, InCollection<Object> {
+	interface RemoveByIdInCollection extends RemoveByIdTxOrNot, InCollection<RemoveResult> {
 		/**
 		 * With a different collection
 		 *
 		 * @param collection the collection to use.
 		 */
-		RemoveByIdWithOptions inCollection(String collection);
+		RemoveByIdTxOrNot inCollection(String collection);
 	}
 
 	/**
 	 * Fluent method to specify the scope.
 	 */
-	interface RemoveByIdInScope extends RemoveByIdInCollection, InScope<Object> {
+	interface RemoveByIdInScope extends RemoveByIdInCollection, InScope<RemoveResult> {
 		/**
 		 * With a different scope
 		 *
@@ -110,23 +146,9 @@ public interface ReactiveRemoveByIdOperation {
 		RemoveByIdInCollection inScope(String scope);
 	}
 
-	interface RemoveByIdWithDurability extends RemoveByIdInScope, WithDurability<RemoveResult> {
-		@Override
-		RemoveByIdInCollection withDurability(DurabilityLevel durabilityLevel);
-
-		@Override
-		RemoveByIdInCollection withDurability(PersistTo persistTo, ReplicateTo replicateTo);
-
-	}
-
-	interface RemoveByIdWithCas extends RemoveByIdWithDurability {
-
-		RemoveByIdWithDurability withCas(Long cas);
-	}
-
 	/**
 	 * Provides methods for constructing remove operations in a fluent way.
 	 */
-	interface ReactiveRemoveById extends RemoveByIdWithCas {}
+	interface ReactiveRemoveById extends RemoveByIdInScope {};
 
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/ReactiveRemoveByIdOperationSupport.java b/src/main/java/org/springframework/data/couchbase/core/ReactiveRemoveByIdOperationSupport.java
index b4f64ed7..fb8f3ee8 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ReactiveRemoveByIdOperationSupport.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ReactiveRemoveByIdOperationSupport.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,9 +15,17 @@
  */
 package org.springframework.data.couchbase.core;
 
+import com.couchbase.client.core.error.CasMismatchException;
+import com.couchbase.client.core.error.transaction.RetryTransactionException;
+import com.couchbase.client.core.error.transaction.TransactionOperationFailedException;
+import com.couchbase.client.core.transaction.CoreTransactionGetResult;
+import com.couchbase.client.java.transactions.TransactionGetResult;
+import org.springframework.data.couchbase.ReactiveCouchbaseClientFactory;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 
+import java.lang.reflect.Method;
 import java.util.Collection;
 
 import org.slf4j.Logger;
@@ -27,10 +35,13 @@ import org.springframework.data.couchbase.core.support.PseudoArgs;
 import org.springframework.util.Assert;
 
 import com.couchbase.client.core.msg.kv.DurabilityLevel;
+import com.couchbase.client.java.ReactiveCollection;
 import com.couchbase.client.java.kv.PersistTo;
 import com.couchbase.client.java.kv.RemoveOptions;
 import com.couchbase.client.java.kv.ReplicateTo;
 
+import static com.couchbase.client.java.transactions.internal.ConverterUtil.makeCollectionIdentifier;
+
 public class ReactiveRemoveByIdOperationSupport implements ReactiveRemoveByIdOperation {
 
 	private final ReactiveCouchbaseTemplate template;
@@ -49,7 +60,7 @@ public class ReactiveRemoveByIdOperationSupport implements ReactiveRemoveByIdOpe
 	@Override
 	public ReactiveRemoveById removeById(Class<?> domainType) {
 		return new ReactiveRemoveByIdSupport(template, domainType, null, null, null, PersistTo.NONE, ReplicateTo.NONE,
-				DurabilityLevel.NONE, null);
+				DurabilityLevel.NONE, null, null);
 	}
 
 	static class ReactiveRemoveByIdSupport implements ReactiveRemoveById {
@@ -63,10 +74,11 @@ public class ReactiveRemoveByIdOperationSupport implements ReactiveRemoveByIdOpe
 		private final ReplicateTo replicateTo;
 		private final DurabilityLevel durabilityLevel;
 		private final Long cas;
+		private final CouchbaseTransactionalOperator txCtx;
 
 		ReactiveRemoveByIdSupport(final ReactiveCouchbaseTemplate template, final Class<?> domainType, final String scope,
 								  final String collection, final RemoveOptions options, final PersistTo persistTo, final ReplicateTo replicateTo,
-				final DurabilityLevel durabilityLevel, Long cas) {
+								  final DurabilityLevel durabilityLevel, Long cas, CouchbaseTransactionalOperator txCtx) {
 			this.template = template;
 			this.domainType = domainType;
 			this.scope = scope;
@@ -76,23 +88,65 @@ public class ReactiveRemoveByIdOperationSupport implements ReactiveRemoveByIdOpe
 			this.replicateTo = replicateTo;
 			this.durabilityLevel = durabilityLevel;
 			this.cas = cas;
+			this.txCtx = txCtx;
 		}
 
 		@Override
 		public Mono<RemoveResult> one(final String id) {
-			PseudoArgs<RemoveOptions> pArgs = new PseudoArgs<>(template, scope, collection, options, domainType);
+			PseudoArgs<RemoveOptions> pArgs = new PseudoArgs<>(template, scope, collection, options, txCtx, domainType);
 			LOG.trace("removeById {}", pArgs);
-			return Mono.just(id)
-					.flatMap(docId -> template.getCouchbaseClientFactory().withScope(pArgs.getScope())
-							.getCollection(pArgs.getCollection()).reactive().remove(id, buildRemoveOptions(pArgs.getOptions()))
-							.map(r -> RemoveResult.from(docId, r)))
-					.onErrorMap(throwable -> {
+			ReactiveCouchbaseClientFactory clientFactory = template.getCouchbaseClientFactory();
+			ReactiveCollection rc = clientFactory.withScope(pArgs.getScope()).getCollection(pArgs.getCollection()).block()
+					.reactive();
+			Mono<ReactiveCouchbaseTemplate> tmpl = template.doGetTemplate();
+			final Mono<RemoveResult> removeResult;
+
+			// todo gpx convert to TransactionalSupport
+			Mono<RemoveResult> allResult = tmpl.flatMap(tp -> tp.getCouchbaseClientFactory().getTransactionResources(null).flatMap(s -> {
+				if (s.getCore() == null) {
+					System.err.println("non-tx remove");
+					return rc.remove(id, buildRemoveOptions(pArgs.getOptions())).map(r -> RemoveResult.from(id, r));
+				} else {
+					rejectInvalidTransactionalOptions();
+
+					System.err.println("tx remove");
+					if ( cas == null || cas == 0 ){
+						throw new IllegalArgumentException("cas must be supplied for tx remove");
+					}
+					Mono<CoreTransactionGetResult> gr = s.getCore().get(makeCollectionIdentifier(rc.async()), id);
+
+					return gr.flatMap(getResult -> {
+						if (getResult.cas() != cas) {
+							return Mono.error(TransactionalSupport.retryTransactionOnCasMismatch(s.getCore(), getResult.cas(), cas));
+						}
+						return s.getCore().remove(getResult)
+								.map(r -> new RemoveResult(id, 0, null));
+					});
+
+				}}).onErrorMap(throwable -> {
 				if (throwable instanceof RuntimeException) {
 					return template.potentiallyConvertRuntimeException((RuntimeException) throwable);
 				} else {
 					return throwable;
 				}
-					});
+			}));
+			return allResult;
+		}
+
+		private void rejectInvalidTransactionalOptions() {
+			if ((this.persistTo != null && this.persistTo != PersistTo.NONE) || (this.replicateTo != null && this.replicateTo != ReplicateTo.NONE)) {
+				throw new IllegalArgumentException("withDurability PersistTo and ReplicateTo overload is not supported in a transaction");
+			}
+			if (this.options != null) {
+				throw new IllegalArgumentException("withOptions is not supported in a transaction");
+			}
+		}
+
+		@Override
+		public Mono<RemoveResult> oneEntity(Object entity) {
+			ReactiveRemoveByIdSupport op = new ReactiveRemoveByIdSupport(template, domainType, scope, collection, options, persistTo, replicateTo,
+					durabilityLevel, template.support().getCas(entity), txCtx);
+			return op.one(template.support().getId(entity).toString());
 		}
 
 		@Override
@@ -100,49 +154,61 @@ public class ReactiveRemoveByIdOperationSupport implements ReactiveRemoveByIdOpe
 			return Flux.fromIterable(ids).flatMap(this::one);
 		}
 
+		@Override
+		public Flux<RemoveResult> allEntities(Collection<Object> entities) {
+			return Flux.fromIterable(entities).flatMap(this::oneEntity);
+		}
+
 		private RemoveOptions buildRemoveOptions(RemoveOptions options) {
 			return OptionsBuilder.buildRemoveOptions(options, persistTo, replicateTo, durabilityLevel, cas);
 		}
 
 		@Override
-		public RemoveByIdInCollection withDurability(final DurabilityLevel durabilityLevel) {
+		public RemoveByIdInScope withDurability(final DurabilityLevel durabilityLevel) {
 			Assert.notNull(durabilityLevel, "Durability Level must not be null.");
 			return new ReactiveRemoveByIdSupport(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, cas);
+					durabilityLevel, cas, txCtx);
 		}
 
 		@Override
-		public RemoveByIdInCollection withDurability(final PersistTo persistTo, final ReplicateTo replicateTo) {
+		public RemoveByIdInScope withDurability(final PersistTo persistTo, final ReplicateTo replicateTo) {
 			Assert.notNull(persistTo, "PersistTo must not be null.");
 			Assert.notNull(replicateTo, "ReplicateTo must not be null.");
 			return new ReactiveRemoveByIdSupport(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, cas);
+					durabilityLevel, cas, txCtx);
 		}
 
 		@Override
-		public RemoveByIdWithDurability inCollection(final String collection) {
+		public RemoveByIdTxOrNot inCollection(final String collection) {
 			return new ReactiveRemoveByIdSupport(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, cas);
+					durabilityLevel, cas, txCtx);
 		}
 
 		@Override
 		public RemoveByIdInCollection inScope(final String scope) {
 			return new ReactiveRemoveByIdSupport(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, cas);
+					durabilityLevel, cas, txCtx);
 		}
 
 		@Override
 		public TerminatingRemoveById withOptions(final RemoveOptions options) {
 			Assert.notNull(options, "Options must not be null.");
 			return new ReactiveRemoveByIdSupport(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, cas);
+					durabilityLevel, cas, txCtx);
 		}
 
 		@Override
 		public RemoveByIdWithDurability withCas(Long cas) {
 			return new ReactiveRemoveByIdSupport(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, cas);
+					durabilityLevel, cas, txCtx);
+		}
+
+		@Override
+		public RemoveByIdWithCas transaction(CouchbaseTransactionalOperator txCtx) {
+			return new ReactiveRemoveByIdSupport(template, domainType, scope, collection, options, persistTo, replicateTo,
+					durabilityLevel, cas, txCtx);
 		}
+
 	}
 
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/ReactiveRemoveByQueryOperation.java b/src/main/java/org/springframework/data/couchbase/core/ReactiveRemoveByQueryOperation.java
index 7619eabf..95aed499 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ReactiveRemoveByQueryOperation.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ReactiveRemoveByQueryOperation.java
@@ -15,6 +15,7 @@
  */
 package org.springframework.data.couchbase.core;
 
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 import reactor.core.publisher.Flux;
 
 import org.springframework.data.couchbase.core.query.Query;
@@ -24,6 +25,7 @@ import org.springframework.data.couchbase.core.support.InScope;
 import org.springframework.data.couchbase.core.support.WithConsistency;
 import org.springframework.data.couchbase.core.support.WithQuery;
 import org.springframework.data.couchbase.core.support.WithQueryOptions;
+import org.springframework.data.couchbase.core.support.WithTransaction;
 
 import com.couchbase.client.java.query.QueryOptions;
 import com.couchbase.client.java.query.QueryScanConsistency;
@@ -54,31 +56,62 @@ public interface ReactiveRemoveByQueryOperation {
 	}
 
 	/**
-	 * Fluent methods to specify the query
+	 * Fluent method to specify options.
 	 *
-	 * @param <T> the entity type.
+	 * @param <T> the entity type to use for the results.
+	 */
+	interface RemoveByQueryWithOptions<T> extends TerminatingRemoveByQuery<T>, WithQueryOptions<RemoveResult> {
+		/**
+		 * Fluent method to specify options to use for execution
+		 *
+		 * @param options to use for execution
 		 */
-	interface RemoveByQueryWithQuery<T> extends TerminatingRemoveByQuery<T>, WithQuery<RemoveResult> {
+		TerminatingRemoveByQuery<T> withOptions(QueryOptions options);
+	}
 
-		TerminatingRemoveByQuery<T> matching(Query query);
+	@Deprecated
+	interface RemoveByQueryConsistentWith<T> extends RemoveByQueryWithOptions<T> {
+
+		@Deprecated
+		RemoveByQueryWithOptions<T> consistentWith(QueryScanConsistency scanConsistency);
 
-		default TerminatingRemoveByQuery<T> matching(QueryCriteriaDefinition criteria) {
-			return matching(Query.query(criteria));
 	}
+
+	interface RemoveByQueryWithConsistency<T> extends RemoveByQueryConsistentWith<T>, WithConsistency<RemoveResult> {
+		@Override
+		RemoveByQueryConsistentWith<T> withConsistency(QueryScanConsistency scanConsistency);
+
 	}
 
 	/**
-	 * Fluent method to specify options.
+	 * Fluent method to specify the transaction
 	 *
 	 * @param <T> the entity type to use for the results.
 	 */
-	interface RemoveByQueryWithOptions<T> extends RemoveByQueryWithQuery<T>, WithQueryOptions<RemoveResult> {
+	interface RemoveByQueryWithTransaction<T> extends TerminatingRemoveByQuery<T>, WithTransaction<RemoveResult> {
 		/**
-		 * Fluent method to specify options to use for execution
+		 * Provide the transaction
 		 *
-		 * @param options to use for execution
+		 * @param txCtx - transaction
 		 */
-		RemoveByQueryWithQuery<T> withOptions(QueryOptions options);
+		@Override
+		TerminatingRemoveByQuery<T> transaction(CouchbaseTransactionalOperator txCtx);
+	}
+
+	interface RemoveByQueryTxOrNot<T> extends RemoveByQueryWithConsistency<T>, RemoveByQueryWithTransaction<T> {}
+
+	/**
+	 * Fluent methods to specify the query
+	 *
+	 * @param <T> the entity type.
+	 */
+	interface RemoveByQueryWithQuery<T> extends RemoveByQueryTxOrNot<T>, WithQuery<RemoveResult> {
+
+		RemoveByQueryTxOrNot<T> matching(Query query);
+
+		default RemoveByQueryTxOrNot<T> matching(QueryCriteriaDefinition criteria) {
+			return matching(Query.query(criteria));
+		}
 	}
 
 	/**
@@ -86,13 +119,13 @@ public interface ReactiveRemoveByQueryOperation {
 	 *
 	 * @param <T> the entity type to use for the results.
 	 */
-	interface RemoveByQueryInCollection<T> extends RemoveByQueryWithOptions<T>, InCollection<Object> {
+	interface RemoveByQueryInCollection<T> extends RemoveByQueryWithQuery<T>, InCollection<Object> {
 		/**
 		 * With a different collection
 		 *
 		 * @param collection the collection to use.
 		 */
-		RemoveByQueryWithOptions<T> inCollection(String collection);
+		RemoveByQueryWithQuery<T> inCollection(String collection);
 	}
 
 	/**
@@ -109,25 +142,11 @@ public interface ReactiveRemoveByQueryOperation {
 		RemoveByQueryInCollection<T> inScope(String scope);
 	}
 
-	@Deprecated
-	interface RemoveByQueryConsistentWith<T> extends RemoveByQueryInScope<T> {
-
-		@Deprecated
-		RemoveByQueryInScope<T> consistentWith(QueryScanConsistency scanConsistency);
-
-	}
-
-	interface RemoveByQueryWithConsistency<T> extends RemoveByQueryConsistentWith<T>, WithConsistency<RemoveResult> {
-		@Override
-		RemoveByQueryConsistentWith<T> withConsistency(QueryScanConsistency scanConsistency);
-
-	}
-
 	/**
 	 * Provides methods for constructing query operations in a fluent way.
 	 *
 	 * @param <T> the entity type.
 	 */
-	interface ReactiveRemoveByQuery<T> extends RemoveByQueryWithConsistency<T> {}
+	interface ReactiveRemoveByQuery<T> extends RemoveByQueryInScope<T> {}
 
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/ReactiveRemoveByQueryOperationSupport.java b/src/main/java/org/springframework/data/couchbase/core/ReactiveRemoveByQueryOperationSupport.java
index d6ea991d..d21bcab0 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ReactiveRemoveByQueryOperationSupport.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ReactiveRemoveByQueryOperationSupport.java
@@ -15,6 +15,10 @@
  */
 package org.springframework.data.couchbase.core;
 
+import com.couchbase.client.java.transactions.TransactionQueryOptions;
+import com.couchbase.client.java.transactions.TransactionQueryResult;
+import org.springframework.data.couchbase.ReactiveCouchbaseClientFactory;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 
@@ -27,6 +31,7 @@ import org.springframework.data.couchbase.core.support.PseudoArgs;
 import org.springframework.data.couchbase.core.support.TemplateUtils;
 import org.springframework.util.Assert;
 
+import com.couchbase.client.java.ReactiveScope;
 import com.couchbase.client.java.query.QueryOptions;
 import com.couchbase.client.java.query.QueryScanConsistency;
 import com.couchbase.client.java.query.ReactiveQueryResult;
@@ -44,7 +49,7 @@ public class ReactiveRemoveByQueryOperationSupport implements ReactiveRemoveByQu
 
 	@Override
 	public <T> ReactiveRemoveByQuery<T> removeByQuery(Class<T> domainType) {
-		return new ReactiveRemoveByQuerySupport<>(template, domainType, ALL_QUERY, null, null, null, null);
+		return new ReactiveRemoveByQuerySupport<>(template, domainType, ALL_QUERY, null, null, null, null, null);
 	}
 
 	static class ReactiveRemoveByQuerySupport<T> implements ReactiveRemoveByQuery<T> {
@@ -56,9 +61,11 @@ public class ReactiveRemoveByQueryOperationSupport implements ReactiveRemoveByQu
 		private final String scope;
 		private final String collection;
 		private final QueryOptions options;
+		private final CouchbaseTransactionalOperator txCtx;
 
 		ReactiveRemoveByQuerySupport(final ReactiveCouchbaseTemplate template, final Class<T> domainType, final Query query,
-				final QueryScanConsistency scanConsistency, String scope, String collection, QueryOptions options) {
+									 final QueryScanConsistency scanConsistency, String scope, String collection, QueryOptions options,
+									 CouchbaseTransactionalOperator txCtx) {
 			this.template = template;
 			this.domainType = domainType;
 			this.query = query;
@@ -66,19 +73,28 @@ public class ReactiveRemoveByQueryOperationSupport implements ReactiveRemoveByQu
 			this.scope = scope;
 			this.collection = collection;
 			this.options = options;
+			this.txCtx = txCtx;
 		}
 
 		@Override
 		public Flux<RemoveResult> all() {
-			PseudoArgs<QueryOptions> pArgs = new PseudoArgs<>(template, scope, collection, options, domainType);
+			PseudoArgs<QueryOptions> pArgs = new PseudoArgs<>(template, scope, collection, options, txCtx, domainType);
 			String statement = assembleDeleteQuery(pArgs.getCollection());
 			LOG.trace("removeByQuery {} statement: {}", pArgs, statement);
-			Mono<ReactiveQueryResult> allResult = pArgs.getScope() == null
-					? template.getCouchbaseClientFactory().getCluster().reactive().query(statement,
-							buildQueryOptions(pArgs.getOptions()))
-					: template.getCouchbaseClientFactory().withScope(pArgs.getScope()).getScope().reactive().query(statement,
-							buildQueryOptions(pArgs.getOptions()));
-			return Flux.defer(() -> allResult.onErrorMap(throwable -> {
+			Mono<ReactiveQueryResult> allResult = null;
+			ReactiveCouchbaseClientFactory clientFactory = template.getCouchbaseClientFactory();
+			ReactiveScope rs = clientFactory.getBlockingScope(pArgs.getScope()).reactive();
+			if (pArgs.getTxOp() == null) {
+				QueryOptions opts = buildQueryOptions(pArgs.getOptions());
+				allResult = pArgs.getScope() == null ? clientFactory.getBlockingCluster().reactive().query(statement, opts)
+						: rs.query(statement, opts);
+			} else {
+				TransactionQueryOptions opts = buildTransactionOptions(buildQueryOptions(pArgs.getOptions()));
+				Mono<TransactionQueryResult> tqr = pArgs.getScope() == null ? pArgs.getTxOp().getAttemptContextReactive().query(statement, opts) : pArgs.getTxOp().getAttemptContextReactive().query(rs, statement, opts);
+				// todo gpx do something with tqr
+			}
+			Mono<ReactiveQueryResult> finalAllResult = allResult;
+			return Flux.defer(() -> finalAllResult.onErrorMap(throwable -> {
 						if (throwable instanceof RuntimeException) {
 							return template.potentiallyConvertRuntimeException((RuntimeException) throwable);
 						} else {
@@ -94,29 +110,34 @@ public class ReactiveRemoveByQueryOperationSupport implements ReactiveRemoveByQu
 			return query.buildQueryOptions(options, qsc);
 		}
 
+		private TransactionQueryOptions buildTransactionOptions(QueryOptions options) {
+			TransactionQueryOptions txOptions = TransactionQueryOptions.queryOptions();
+			return txOptions;
+		}
+
 		@Override
-		public TerminatingRemoveByQuery<T> matching(final Query query) {
+		public RemoveByQueryTxOrNot<T> matching(final Query query) {
 			return new ReactiveRemoveByQuerySupport<>(template, domainType, query, scanConsistency, scope, collection,
-					options);
+					options, txCtx);
 		}
 
 		@Override
-		public RemoveByQueryWithConsistency<T> inCollection(final String collection) {
+		public RemoveByQueryWithQuery<T> inCollection(final String collection) {
 			return new ReactiveRemoveByQuerySupport<>(template, domainType, query, scanConsistency, scope, collection,
-					options);
+					options, txCtx);
 		}
 
 		@Override
 		@Deprecated
 		public RemoveByQueryInScope<T> consistentWith(final QueryScanConsistency scanConsistency) {
 			return new ReactiveRemoveByQuerySupport<>(template, domainType, query, scanConsistency, scope, collection,
-					options);
+					options, txCtx);
 		}
 
 		@Override
 		public RemoveByQueryConsistentWith<T> withConsistency(final QueryScanConsistency scanConsistency) {
 			return new ReactiveRemoveByQuerySupport<>(template, domainType, query, scanConsistency, scope, collection,
-					options);
+					options, txCtx);
 		}
 
 		private String assembleDeleteQuery(String collection) {
@@ -127,14 +148,21 @@ public class ReactiveRemoveByQueryOperationSupport implements ReactiveRemoveByQu
 		public RemoveByQueryWithQuery<T> withOptions(final QueryOptions options) {
 			Assert.notNull(options, "Options must not be null.");
 			return new ReactiveRemoveByQuerySupport<>(template, domainType, query, scanConsistency, scope, collection,
-					options);
+					options, txCtx);
 		}
 
 		@Override
 		public RemoveByQueryInCollection<T> inScope(final String scope) {
 			return new ReactiveRemoveByQuerySupport<>(template, domainType, query, scanConsistency, scope, collection,
-					options);
+					options, txCtx);
 		}
+
+		@Override
+		public RemoveByQueryWithConsistency<T> transaction(final CouchbaseTransactionalOperator txCtx) {
+			return new ReactiveRemoveByQuerySupport<>(template, domainType, query, scanConsistency, scope, collection,
+					options, txCtx);
+		}
+
 	}
 
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/ReactiveReplaceByIdOperation.java b/src/main/java/org/springframework/data/couchbase/core/ReactiveReplaceByIdOperation.java
index 1f206772..deda7dd9 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ReactiveReplaceByIdOperation.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ReactiveReplaceByIdOperation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,6 +15,7 @@
  */
 package org.springframework.data.couchbase.core;
 
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 
@@ -27,6 +28,7 @@ import org.springframework.data.couchbase.core.support.OneAndAllEntityReactive;
 import org.springframework.data.couchbase.core.support.WithDurability;
 import org.springframework.data.couchbase.core.support.WithExpiry;
 import org.springframework.data.couchbase.core.support.WithReplaceOptions;
+import org.springframework.data.couchbase.core.support.WithTransaction;
 
 import com.couchbase.client.core.msg.kv.DurabilityLevel;
 import com.couchbase.client.java.kv.PersistTo;
@@ -84,19 +86,39 @@ public interface ReactiveReplaceByIdOperation {
 		TerminatingReplaceById<T> withOptions(ReplaceOptions options);
 	}
 
+	interface ReplaceByIdWithDurability<T> extends ReplaceByIdWithOptions<T>, WithDurability<T> {
+
+		ReplaceByIdInCollection<T> withDurability(DurabilityLevel durabilityLevel);
+
+		ReplaceByIdInCollection<T> withDurability(PersistTo persistTo, ReplicateTo replicateTo);
+
+	}
+
+	interface ReplaceByIdWithExpiry<T> extends ReplaceByIdWithDurability<T>, WithExpiry<T> {
+
+		ReplaceByIdWithDurability<T> withExpiry(final Duration expiry);
+	}
+
+	interface ReplaceByIdWithTransaction<T> extends TerminatingReplaceById<T>, WithTransaction<T> {
+		@Override
+		ReplaceByIdWithExpiry<T> transaction(final CouchbaseTransactionalOperator txCtx);
+	}
+
+	interface ReplaceByIdTxOrNot<T> extends ReplaceByIdWithExpiry<T>, ReplaceByIdWithTransaction<T> {}
+
 	/**
 	 * Fluent method to specify the collection.
 	 *
 	 * @param <T> the entity type to use for the results.
 	 */
-	interface ReplaceByIdInCollection<T> extends ReplaceByIdWithOptions<T>, InCollection<Object> {
+	interface ReplaceByIdInCollection<T> extends ReplaceByIdTxOrNot<T>, InCollection<Object> {
 		/**
 		 * With a different collection
 		 *
 		 * @param collection the collection to use.
 		 */
 		@Override
-		ReplaceByIdWithOptions<T> inCollection(String collection);
+		ReplaceByIdTxOrNot<T> inCollection(String collection);
 	}
 
 	/**
@@ -114,24 +136,11 @@ public interface ReactiveReplaceByIdOperation {
 		ReplaceByIdInCollection<T> inScope(String scope);
 	}
 
-	interface ReplaceByIdWithDurability<T> extends ReplaceByIdInScope<T>, WithDurability<T> {
-
-		ReplaceByIdInCollection<T> withDurability(DurabilityLevel durabilityLevel);
-
-		ReplaceByIdInCollection<T> withDurability(PersistTo persistTo, ReplicateTo replicateTo);
-
-	}
-
-	interface ReplaceByIdWithExpiry<T> extends ReplaceByIdWithDurability<T>, WithExpiry<T> {
-
-		ReplaceByIdWithDurability<T> withExpiry(final Duration expiry);
-	}
-
 	/**
 	 * Provides methods for constructing KV replace operations in a fluent way.
 	 *
 	 * @param <T> the entity type to replace
 	 */
-	interface ReactiveReplaceById<T> extends ReplaceByIdWithExpiry<T> {}
+	interface ReactiveReplaceById<T> extends ReplaceByIdInScope<T> {};
 
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/ReactiveReplaceByIdOperationSupport.java b/src/main/java/org/springframework/data/couchbase/core/ReactiveReplaceByIdOperationSupport.java
index 55aebd4d..383ed9c5 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ReactiveReplaceByIdOperationSupport.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ReactiveReplaceByIdOperationSupport.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,9 +15,19 @@
  */
 package org.springframework.data.couchbase.core;
 
+import com.couchbase.client.core.error.CasMismatchException;
+import com.couchbase.client.core.error.transaction.RetryTransactionException;
+import com.couchbase.client.core.error.transaction.TransactionOperationFailedException;
+import com.couchbase.client.core.transaction.CoreTransactionGetResult;
+import com.couchbase.client.java.transactions.TransactionGetResult;
+import com.couchbase.client.core.error.transaction.RetryTransactionException;
+import com.couchbase.client.core.io.CollectionIdentifier;
+import com.couchbase.client.core.transaction.CoreTransactionGetResult;
+import com.couchbase.client.core.transaction.util.DebugUtil;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 
+import java.lang.reflect.Method;
 import java.time.Duration;
 import java.util.Collection;
 
@@ -26,13 +36,17 @@ import org.slf4j.LoggerFactory;
 import org.springframework.data.couchbase.core.mapping.CouchbaseDocument;
 import org.springframework.data.couchbase.core.query.OptionsBuilder;
 import org.springframework.data.couchbase.core.support.PseudoArgs;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 import org.springframework.util.Assert;
 
+import com.couchbase.client.core.error.CouchbaseException;
 import com.couchbase.client.core.msg.kv.DurabilityLevel;
 import com.couchbase.client.java.kv.PersistTo;
 import com.couchbase.client.java.kv.ReplaceOptions;
 import com.couchbase.client.java.kv.ReplicateTo;
 
+import static com.couchbase.client.java.transactions.internal.ConverterUtil.makeCollectionIdentifier;
+
 public class ReactiveReplaceByIdOperationSupport implements ReactiveReplaceByIdOperation {
 
 	private final ReactiveCouchbaseTemplate template;
@@ -46,7 +60,7 @@ public class ReactiveReplaceByIdOperationSupport implements ReactiveReplaceByIdO
 	public <T> ReactiveReplaceById<T> replaceById(final Class<T> domainType) {
 		Assert.notNull(domainType, "DomainType must not be null!");
 		return new ReactiveReplaceByIdSupport<>(template, domainType, null, null, null, PersistTo.NONE, ReplicateTo.NONE,
-				DurabilityLevel.NONE, null, template.support());
+				DurabilityLevel.NONE, null, null, template.support());
 	}
 
 	static class ReactiveReplaceByIdSupport<T> implements ReactiveReplaceById<T> {
@@ -60,11 +74,13 @@ public class ReactiveReplaceByIdOperationSupport implements ReactiveReplaceByIdO
 		private final ReplicateTo replicateTo;
 		private final DurabilityLevel durabilityLevel;
 		private final Duration expiry;
+		private final CouchbaseTransactionalOperator txCtx;
 		private final ReactiveTemplateSupport support;
 
 		ReactiveReplaceByIdSupport(final ReactiveCouchbaseTemplate template, final Class<T> domainType, final String scope,
 								   final String collection, final ReplaceOptions options, final PersistTo persistTo, final ReplicateTo replicateTo,
-				final DurabilityLevel durabilityLevel, final Duration expiry, ReactiveTemplateSupport support) {
+								   final DurabilityLevel durabilityLevel, final Duration expiry, final CouchbaseTransactionalOperator txCtx,
+								   ReactiveTemplateSupport support) {
 			this.template = template;
 			this.domainType = domainType;
 			this.scope = scope;
@@ -74,26 +90,57 @@ public class ReactiveReplaceByIdOperationSupport implements ReactiveReplaceByIdO
 			this.replicateTo = replicateTo;
 			this.durabilityLevel = durabilityLevel;
 			this.expiry = expiry;
+			this.txCtx = txCtx;
 			this.support = support;
 		}
 
 		@Override
 		public Mono<T> one(T object) {
-			PseudoArgs<ReplaceOptions> pArgs = new PseudoArgs<>(template, scope, collection, options, domainType);
+			PseudoArgs<ReplaceOptions> pArgs = new PseudoArgs<>(template, scope, collection, options, txCtx, domainType);
 			LOG.trace("replaceById {}", pArgs);
-			return Mono.just(object).flatMap(support::encodeEntity)
-					.flatMap(converted -> template.getCouchbaseClientFactory().withScope(pArgs.getScope())
-							.getCollection(pArgs.getCollection()).reactive()
+			Mono<ReactiveCouchbaseTemplate> tmpl = template.doGetTemplate();
+
+			return TransactionalSupport.one(tmpl, pArgs.getTxOp(), pArgs.getScope(), pArgs.getCollection(), support, object,
+					(TransactionalSupportHelper support) -> {
+						CouchbaseDocument converted = support.converted;
+
+						return support.collection
 								.replace(converted.getId(), converted.export(),
 										buildReplaceOptions(pArgs.getOptions(), object, converted))
-							.flatMap(result -> support.applyUpdatedCas(object, converted, result.cas())))
-					.onErrorMap(throwable -> {
-						if (throwable instanceof RuntimeException) {
-							return template.potentiallyConvertRuntimeException((RuntimeException) throwable);
-						} else {
-							return throwable;
+								.flatMap(result -> this.support.applyResult(object, converted, converted.getId(), result.cas(), null));
+					}, (TransactionalSupportHelper support) -> {
+						rejectInvalidTransactionalOptions();
+
+						CouchbaseDocument converted = support.converted;
+						if ( support.cas == null || support.cas == 0 ){
+							throw new IllegalArgumentException("cas must be supplied in object for tx replace. object="+object);
 						}
+
+						CollectionIdentifier collId = makeCollectionIdentifier(support.collection.async());
+						support.ctx.logger().info(support.ctx.attemptId(), "refetching %s for Spring replace", DebugUtil.docId(collId, converted.getId()));
+						Mono<CoreTransactionGetResult> gr = support.ctx.get(collId, converted.getId());
+
+						return gr.flatMap(getResult -> {
+							if (getResult.cas() != support.cas) {
+								return Mono.error(TransactionalSupport.retryTransactionOnCasMismatch(support.ctx, getResult.cas(), support.cas));
+							}
+							return support.ctx.replace(getResult, 	template.getCouchbaseClientFactory().getCluster().block().environment().transcoder()
+									.encode(support.converted.export()).encoded());
+						}).flatMap(result -> this.support.applyResult(object, converted, converted.getId(), 0L, null, null));
 					});
+
+		}
+
+		private void rejectInvalidTransactionalOptions() {
+			if ((this.persistTo != null && this.persistTo != PersistTo.NONE) || (this.replicateTo != null && this.replicateTo != ReplicateTo.NONE)) {
+				throw new IllegalArgumentException("withDurability PersistTo and ReplicateTo overload is not supported in a transaction");
+			}
+			if (this.expiry != null) {
+				throw new IllegalArgumentException("withExpiry is not supported in a transaction");
+			}
+			if (this.options != null) {
+				throw new IllegalArgumentException("withOptions is not supported in a transaction");
+			}
 		}
 
 		@Override
@@ -110,41 +157,48 @@ public class ReactiveReplaceByIdOperationSupport implements ReactiveReplaceByIdO
 		public TerminatingReplaceById<T> withOptions(final ReplaceOptions options) {
 			Assert.notNull(options, "Options must not be null.");
 			return new ReactiveReplaceByIdSupport<>(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, expiry, support);
+					durabilityLevel, expiry, txCtx, support);
 		}
 
 		@Override
-		public ReplaceByIdWithDurability<T> inCollection(final String collection) {
+		public ReplaceByIdTxOrNot<T> inCollection(final String collection) {
 			return new ReactiveReplaceByIdSupport<>(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, expiry, support);
+					durabilityLevel, expiry, txCtx, support);
 		}
 
 		@Override
 		public ReplaceByIdInCollection<T> inScope(final String scope) {
 			return new ReactiveReplaceByIdSupport<>(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, expiry, support);
+					durabilityLevel, expiry, txCtx, support);
 		}
 
 		@Override
-		public ReplaceByIdInCollection<T> withDurability(final DurabilityLevel durabilityLevel) {
+		public ReplaceByIdInScope<T> withDurability(final DurabilityLevel durabilityLevel) {
 			Assert.notNull(durabilityLevel, "Durability Level must not be null.");
 			return new ReactiveReplaceByIdSupport<>(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, expiry, support);
+					durabilityLevel, expiry, txCtx, support);
 		}
 
 		@Override
-		public ReplaceByIdInCollection<T> withDurability(final PersistTo persistTo, final ReplicateTo replicateTo) {
+		public ReplaceByIdInScope<T> withDurability(final PersistTo persistTo, final ReplicateTo replicateTo) {
 			Assert.notNull(persistTo, "PersistTo must not be null.");
 			Assert.notNull(replicateTo, "ReplicateTo must not be null.");
 			return new ReactiveReplaceByIdSupport<>(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, expiry, support);
+					durabilityLevel, expiry, txCtx, support);
 		}
 
 		@Override
 		public ReplaceByIdWithDurability<T> withExpiry(final Duration expiry) {
 			Assert.notNull(expiry, "expiry must not be null.");
 			return new ReactiveReplaceByIdSupport<>(template, domainType, scope, collection, options, persistTo, replicateTo,
-					durabilityLevel, expiry, support);
+					durabilityLevel, expiry, txCtx, support);
+		}
+
+		@Override
+		public ReplaceByIdWithExpiry<T> transaction(final CouchbaseTransactionalOperator txCtx) {
+			Assert.notNull(txCtx, "txCtx must not be null.");
+			return new ReactiveReplaceByIdSupport<>(template, domainType, scope, collection, options, persistTo, replicateTo,
+					durabilityLevel, expiry, txCtx, support);
 		}
 
 	}
diff --git a/src/main/java/org/springframework/data/couchbase/core/ReactiveSessionCallback.java b/src/main/java/org/springframework/data/couchbase/core/ReactiveSessionCallback.java
new file mode 100644
index 00000000..c91caa16
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/core/ReactiveSessionCallback.java
@@ -0,0 +1,45 @@
+package org.springframework.data.couchbase.core;
+/*
+ * Copyright 2018-2021 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.reactivestreams.Publisher;
+
+/**
+ * Callback interface for executing operations within a {@link com.mongodb.reactivestreams.client.ClientSession} using
+ * reactive infrastructure.
+ *
+ * @author Christoph Strobl
+ * @since 2.1
+ * @see com.mongodb.reactivestreams.client.ClientSession
+ */
+@FunctionalInterface
+public interface ReactiveSessionCallback<T> {
+
+	/**
+	 * Execute operations against a MongoDB instance via session bound {@link ReactiveMongoOperations}. The session is
+	 * inferred directly into the operation so that no further interaction is necessary. <br />
+	 * Please note that only Spring Data-specific abstractions like {@link ReactiveMongoOperations#find(Query, Class)} and
+	 * others are enhanced with the {@link com.mongodb.session.ClientSession}. When obtaining plain MongoDB gateway
+	 * objects like {@link com.mongodb.reactivestreams.client.MongoCollection} or
+	 * {@link com.mongodb.reactivestreams.client.MongoDatabase} via eg.
+	 * {@link ReactiveMongoOperations#getCollection(String)} we leave responsibility for
+	 * {@link com.mongodb.session.ClientSession} again up to the caller.
+	 *
+	 * @param operations will never be {@literal null}.
+	 * @return never {@literal null}.
+	 */
+	Publisher<T> doInSession(ReactiveCouchbaseOperations operations);
+}
diff --git a/src/main/java/org/springframework/data/couchbase/core/ReactiveTemplateSupport.java b/src/main/java/org/springframework/data/couchbase/core/ReactiveTemplateSupport.java
index 5f897720..1313a646 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ReactiveTemplateSupport.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ReactiveTemplateSupport.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2021 the original author or authors
+ * Copyright 2021-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,22 +17,39 @@ package org.springframework.data.couchbase.core;
 
 import reactor.core.publisher.Mono;
 
+import org.springframework.data.couchbase.core.convert.translation.TranslationService;
 import org.springframework.data.couchbase.core.mapping.CouchbaseDocument;
-import org.springframework.data.couchbase.core.mapping.event.CouchbaseMappingEvent;
+import org.springframework.data.couchbase.repository.support.TransactionResultHolder;
+import org.springframework.data.couchbase.transaction.ReactiveCouchbaseResourceHolder;
 
+/**
+ * @author Michael Reiche
+ */
 public interface ReactiveTemplateSupport {
 
 	Mono<CouchbaseDocument> encodeEntity(Object entityToEncode);
 
-	<T> Mono<T> decodeEntity(String id, String source, long cas, Class<T> entityClass);
+	<T> Mono<T> decodeEntity(String id, String source, long cas, Class<T> entityClass, String scope, String collection,
+							 TransactionResultHolder txResultHolder);
+
+	<T> Mono<T> decodeEntity(String id, String source, long cas, Class<T> entityClass, String scope, String collection,
+			TransactionResultHolder txResultHolder, ReactiveCouchbaseResourceHolder holder);
 
-	<T> Mono<T> applyUpdatedCas(T entity, CouchbaseDocument converted, long cas);
+	<T> Mono<T> applyResult(T entity, CouchbaseDocument converted, Object id, Long cas,
+							TransactionResultHolder txResultHolder);
 
-	<T> Mono<T> applyUpdatedId(T entity, Object id);
+	<T> Mono<T> applyResult(T entity, CouchbaseDocument converted, Object id, Long cas,
+			TransactionResultHolder txResultHolder, ReactiveCouchbaseResourceHolder holder);
 
 	Long getCas(Object entity);
 
+	Object getId(Object entity);
+
 	String getJavaNameForEntity(Class<?> clazz);
 
-	void maybeEmitEvent(CouchbaseMappingEvent<?> event);
+	<T> Integer getTxResultHolder(T source);
+
+	// <T> Integer setTxResultHolder(T source);
+
+	TranslationService getTranslationService();
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/ReactiveUpsertByIdOperation.java b/src/main/java/org/springframework/data/couchbase/core/ReactiveUpsertByIdOperation.java
index 5ec888d1..b3045a25 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ReactiveUpsertByIdOperation.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ReactiveUpsertByIdOperation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -86,19 +86,32 @@ public interface ReactiveUpsertByIdOperation {
 		TerminatingUpsertById<T> withOptions(UpsertOptions options);
 	}
 
+	interface UpsertByIdWithDurability<T> extends UpsertByIdWithOptions<T>, WithDurability<T> {
+		@Override
+		UpsertByIdWithOptions<T> withDurability(DurabilityLevel durabilityLevel);
+
+		@Override
+		UpsertByIdWithOptions<T> withDurability(PersistTo persistTo, ReplicateTo replicateTo);
+	}
+
+	interface UpsertByIdWithExpiry<T> extends UpsertByIdWithDurability<T>, WithExpiry<T> {
+		@Override
+		UpsertByIdWithDurability<T> withExpiry(Duration expiry);
+	}
+
 	/**
 	 * Fluent method to specify the collection.
 	 *
 	 * @param <T> the entity type to use for the results.
 	 */
-	interface UpsertByIdInCollection<T> extends UpsertByIdWithOptions<T>, InCollection<Object> {
+	interface UpsertByIdInCollection<T> extends UpsertByIdWithExpiry<T>, InCollection<Object> {
 		/**
 		 * With a different collection
 		 *
 		 * @param collection the collection to use.
 		 */
 		@Override
-		UpsertByIdWithOptions<T> inCollection(String collection);
+		UpsertByIdWithExpiry<T> inCollection(String collection);
 	}
 
 	/**
@@ -116,25 +129,11 @@ public interface ReactiveUpsertByIdOperation {
 		UpsertByIdInCollection<T> inScope(String scope);
 	}
 
-	interface UpsertByIdWithDurability<T> extends UpsertByIdInScope<T>, WithDurability<T> {
-		@Override
-		UpsertByIdInCollection<T> withDurability(DurabilityLevel durabilityLevel);
-
-		@Override
-		UpsertByIdInCollection<T> withDurability(PersistTo persistTo, ReplicateTo replicateTo);
-
-	}
-
-	interface UpsertByIdWithExpiry<T> extends UpsertByIdWithDurability<T>, WithExpiry<T> {
-		@Override
-		UpsertByIdWithDurability<T> withExpiry(Duration expiry);
-	}
-
 	/**
 	 * Provides methods for constructing KV operations in a fluent way.
 	 *
 	 * @param <T> the entity type to upsert
 	 */
-	interface ReactiveUpsertById<T> extends UpsertByIdWithExpiry<T> {}
+	interface ReactiveUpsertById<T> extends UpsertByIdInScope<T> {}
 
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/ReactiveUpsertByIdOperationSupport.java b/src/main/java/org/springframework/data/couchbase/core/ReactiveUpsertByIdOperationSupport.java
index b2433e10..32949e2c 100644
--- a/src/main/java/org/springframework/data/couchbase/core/ReactiveUpsertByIdOperationSupport.java
+++ b/src/main/java/org/springframework/data/couchbase/core/ReactiveUpsertByIdOperationSupport.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -28,6 +28,7 @@ import org.springframework.data.couchbase.core.query.OptionsBuilder;
 import org.springframework.data.couchbase.core.support.PseudoArgs;
 import org.springframework.util.Assert;
 
+import com.couchbase.client.core.error.CouchbaseException;
 import com.couchbase.client.core.msg.kv.DurabilityLevel;
 import com.couchbase.client.java.kv.PersistTo;
 import com.couchbase.client.java.kv.ReplicateTo;
@@ -79,15 +80,19 @@ public class ReactiveUpsertByIdOperationSupport implements ReactiveUpsertByIdOpe
 
 		@Override
 		public Mono<T> one(T object) {
-			PseudoArgs<UpsertOptions> pArgs = new PseudoArgs(template, scope, collection, options, domainType);
+			PseudoArgs<UpsertOptions> pArgs = new PseudoArgs(template, scope, collection, options, null, domainType);
 			LOG.trace("upsertById {}", pArgs);
-			return Mono.just(object).flatMap(support::encodeEntity)
-					.flatMap(converted -> template.getCouchbaseClientFactory().withScope(pArgs.getScope())
-							.getCollection(pArgs.getCollection()).reactive()
+			Mono<ReactiveCouchbaseTemplate> tmpl = template.doGetTemplate();
+			Mono<T> reactiveEntity = TransactionalSupport.verifyNotInTransaction(template.doGetTemplate(), "upsertById")
+					.then(support.encodeEntity(object))
+					.flatMap(converted -> tmpl.flatMap(tp -> {
+						return tp.getCouchbaseClientFactory().withScope(pArgs.getScope())
+								.getCollection(pArgs.getCollection()).flatMap(collection -> collection.reactive()
 										.upsert(converted.getId(), converted.export(), buildUpsertOptions(pArgs.getOptions(), converted))
-							.flatMap(result -> support.applyUpdatedId(object, converted.getId())
-									.flatMap(updatedObject -> support.applyUpdatedCas(updatedObject, converted, result.cas()))))
-					.onErrorMap(throwable -> {
+										.flatMap(result -> support.applyResult(object, converted, converted.getId(), result.cas(), null)));
+					}));
+
+			return reactiveEntity.onErrorMap(throwable -> {
 				if (throwable instanceof RuntimeException) {
 					return template.potentiallyConvertRuntimeException((RuntimeException) throwable);
 				} else {
@@ -113,7 +118,7 @@ public class ReactiveUpsertByIdOperationSupport implements ReactiveUpsertByIdOpe
 		}
 
 		@Override
-		public UpsertByIdWithDurability<T> inCollection(final String collection) {
+		public UpsertByIdWithExpiry<T> inCollection(final String collection) {
 			return new ReactiveUpsertByIdSupport<>(template, domainType, scope, collection, options, persistTo, replicateTo,
 					durabilityLevel, expiry, support);
 		}
@@ -125,14 +130,14 @@ public class ReactiveUpsertByIdOperationSupport implements ReactiveUpsertByIdOpe
 		}
 
 		@Override
-		public UpsertByIdInCollection<T> withDurability(final DurabilityLevel durabilityLevel) {
+		public UpsertByIdInScope<T> withDurability(final DurabilityLevel durabilityLevel) {
 			Assert.notNull(durabilityLevel, "Durability Level must not be null.");
 			return new ReactiveUpsertByIdSupport<>(template, domainType, scope, collection, options, persistTo, replicateTo,
 					durabilityLevel, expiry, support);
 		}
 
 		@Override
-		public UpsertByIdInCollection<T> withDurability(final PersistTo persistTo, final ReplicateTo replicateTo) {
+		public UpsertByIdInScope<T> withDurability(final PersistTo persistTo, final ReplicateTo replicateTo) {
 			Assert.notNull(persistTo, "PersistTo must not be null.");
 			Assert.notNull(replicateTo, "ReplicateTo must not be null.");
 			return new ReactiveUpsertByIdSupport<>(template, domainType, scope, collection, options, persistTo, replicateTo,
diff --git a/src/main/java/org/springframework/data/couchbase/core/TemplateSupport.java b/src/main/java/org/springframework/data/couchbase/core/TemplateSupport.java
index bc42da3f..260d9041 100644
--- a/src/main/java/org/springframework/data/couchbase/core/TemplateSupport.java
+++ b/src/main/java/org/springframework/data/couchbase/core/TemplateSupport.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2021 the original author or authors
+ * Copyright 2021-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,22 +15,37 @@
  */
 package org.springframework.data.couchbase.core;
 
+import org.springframework.data.couchbase.core.convert.translation.TranslationService;
 import org.springframework.data.couchbase.core.mapping.CouchbaseDocument;
 import org.springframework.data.couchbase.core.mapping.event.CouchbaseMappingEvent;
+import org.springframework.data.couchbase.repository.support.TransactionResultHolder;
+import org.springframework.data.couchbase.transaction.ReactiveCouchbaseResourceHolder;
 
+/**
+ *
+ * @author Michael Reiche
+ */
 public interface TemplateSupport {
 
 	CouchbaseDocument encodeEntity(Object entityToEncode);
 
-	<T> T decodeEntity(String id, String source, long cas, Class<T> entityClass);
+	<T> T decodeEntity(String id, String source, long cas, Class<T> entityClass, String scope, String collection, TransactionResultHolder txResultHolder);
+
+	<T> T decodeEntity(String id, String source, long cas, Class<T> entityClass, String scope, String collection, TransactionResultHolder txResultHolder, ReactiveCouchbaseResourceHolder holder);
 
-	<T> T applyUpdatedCas(T entity, CouchbaseDocument converted, long cas);
+	<T> T applyResult(T entity, CouchbaseDocument converted, Object id, long cas, TransactionResultHolder txResultHolder);
 
-	<T> T applyUpdatedId(T entity, Object id);
+	<T> T applyResult(T entity, CouchbaseDocument converted, Object id, long cas, TransactionResultHolder txResultHolder, ReactiveCouchbaseResourceHolder holder);
 
-	long getCas(Object entity);
+	Long getCas(Object entity);
+
+	Object getId(Object entity);
 
 	String getJavaNameForEntity(Class<?> clazz);
 
 	void maybeEmitEvent(CouchbaseMappingEvent<?> event);
+
+	<T> Integer getTxResultHolder(T source);
+
+	TranslationService getTranslationService();
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/TransactionalSupport.java b/src/main/java/org/springframework/data/couchbase/core/TransactionalSupport.java
new file mode 100644
index 00000000..37d5c22d
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/core/TransactionalSupport.java
@@ -0,0 +1,95 @@
+package org.springframework.data.couchbase.core;
+
+import com.couchbase.client.core.error.CasMismatchException;
+import com.couchbase.client.core.error.transaction.TransactionOperationFailedException;
+import com.couchbase.client.core.transaction.CoreTransactionAttemptContext;
+import reactor.core.publisher.Mono;
+
+import java.lang.reflect.Method;
+import java.util.function.Function;
+
+import org.springframework.data.couchbase.core.mapping.CouchbaseDocument;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
+import org.springframework.lang.Nullable;
+
+import com.couchbase.client.core.annotation.Stability;
+import com.couchbase.client.java.ReactiveCollection;
+
+@Stability.Internal
+class TransactionalSupportHelper {
+    public final CouchbaseDocument converted;
+    public final Long cas;
+    public final ReactiveCollection collection;
+    public final @Nullable CoreTransactionAttemptContext ctx;
+
+    public TransactionalSupportHelper(CouchbaseDocument doc, Long cas, ReactiveCollection collection,
+                                      @Nullable CoreTransactionAttemptContext ctx) {
+        this.converted = doc;
+        this.cas = cas;
+        this.collection = collection;
+        this.ctx = ctx;
+    }
+}
+
+/**
+ * Checks if this operation is being run inside a transaction, and calls a non-transactional or transactional callback
+ * as appropriate.
+ */
+@Stability.Internal
+public class TransactionalSupport {
+    public static <T> Mono<T> one(Mono<ReactiveCouchbaseTemplate> tmpl, CouchbaseTransactionalOperator transactionalOperator,
+                                  String scopeName, String collectionName, ReactiveTemplateSupport support, T object,
+                                  Function<TransactionalSupportHelper, Mono<T>> nonTransactional, Function<TransactionalSupportHelper, Mono<T>> transactional) {
+        return tmpl.flatMap(template -> template.getCouchbaseClientFactory().withScope(scopeName)
+                .getCollection(collectionName).flatMap(collection -> support.encodeEntity(object)
+                        .flatMap(converted -> tmpl.flatMap(tp -> tp.getCouchbaseClientFactory().getTransactionResources(null).flatMap(s -> {
+                            TransactionalSupportHelper gsh = new TransactionalSupportHelper(converted, support.getCas(object),
+                                    collection.reactive(), s.getCore() != null ? s.getCore()
+                                    : (transactionalOperator != null ? transactionalOperator.getAttemptContext() : null));
+                            if (gsh.ctx == null) {
+                                System.err.println("non-tx");
+                                return nonTransactional.apply(gsh);
+                            } else {
+                                System.err.println("tx");
+                                return transactional.apply(gsh);
+                            }
+                        })).onErrorMap(throwable -> {
+                            if (throwable instanceof RuntimeException) {
+                                return template.potentiallyConvertRuntimeException((RuntimeException) throwable);
+                            } else {
+                                return throwable;
+                            }
+                        }))));
+    }
+
+    public static Mono<Void> verifyNotInTransaction(Mono<ReactiveCouchbaseTemplate> tmpl, String methodName) {
+        return tmpl.flatMap(tp -> tp.getCouchbaseClientFactory().getTransactionResources(null)
+                .flatMap(s -> {
+                    if (s.hasActiveTransaction()) {
+                        return Mono.error(new IllegalArgumentException(methodName + "can not be used inside a transaction"));
+                    }
+                    else {
+                        return Mono.empty();
+                    }
+                }));
+    }
+
+    public static RuntimeException retryTransactionOnCasMismatch(CoreTransactionAttemptContext ctx, long cas1, long cas2) {
+        try {
+            ctx.logger().info(ctx.attemptId(), "Spring CAS mismatch %s != %s, retrying transaction", cas1, cas2);
+
+            // todo gpx expose this in SDK
+            Method method = CoreTransactionAttemptContext.class.getDeclaredMethod("operationFailed", TransactionOperationFailedException.class);
+            method.setAccessible(true);
+            TransactionOperationFailedException err = TransactionOperationFailedException.Builder.createError()
+                    .retryTransaction()
+                    .cause(new CasMismatchException(null))
+                    .build();
+            method.invoke(ctx, err);
+            return err;
+        } catch (Throwable err) {
+            return new RuntimeException(err);
+        }
+
+    }
+}
diff --git a/src/main/java/org/springframework/data/couchbase/core/convert/AbstractCouchbaseConverter.java b/src/main/java/org/springframework/data/couchbase/core/convert/AbstractCouchbaseConverter.java
index 0e70fb47..e216779f 100644
--- a/src/main/java/org/springframework/data/couchbase/core/convert/AbstractCouchbaseConverter.java
+++ b/src/main/java/org/springframework/data/couchbase/core/convert/AbstractCouchbaseConverter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -22,7 +22,7 @@ import org.springframework.beans.factory.InitializingBean;
 import org.springframework.core.convert.ConversionService;
 import org.springframework.core.convert.support.GenericConversionService;
 import org.springframework.data.convert.CustomConversions;
-import org.springframework.data.convert.EntityInstantiators;
+import org.springframework.data.mapping.model.EntityInstantiators;
 
 /**
  * An abstract {@link CouchbaseConverter} that provides the basics for the {@link MappingCouchbaseConverter}.
diff --git a/src/main/java/org/springframework/data/couchbase/core/convert/CouchbaseCustomConversions.java b/src/main/java/org/springframework/data/couchbase/core/convert/CouchbaseCustomConversions.java
index bfffbe51..ba265d4e 100644
--- a/src/main/java/org/springframework/data/couchbase/core/convert/CouchbaseCustomConversions.java
+++ b/src/main/java/org/springframework/data/couchbase/core/convert/CouchbaseCustomConversions.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2021 the original author or authors.
+ * Copyright 2017-2022 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -24,11 +24,9 @@ import org.springframework.data.mapping.model.SimpleTypeHolder;
 
 /**
  * Value object to capture custom conversion.
- * <p/>
  * <p>
  * Types that can be mapped directly onto JSON are considered simple ones, because they neither need deeper inspection
  * nor nested conversion.
- * </p>
  *
  * @author Michael Nitschinger
  * @author Oliver Gierke
diff --git a/src/main/java/org/springframework/data/couchbase/core/convert/CouchbaseJsr310Converters.java b/src/main/java/org/springframework/data/couchbase/core/convert/CouchbaseJsr310Converters.java
index e001f33f..ead6f1ae 100644
--- a/src/main/java/org/springframework/data/couchbase/core/convert/CouchbaseJsr310Converters.java
+++ b/src/main/java/org/springframework/data/couchbase/core/convert/CouchbaseJsr310Converters.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2020 the original author or authors.
+ * Copyright 2017-2022 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -27,6 +27,7 @@ import java.time.LocalDateTime;
 import java.time.LocalTime;
 import java.time.Period;
 import java.time.ZoneId;
+import java.time.ZonedDateTime;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Date;
@@ -71,6 +72,9 @@ public final class CouchbaseJsr310Converters {
 		converters.add(StringToDurationConverter.INSTANCE);
 		converters.add(PeriodToStringConverter.INSTANCE);
 		converters.add(StringToPeriodConverter.INSTANCE);
+		converters.add(ZonedDateTimeToLongConverter.INSTANCE);
+		converters.add(NumberToZonedDateTimeConverter.INSTANCE);
+
 		return converters;
 	}
 
@@ -99,6 +103,31 @@ public final class CouchbaseJsr310Converters {
 		}
 	}
 
+	@ReadingConverter
+	public enum NumberToZonedDateTimeConverter implements Converter<Number, ZonedDateTime> {
+
+		INSTANCE;
+
+		@Override
+		public ZonedDateTime convert(Number source) {
+			return source == null ? null
+					: ZonedDateTime.ofInstant(DateConverters.SerializedObjectToDateConverter.INSTANCE.convert(source).toInstant(),
+					systemDefault());
+		}
+	}
+
+	@WritingConverter
+	public enum ZonedDateTimeToLongConverter implements Converter<ZonedDateTime, Long> {
+
+		INSTANCE;
+
+		@Override
+		public Long convert(ZonedDateTime source) {
+			return source == null ? null
+					: DateConverters.DateToLongConverter.INSTANCE.convert(Date.from(source.toInstant()));
+		}
+	}
+
 	@ReadingConverter
 	public enum NumberToLocalDateConverter implements Converter<Number, LocalDate> {
 
diff --git a/src/main/java/org/springframework/data/couchbase/core/convert/CustomConversions.java b/src/main/java/org/springframework/data/couchbase/core/convert/CustomConversions.java
index b68dc4f9..8b19a21a 100644
--- a/src/main/java/org/springframework/data/couchbase/core/convert/CustomConversions.java
+++ b/src/main/java/org/springframework/data/couchbase/core/convert/CustomConversions.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2020 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,11 +20,9 @@ import java.util.List;
 
 /**
  * Value object to capture custom conversion.
- * <p/>
  * <p>
  * Types that can be mapped directly onto JSON are considered simple ones, because they neither need deeper inspection
  * nor nested conversion.
- * </p>
  *
  * @author Michael Nitschinger
  * @author Oliver Gierke
diff --git a/src/main/java/org/springframework/data/couchbase/core/convert/MappingCouchbaseConverter.java b/src/main/java/org/springframework/data/couchbase/core/convert/MappingCouchbaseConverter.java
index 42156020..e6eec583 100644
--- a/src/main/java/org/springframework/data/couchbase/core/convert/MappingCouchbaseConverter.java
+++ b/src/main/java/org/springframework/data/couchbase/core/convert/MappingCouchbaseConverter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -36,7 +36,6 @@ import org.springframework.core.convert.ConversionService;
 import org.springframework.core.convert.support.DefaultConversionService;
 import org.springframework.data.annotation.Transient;
 import org.springframework.data.convert.CustomConversions;
-import org.springframework.data.convert.EntityInstantiator;
 import org.springframework.data.couchbase.core.mapping.CouchbaseDocument;
 import org.springframework.data.couchbase.core.mapping.CouchbaseList;
 import org.springframework.data.couchbase.core.mapping.CouchbaseMappingContext;
@@ -48,18 +47,20 @@ import org.springframework.data.couchbase.core.mapping.id.IdAttribute;
 import org.springframework.data.couchbase.core.mapping.id.IdPrefix;
 import org.springframework.data.couchbase.core.mapping.id.IdSuffix;
 import org.springframework.data.couchbase.core.query.N1qlJoin;
+import org.springframework.data.couchbase.repository.TransactionResult;
 import org.springframework.data.mapping.Alias;
 import org.springframework.data.mapping.Association;
 import org.springframework.data.mapping.AssociationHandler;
 import org.springframework.data.mapping.MappingException;
+import org.springframework.data.mapping.Parameter;
 import org.springframework.data.mapping.PersistentEntity;
 import org.springframework.data.mapping.PersistentPropertyAccessor;
-import org.springframework.data.mapping.PreferredConstructor.Parameter;
 import org.springframework.data.mapping.PropertyHandler;
 import org.springframework.data.mapping.callback.EntityCallbacks;
 import org.springframework.data.mapping.context.MappingContext;
 import org.springframework.data.mapping.model.ConvertingPropertyAccessor;
 import org.springframework.data.mapping.model.DefaultSpELExpressionEvaluator;
+import org.springframework.data.mapping.model.EntityInstantiator;
 import org.springframework.data.mapping.model.ParameterValueProvider;
 import org.springframework.data.mapping.model.PersistentEntityParameterValueProvider;
 import org.springframework.data.mapping.model.PropertyValueProvider;
@@ -268,6 +269,9 @@ public class MappingCouchbaseConverter extends AbstractCouchbaseConverter implem
 		entity.doWithProperties(new PropertyHandler<CouchbasePersistentProperty>() {
 			@Override
 			public void doWithPersistentProperty(final CouchbasePersistentProperty prop) {
+				if (prop.isAnnotationPresent(TransactionResult.class)) {
+					return;
+				}
 				if (!doesPropertyExistInSource(prop) || entity.isConstructorArgument(prop) || isIdConstructionProperty(prop)
 						|| prop.isAnnotationPresent(N1qlJoin.class)) {
 					return;
@@ -510,6 +514,10 @@ public class MappingCouchbaseConverter extends AbstractCouchbaseConverter implem
 		entity.doWithProperties(new PropertyHandler<CouchbasePersistentProperty>() {
 			@Override
 			public void doWithPersistentProperty(final CouchbasePersistentProperty prop) {
+				if (prop.isAnnotationPresent(TransactionResult.class)) {
+					return;
+				}
+
 				if (prop.equals(idProperty) || (versionProperty != null && prop.equals(versionProperty))) {
 					return;
 				} else if (prop.isAnnotationPresent(N1qlJoin.class)) {
@@ -723,7 +731,6 @@ public class MappingCouchbaseConverter extends AbstractCouchbaseConverter implem
 				target.put(writeCollectionInternal(asCollection(element), new CouchbaseList(conversions.getSimpleTypeHolder()),
 						componentType));
 			} else {
-
 				CouchbaseDocument embeddedDoc = new CouchbaseDocument();
 				writeInternal(element, embeddedDoc, componentType, false);
 				target.put(embeddedDoc);
@@ -816,7 +823,6 @@ public class MappingCouchbaseConverter extends AbstractCouchbaseConverter implem
 	/**
 	 * COPIED Set the {@link EntityCallbacks} instance to use when invoking
 	 * {@link org.springframework.data.mapping.callback.EntityCallback callbacks} like the {@link AfterConvertCallback}.
-	 * <p/>
 	 * Overrides potentially existing {@link EntityCallbacks}.
 	 *
 	 * @param entityCallbacks must not be {@literal null}.
diff --git a/src/main/java/org/springframework/data/couchbase/core/convert/join/N1qlJoinResolver.java b/src/main/java/org/springframework/data/couchbase/core/convert/join/N1qlJoinResolver.java
index 6044a2a4..9ccd40fe 100644
--- a/src/main/java/org/springframework/data/couchbase/core/convert/join/N1qlJoinResolver.java
+++ b/src/main/java/org/springframework/data/couchbase/core/convert/join/N1qlJoinResolver.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2018-2021 the original author or authors
+ * Copyright 2018-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,9 +16,12 @@
 
 package org.springframework.data.couchbase.core.convert.join;
 
+import static org.springframework.data.couchbase.core.query.N1QLExpression.i;
+import static org.springframework.data.couchbase.core.query.N1QLExpression.x;
 import static org.springframework.data.couchbase.core.support.TemplateUtils.SELECT_CAS;
 import static org.springframework.data.couchbase.core.support.TemplateUtils.SELECT_ID;
 
+import java.lang.reflect.AnnotatedElement;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.util.List;
@@ -33,13 +36,17 @@ import org.springframework.data.couchbase.core.query.HashSide;
 import org.springframework.data.couchbase.core.query.N1QLExpression;
 import org.springframework.data.couchbase.core.query.N1QLQuery;
 import org.springframework.data.couchbase.core.query.N1qlJoin;
+import org.springframework.data.couchbase.core.query.OptionsBuilder;
 import org.springframework.data.couchbase.core.query.Query;
+import org.springframework.data.couchbase.repository.Collection;
+import org.springframework.data.couchbase.repository.Scope;
 import org.springframework.data.couchbase.repository.query.StringBasedN1qlQueryParser;
 import org.springframework.data.mapping.PropertyHandler;
 import org.springframework.data.mapping.model.ConvertingPropertyAccessor;
 import org.springframework.data.util.TypeInformation;
 import org.springframework.util.Assert;
 
+import com.couchbase.client.core.io.CollectionIdentifier;
 import com.couchbase.client.java.query.QueryOptions;
 
 /**
@@ -50,7 +57,7 @@ import com.couchbase.client.java.query.QueryOptions;
 public class N1qlJoinResolver {
 	private static final Logger LOGGER = LoggerFactory.getLogger(N1qlJoinResolver.class);
 
-	public static String buildQuery(ReactiveCouchbaseTemplate template, String collectionName,
+	public static <L, R> String buildQuery(ReactiveCouchbaseTemplate template, String scope, String collection,
 			N1qlJoinResolverParameters parameters) {
 		String joinType = "JOIN";
 		String selectEntity = "SELECT META(rks).id AS " + SELECT_ID + ", META(rks).cas AS " + SELECT_CAS + ", (rks).* ";
@@ -61,14 +68,16 @@ public class N1qlJoinResolver {
 		}
 		String useLKS = useLKSBuilder.length() > 0 ? "USE " + useLKSBuilder.toString() + " " : "";
 
-		String from = "FROM `" + template.getBucketName() + "` lks " + useLKS + joinType + " `" + template.getBucketName()
-				+ "` rks";
+		KeySpacePair keySpacePair = getKeySpacePair(template.getBucketName(), scope, collection, parameters);
 
-		StringBasedN1qlQueryParser.N1qlSpelValues n1qlL = Query.getN1qlSpelValues(template, collectionName,
+		String from = "FROM " + keySpacePair.lhs.keyspace + " lks " + useLKS + joinType + " " + keySpacePair.rhs.keyspace
+				+ " rks";
+
+		StringBasedN1qlQueryParser.N1qlSpelValues n1qlL = Query.getN1qlSpelValues(template, keySpacePair.lhs.collection,
 				parameters.getEntityTypeInfo().getType(), parameters.getEntityTypeInfo().getType(), false, null, null);
 		String onLks = "lks." + n1qlL.filter;
 
-		StringBasedN1qlQueryParser.N1qlSpelValues n1qlR = Query.getN1qlSpelValues(template, collectionName,
+		StringBasedN1qlQueryParser.N1qlSpelValues n1qlR = Query.getN1qlSpelValues(template, keySpacePair.rhs.collection,
 				parameters.getAssociatedEntityTypeInfo().getType(), parameters.getAssociatedEntityTypeInfo().getType(), false,
 				null, null);
 		String onRks = "rks." + n1qlR.filter;
@@ -111,10 +120,92 @@ public class N1qlJoinResolver {
 		return statementSb.toString();
 	}
 
-	public static <R> List<R> doResolve(ReactiveCouchbaseTemplate template, String collectionName,
+	static KeySpacePair getKeySpacePair(String bucketName, String scope, String collection,
+			N1qlJoinResolverParameters parameters) {
+		Class<?> lhsClass = parameters.getEntityTypeInfo().getActualType().getType();
+		String lhScope = scope != null ? scope : getScope(lhsClass);
+		String lhCollection = collection != null ? collection : getCollection(lhsClass);
+		Class<?> rhsClass = parameters.getAssociatedEntityTypeInfo().getActualType().getType();
+		String rhScope = getScope(rhsClass);
+		String rhCollection = getCollection(rhsClass);
+		if (lhCollection != null && rhCollection != null) {
+			// they both have non-default collections
+			// It's possible that the scope for the lhs was set with an annotation on a repository method,
+			// the entity class or the repository class or a query option. Since there is no means to set
+			// the scope of the associated class by the method, repository class or query option (only
+			// the annotation) we assume that the (possibly) dynamic scope of the entity would be a better
+			// choice as it is logical to put collections to be joined in the same scope. Note that lhScope
+			// is used for both keyspaces.
+			return new KeySpacePair(lhCollection, x(i(bucketName) + "." + i(lhScope) + "." + i(lhCollection)), //
+					rhCollection, x(i(bucketName) + "." + i(lhScope) + "." + i(rhCollection)));
+		} else if (lhCollection != null && rhCollection == null) {
+			// the lhs has a collection (and therefore a scope as well), but the rhs does not have a collection.
+			// Use the lhScope and lhCollection for the entity. The rhs is just the bucket.
+			return new KeySpacePair(lhCollection, x(i(bucketName) + "." + i(lhScope) + "." + i(lhCollection)), //
+					null, i(bucketName));
+		} else if (lhCollection != null && rhCollection == null) {
+			// the lhs does not have a collection (or scope), but rhs does have a collection
+			// Using the same (default) scope for the rhs would mean specifying a
+			// non-default collection in a default scope - which is not allowed.
+			// So use the scope and collection from the associated class.
+			return new KeySpacePair(null, i(bucketName), //
+					rhCollection, x(i(bucketName) + "." + i(rhScope) + "." + i(rhCollection)));
+		} else { // neither have collections, just use the bucket.
+			return new KeySpacePair(null, i(bucketName), null, i(bucketName));
+		}
+	}
+
+	static class KeySpacePair {
+		KeySpaceInfo lhs;
+		KeySpaceInfo rhs;
+
+		public KeySpacePair(String lhsCollection, N1QLExpression lhsKeyspace, String rhsCollection,
+				N1QLExpression rhsKeyspace) {
+			this.lhs = new KeySpaceInfo(lhsCollection, lhsKeyspace);
+			this.rhs = new KeySpaceInfo(rhsCollection, rhsKeyspace);
+		}
+
+		static class KeySpaceInfo {
+			String collection;
+			N1QLExpression keyspace;
+
+			public KeySpaceInfo(String collection, N1QLExpression keyspace) {
+				this.collection = collection;
+				this.keyspace = keyspace;
+			}
+		}
+	}
+
+	/**
+	 * from CouchbaseQueryMethod.getCollection()
+	 * 
+	 * @param targetClass
+	 * @return
+	 */
+	static String getCollection(Class<?> targetClass) {
+		// Could try the repository method, then the targetClass, then the repository class, then the entity class
+		// but we don't have the repository method nor the repositoryMetdata at this point.
+		AnnotatedElement[] annotated = new AnnotatedElement[] { targetClass };
+		return OptionsBuilder.annotationString(Collection.class, CollectionIdentifier.DEFAULT_COLLECTION, annotated);
+	}
+
+	/**
+	 * from CouchbaseQueryMethod.getScope()
+	 * 
+	 * @param targetClass
+	 * @return
+	 */
+	static String getScope(Class<?> targetClass) {
+		// Could try the repository method, then the targetClass, then the repository class, then the entity class
+		// but we don't have the repository method nor the repositoryMetdata at this point.
+		AnnotatedElement[] annotated = new AnnotatedElement[] { targetClass };
+		return OptionsBuilder.annotationString(Scope.class, CollectionIdentifier.DEFAULT_SCOPE, annotated);
+	}
+
+	public static <R> List<R> doResolve(ReactiveCouchbaseTemplate template, String scopeName, String collectionName,
 			N1qlJoinResolverParameters parameters, Class<R> associatedEntityClass) {
 
-		String statement = buildQuery(template, collectionName, parameters);
+		String statement = buildQuery(template, scopeName, collectionName, parameters);
 
 		if (LOGGER.isDebugEnabled()) {
 			LOGGER.debug("Join query executed " + statement);
@@ -130,20 +221,24 @@ public class N1qlJoinResolver {
 	}
 
 	public static void handleProperties(CouchbasePersistentEntity<?> persistentEntity,
-			ConvertingPropertyAccessor<?> accessor, ReactiveCouchbaseTemplate template, String id) {
+			ConvertingPropertyAccessor<?> accessor, ReactiveCouchbaseTemplate template, String id, String scope,
+			String collection) {
 		persistentEntity.doWithProperties((PropertyHandler<CouchbasePersistentProperty>) prop -> {
 			if (prop.isAnnotationPresent(N1qlJoin.class)) {
 				N1qlJoin definition = prop.findAnnotation(N1qlJoin.class);
 				TypeInformation type = prop.getTypeInformation().getActualType();
 				Class clazz = type.getType();
 				N1qlJoinResolver.N1qlJoinResolverParameters parameters = new N1qlJoinResolver.N1qlJoinResolverParameters(
-						definition, id, persistentEntity.getTypeInformation(), type);
+						definition, id, persistentEntity.getTypeInformation(), type, scope, collection);
 				if (N1qlJoinResolver.isLazyJoin(definition)) {
 					N1qlJoinResolver.N1qlJoinProxy proxy = new N1qlJoinResolver.N1qlJoinProxy(template, parameters);
 					accessor.setProperty(prop,
 							java.lang.reflect.Proxy.newProxyInstance(List.class.getClassLoader(), new Class[] { List.class }, proxy));
 				} else {
-					accessor.setProperty(prop, N1qlJoinResolver.doResolve(template, null, parameters, clazz));
+					// clazz needs to be passes instead of just using
+					// parameters.associatedType.getTypeInformation().getActualType().getType
+					// to keep the compiler happy for the call template.findByQuery(associatedEntityClass)
+					accessor.setProperty(prop, N1qlJoinResolver.doResolve(template, scope, collection, parameters, clazz));
 				}
 			}
 		});
@@ -152,6 +247,7 @@ public class N1qlJoinResolver {
 	static public class N1qlJoinProxy implements InvocationHandler {
 		private final ReactiveCouchbaseTemplate reactiveTemplate;
 		private final String collectionName = null;
+		private final String scopeName = null;
 		private final N1qlJoinResolverParameters params;
 		private List<?> resolved = null;
 
@@ -163,8 +259,8 @@ public class N1qlJoinResolver {
 		@Override
 		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
 			if (this.resolved == null) {
-				this.resolved = doResolve(this.reactiveTemplate, collectionName, this.params,
-						this.params.associatedEntityTypeInfo.getType());
+				this.resolved = doResolve(this.reactiveTemplate, this.params.getScopeName(), this.params.getCollectionName(),
+						this.params, this.params.associatedEntityTypeInfo.getType());
 			}
 			return method.invoke(this.resolved, args);
 		}
@@ -175,9 +271,11 @@ public class N1qlJoinResolver {
 		private String lksId;
 		private TypeInformation<?> entityTypeInfo;
 		private TypeInformation<?> associatedEntityTypeInfo;
+		private String scopeName;
+		private String collectionName;
 
 		public N1qlJoinResolverParameters(N1qlJoin joinDefinition, String lksId, TypeInformation<?> entityTypeInfo,
-				TypeInformation<?> associatedEntityTypeInfo) {
+				TypeInformation<?> associatedEntityTypeInfo, String scopeName, String collectionName) {
 			Assert.notNull(joinDefinition, "The join definition is required");
 			Assert.notNull(entityTypeInfo, "The entity type information is required");
 			Assert.notNull(associatedEntityTypeInfo, "The associated entity type information is required");
@@ -186,6 +284,8 @@ public class N1qlJoinResolver {
 			this.lksId = lksId;
 			this.entityTypeInfo = entityTypeInfo;
 			this.associatedEntityTypeInfo = associatedEntityTypeInfo;
+			this.scopeName = scopeName;
+			this.collectionName = collectionName;
 		}
 
 		public N1qlJoin getJoinDefinition() {
@@ -203,5 +303,13 @@ public class N1qlJoinResolver {
 		public TypeInformation getAssociatedEntityTypeInfo() {
 			return associatedEntityTypeInfo;
 		}
+
+		public String getScopeName() {
+			return scopeName;
+		}
+
+		public String getCollectionName() {
+			return collectionName;
+		}
 	}
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/mapping/BasicCouchbasePersistentEntity.java b/src/main/java/org/springframework/data/couchbase/core/mapping/BasicCouchbasePersistentEntity.java
index af9ed294..00c92153 100644
--- a/src/main/java/org/springframework/data/couchbase/core/mapping/BasicCouchbasePersistentEntity.java
+++ b/src/main/java/org/springframework/data/couchbase/core/mapping/BasicCouchbasePersistentEntity.java
@@ -24,6 +24,7 @@ import java.util.concurrent.TimeUnit;
 import org.springframework.context.EnvironmentAware;
 import org.springframework.core.annotation.AnnotatedElementUtils;
 import org.springframework.core.env.Environment;
+import org.springframework.data.couchbase.repository.TransactionResult;
 import org.springframework.data.mapping.MappingException;
 import org.springframework.data.mapping.model.BasicPersistentEntity;
 import org.springframework.data.util.TypeInformation;
@@ -40,6 +41,7 @@ public class BasicCouchbasePersistentEntity<T> extends BasicPersistentEntity<T,
 		implements CouchbasePersistentEntity<T>, EnvironmentAware {
 
 	private Environment environment;
+	private CouchbasePersistentProperty transactionResult;
 
 	/**
 	 * Create a new entity.
@@ -69,6 +71,9 @@ public class BasicCouchbasePersistentEntity<T> extends BasicPersistentEntity<T,
 	@Override
 	protected CouchbasePersistentProperty returnPropertyIfBetterIdPropertyCandidateOrNull(
 			CouchbasePersistentProperty property) {
+
+		transactionResult = property.findAnnotation(TransactionResult.class) != null ? property : transactionResult;
+
 		if (!property.isIdProperty()) {
 			return null;
 		}
@@ -164,4 +169,9 @@ public class BasicCouchbasePersistentEntity<T> extends BasicPersistentEntity<T,
 		return annotation == null ? false : annotation.touchOnRead() && getExpiry() > 0;
 	}
 
+	@Override
+	public CouchbasePersistentProperty transactionResultProperty() {
+		return transactionResult;
+	}
+
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/mapping/BasicCouchbasePersistentProperty.java b/src/main/java/org/springframework/data/couchbase/core/mapping/BasicCouchbasePersistentProperty.java
index d5e61466..53c2561e 100644
--- a/src/main/java/org/springframework/data/couchbase/core/mapping/BasicCouchbasePersistentProperty.java
+++ b/src/main/java/org/springframework/data/couchbase/core/mapping/BasicCouchbasePersistentProperty.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -32,11 +32,9 @@ import com.couchbase.client.core.deps.com.fasterxml.jackson.annotation.JsonPrope
 
 /**
  * Implements annotated property representations of a given {@link Field} instance.
- * <p/>
  * <p>
  * This object is used to gather information out of properties on objects that need to be persisted. For example, it
  * supports overriding of the actual property name by providing custom annotations.
- * </p>
  *
  * @author Michael Nitschinger
  * @author Mark Paluch
@@ -71,7 +69,7 @@ public class BasicCouchbasePersistentProperty extends AnnotationBasedPersistentP
 
 	/**
 	 * Returns the field name of the property.
-	 * <p/>
+	 * <p>
 	 * The field name can be different from the actual property name by using a custom annotation.
 	 */
 	@Override
@@ -79,6 +77,10 @@ public class BasicCouchbasePersistentProperty extends AnnotationBasedPersistentP
 		if (fieldName != null) {
 			return fieldName;
 		}
+		if (getField() == null) { // use the name of the property - instead of getting an NPE trying to use field
+			return fieldName = getName();
+		}
+
 		Field annotationField = getField().getAnnotation(Field.class);
 
 		if (annotationField != null) {
diff --git a/src/main/java/org/springframework/data/couchbase/core/mapping/CouchbaseDocument.java b/src/main/java/org/springframework/data/couchbase/core/mapping/CouchbaseDocument.java
index 26a6834d..02566f76 100644
--- a/src/main/java/org/springframework/data/couchbase/core/mapping/CouchbaseDocument.java
+++ b/src/main/java/org/springframework/data/couchbase/core/mapping/CouchbaseDocument.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2020 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,23 +18,19 @@ package org.springframework.data.couchbase.core.mapping;
 
 import com.couchbase.client.java.json.JsonObject;
 
-import java.util.HashMap;
+import java.util.TreeMap;
 import java.util.Map;
 
 /**
  * A {@link CouchbaseDocument} is an abstract representation of a document stored inside Couchbase Server.
- * <p/>
  * <p>
- * It acts like a {@link HashMap}, but only allows those types to be written that are supported by the underlying
+ * It acts like a {@link TreeMap}, but only allows those types to be written that are supported by the underlying
  * storage format, which is currently JSON. Note that JSON conversion is not happening here, but performed at a
  * different stage based on the payload stored in the {@link CouchbaseDocument}.
- * </p>
- * <p/>
  * <p>
  * In addition to the actual content, meta data is also stored. This especially refers to the document ID and its
  * expiration time. Note that this information is not mandatory, since documents can be nested and therefore only the
  * topmost document most likely has an ID.
- * </p>
  *
  * @author Michael Nitschinger
  */
@@ -60,6 +56,9 @@ public class CouchbaseDocument implements CouchbaseStorable {
 	 */
 	private int expiration;
 
+	// todo gp
+	public long version;
+
 	/**
 	 * Creates a completely empty {@link CouchbaseDocument}.
 	 */
@@ -85,7 +84,7 @@ public class CouchbaseDocument implements CouchbaseStorable {
 	public CouchbaseDocument(final String id, final int expiration) {
 		this.id = id;
 		this.expiration = expiration;
-		content = new HashMap<>();
+		content = new TreeMap<>();
 	}
 
 	/**
@@ -114,13 +113,13 @@ public class CouchbaseDocument implements CouchbaseStorable {
 
 	/**
 	 * Returns the current payload, including all recursive elements.
-	 * <p/>
+	 * <p>
 	 * It either returns the raw results or makes sure that the recusrive elements are also exported properly.
 	 *
 	 * @return
 	 */
-	public final HashMap<String, Object> export() {
-		HashMap<String, Object> toExport = new HashMap<String, Object>(content);
+	public final TreeMap<String, Object> export() {
+		TreeMap<String, Object> toExport = new TreeMap<String, Object>(content);
 		for (Map.Entry<String, Object> entry : content.entrySet()) {
 			if (entry.getValue() instanceof CouchbaseDocument) {
 				toExport.put(entry.getKey(), ((CouchbaseDocument) entry.getValue()).export());
@@ -187,10 +186,8 @@ public class CouchbaseDocument implements CouchbaseStorable {
 
 	/**
 	 * Returns the underlying payload.
-	 * <p/>
 	 * <p>
 	 * Note that unlike {@link #export()}, the nested objects are not converted, so the "raw" map is returned.
-	 * </p>
 	 *
 	 * @return the underlying payload.
 	 */
@@ -221,7 +218,7 @@ public class CouchbaseDocument implements CouchbaseStorable {
 
 	/**
 	 * Returns the expiration time of the document.
-	 * <p/>
+	 * <p>
 	 * If the expiration time is 0, then the document will be persisted until deleted manually ("forever").
 	 *
 	 * @return the expiration time of the document.
@@ -232,9 +229,9 @@ public class CouchbaseDocument implements CouchbaseStorable {
 
 	/**
 	 * Set the expiration time of the document.
-	 * <p/>
+	 * <p>
 	 * If the expiration time is 0, then the document will be persisted until deleted manually ("forever").
-	 * <p/>
+	 * <p>
 	 * Expiration should be expressed as seconds if <= 30 days (30 x 24 x 60 x 60 seconds), or as an expiry date (UTC,
 	 * UNIX time ie. seconds form the Epoch) if > 30 days.
 	 *
@@ -268,10 +265,8 @@ public class CouchbaseDocument implements CouchbaseStorable {
 
 	/**
 	 * Verifies that only values of a certain and supported type can be stored.
-	 * <p/>
 	 * <p>
 	 * If this is not the case, a {@link IllegalArgumentException} is thrown.
-	 * </p>
 	 *
 	 * @param value the object to verify its type.
 	 */
diff --git a/src/main/java/org/springframework/data/couchbase/core/mapping/CouchbaseList.java b/src/main/java/org/springframework/data/couchbase/core/mapping/CouchbaseList.java
index 4a1b90e9..d7cd4b8a 100644
--- a/src/main/java/org/springframework/data/couchbase/core/mapping/CouchbaseList.java
+++ b/src/main/java/org/springframework/data/couchbase/core/mapping/CouchbaseList.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2020 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -25,11 +25,9 @@ import org.springframework.data.mapping.model.SimpleTypeHolder;
 
 /**
  * A {@link CouchbaseList} is an abstract list that represents an array stored in a (most of the times JSON) document.
- * <p/>
  * <p>
  * This {@link CouchbaseList} is part of the potentially nested structure inside one or more {@link CouchbaseDocument}s.
  * It can also contain them recursively, depending on how the document is modeled.
- * </p>
  */
 public class CouchbaseList implements CouchbaseStorable {
 
@@ -145,7 +143,7 @@ public class CouchbaseList implements CouchbaseStorable {
 
 	/**
 	 * Returns the current payload, including all recursive elements.
-	 * <p/>
+	 * <p>
 	 * It either returns the raw results or makes sure that the recusrive elements are also exported properly.
 	 *
 	 * @return
@@ -188,10 +186,8 @@ public class CouchbaseList implements CouchbaseStorable {
 
 	/**
 	 * Verifies that only values of a certain and supported type can be stored.
-	 * <p/>
 	 * <p>
 	 * If this is not the case, a {@link IllegalArgumentException} is thrown.
-	 * </p>
 	 *
 	 * @param value the object to verify its type.
 	 */
diff --git a/src/main/java/org/springframework/data/couchbase/core/mapping/CouchbasePersistentEntity.java b/src/main/java/org/springframework/data/couchbase/core/mapping/CouchbasePersistentEntity.java
index 8d236d32..c73a1951 100644
--- a/src/main/java/org/springframework/data/couchbase/core/mapping/CouchbasePersistentEntity.java
+++ b/src/main/java/org/springframework/data/couchbase/core/mapping/CouchbasePersistentEntity.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -34,7 +34,7 @@ public interface CouchbasePersistentEntity<T> extends PersistentEntity<T, Couchb
 
 	/**
 	 * Returns the expiration time of the entity.
-	 * <p/>
+	 * <p>
 	 * The Couchbase format for expiration time is: - for TTL < 31 days (<= 30 * 24 * 60 * 60): expressed as a TTL in
 	 * seconds - for TTL > 30 days: expressed as Unix UTC time of expiry (number of SECONDS since the Epoch)
 	 *
@@ -45,7 +45,7 @@ public interface CouchbasePersistentEntity<T> extends PersistentEntity<T, Couchb
 
 	/**
 	 * Returns the expiration time of the entity.
-	 * <p/>
+	 * <p>
 	 * The Couchbase format for expiration time is: - for TTL < 31 days (<= 30 * 24 * 60 * 60): expressed as a TTL in
 	 * seconds - for TTL > 30 days: expressed as Unix UTC time of expiry (number of SECONDS since the Epoch)
 	 *
@@ -61,4 +61,11 @@ public interface CouchbasePersistentEntity<T> extends PersistentEntity<T, Couchb
 	 */
 	boolean isTouchOnRead();
 
+	/**
+	 * The property than can hold a transaction result
+	 *
+	 * @return The property than can hold a transaction result
+	 */
+	CouchbasePersistentProperty transactionResultProperty();
+
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/mapping/CouchbasePersistentProperty.java b/src/main/java/org/springframework/data/couchbase/core/mapping/CouchbasePersistentProperty.java
index 7525f6c4..dba19b16 100644
--- a/src/main/java/org/springframework/data/couchbase/core/mapping/CouchbasePersistentProperty.java
+++ b/src/main/java/org/springframework/data/couchbase/core/mapping/CouchbasePersistentProperty.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -27,7 +27,7 @@ public interface CouchbasePersistentProperty extends PersistentProperty<Couchbas
 
 	/**
 	 * Returns the field name of the property.
-	 * <p/>
+	 * <p>
 	 * The field name can be different from the actual property name by using a custom annotation.
 	 */
 	String getFieldName();
diff --git a/src/main/java/org/springframework/data/couchbase/core/mapping/CouchbaseStorable.java b/src/main/java/org/springframework/data/couchbase/core/mapping/CouchbaseStorable.java
index 965acbbb..b4e5ae15 100644
--- a/src/main/java/org/springframework/data/couchbase/core/mapping/CouchbaseStorable.java
+++ b/src/main/java/org/springframework/data/couchbase/core/mapping/CouchbaseStorable.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2020 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,7 +18,7 @@ package org.springframework.data.couchbase.core.mapping;
 
 /**
  * Marker Interface to identify either a {@link CouchbaseDocument} or a {@link CouchbaseList}.
- * <p/>
+ * <p>
  * This interface will be extended in the future to refactor the needed infrastructure into the common interface.
  *
  * @author Michael Nitschinger
diff --git a/src/main/java/org/springframework/data/couchbase/core/mapping/event/ValidatingCouchbaseEventListener.java b/src/main/java/org/springframework/data/couchbase/core/mapping/event/ValidatingCouchbaseEventListener.java
index bdfffa57..33f9e12e 100644
--- a/src/main/java/org/springframework/data/couchbase/core/mapping/event/ValidatingCouchbaseEventListener.java
+++ b/src/main/java/org/springframework/data/couchbase/core/mapping/event/ValidatingCouchbaseEventListener.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2020 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
diff --git a/src/main/java/org/springframework/data/couchbase/core/query/N1qlSecondaryIndexed.java b/src/main/java/org/springframework/data/couchbase/core/query/N1qlSecondaryIndexed.java
index a4d1e403..50b9597f 100644
--- a/src/main/java/org/springframework/data/couchbase/core/query/N1qlSecondaryIndexed.java
+++ b/src/main/java/org/springframework/data/couchbase/core/query/N1qlSecondaryIndexed.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2020 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -26,10 +26,10 @@ import org.springframework.data.couchbase.repository.CouchbaseRepository;
 /**
  * This annotation is targeted at {@link CouchbaseRepository Repository} interfaces, indicating that the framework
  * should ensure a N1QL Secondary Index is present when the repository is instantiated.
- * <p/>
+ * <p>
  * Said index will relate to the "type" field (the one bearing type information) and restrict on documents that match
  * the repository's entity class.
- * <p/>
+ * <p>
  * Be sure to also use {@link N1qlPrimaryIndexed} to make sure the PRIMARY INDEX is there as well.
  *
  * @author Simon Baslé
diff --git a/src/main/java/org/springframework/data/couchbase/core/query/OptionsBuilder.java b/src/main/java/org/springframework/data/couchbase/core/query/OptionsBuilder.java
index 93073709..aacc2a4f 100644
--- a/src/main/java/org/springframework/data/couchbase/core/query/OptionsBuilder.java
+++ b/src/main/java/org/springframework/data/couchbase/core/query/OptionsBuilder.java
@@ -24,8 +24,10 @@ import java.lang.reflect.AnnotatedElement;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.time.Duration;
+import java.util.Map;
 import java.util.Optional;
 
+import com.couchbase.client.java.transactions.TransactionQueryOptions;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.springframework.core.annotation.AnnotatedElementUtils;
@@ -70,7 +72,7 @@ public class OptionsBuilder {
 		QueryScanConsistency metaQueryScanConsistency = meta.get(SCAN_CONSISTENCY) != null
 				? ((ScanConsistency) meta.get(SCAN_CONSISTENCY)).query()
 				: null;
-		QueryScanConsistency qsc = fromFirst(QueryScanConsistency.NOT_BOUNDED, getScanConsistency(optsJson),
+		QueryScanConsistency qsc = fromFirst(QueryScanConsistency.NOT_BOUNDED, query.getScanConsistency(), getScanConsistency(optsJson),
 				scanConsistency, metaQueryScanConsistency);
 		Duration timeout = fromFirst(Duration.ofSeconds(0), getTimeout(optsBuilt), meta.get(TIMEOUT));
 		RetryStrategy retryStrategy = fromFirst(null, getRetryStrategy(optsBuilt), meta.get(RETRY_STRATEGY));
@@ -90,6 +92,22 @@ public class OptionsBuilder {
 		return options;
 	}
 
+	public static TransactionQueryOptions buildTransactionQueryOptions(QueryOptions options) {
+
+		QueryOptions.Built built = options.build();
+		TransactionQueryOptions txOptions = TransactionQueryOptions.queryOptions();
+
+		JsonObject optsJson = getQueryOpts(built);
+		for (Map.Entry<String, Object> entry : optsJson.toMap().entrySet()) {
+			txOptions.raw(entry.getKey(), entry.getValue());
+		}
+
+		if (LOG.isTraceEnabled()) {
+			LOG.trace("query options: {}", optsJson);
+		}
+		return txOptions;
+	}
+
 	public static ExistsOptions buildExistsOptions(ExistsOptions options) {
 		options = options != null ? options : ExistsOptions.existsOptions();
 		return options;
@@ -423,4 +441,5 @@ public class OptionsBuilder {
 			AnnotatedElement[] elements) {
 		return annotationString(annotation, "value", defaultValue, elements);
 	}
+
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/query/Query.java b/src/main/java/org/springframework/data/couchbase/core/query/Query.java
index cfcbf7d8..391f6409 100644
--- a/src/main/java/org/springframework/data/couchbase/core/query/Query.java
+++ b/src/main/java/org/springframework/data/couchbase/core/query/Query.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -178,8 +178,7 @@ public class Query {
 		}
 		this.limit = pageable.getPageSize();
 		this.skip = pageable.getOffset();
-		if (!this.sort.equals(pageable.getSort()))
-			this.sort.and(pageable.getSort());
+		this.with(pageable.getSort());
 		return this;
 	}
 
@@ -383,7 +382,6 @@ public class Query {
 	 * This will find annotations included in composed annotations as well. Ideally
 	 * 
 	 * @param method representing the query.
-	 * @return the query with the annotations applied
 	 */
 	public void setMeta(CouchbaseQueryMethod method, Class<?> typeToRead) {
 		meta = OptionsBuilder.buildMeta(method, typeToRead);
diff --git a/src/main/java/org/springframework/data/couchbase/core/query/QueryCriteria.java b/src/main/java/org/springframework/data/couchbase/core/query/QueryCriteria.java
index 4b7da245..319fed4a 100644
--- a/src/main/java/org/springframework/data/couchbase/core/query/QueryCriteria.java
+++ b/src/main/java/org/springframework/data/couchbase/core/query/QueryCriteria.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,12 +18,16 @@ package org.springframework.data.couchbase.core.query;
 import static org.springframework.data.couchbase.core.query.N1QLExpression.x;
 
 import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
 import java.util.Formatter;
 import java.util.LinkedList;
 import java.util.List;
 
+import com.couchbase.client.core.error.CouchbaseException;
 import org.springframework.data.couchbase.core.convert.CouchbaseConverter;
 import org.springframework.lang.Nullable;
+import org.springframework.util.CollectionUtils;
 
 import com.couchbase.client.core.error.InvalidArgumentException;
 import com.couchbase.client.java.json.JsonArray;
@@ -278,18 +282,34 @@ public class QueryCriteria implements QueryCriteriaDefinition {
 
 	public QueryCriteria in(@Nullable Object... o) {
 		operator = "IN";
-		format = "%1$s in ( %3$s )";
-		// IN takes a single argument that is a list
+		format = "%1$s in %3$s";
+		value = new Object[1];
 		if (o.length > 0) {
 			if (o[0] instanceof JsonArray || o[0] instanceof List || o[0] instanceof Object[]) {
 				if (o.length != 1) {
 					throw new RuntimeException("IN cannot take multiple lists");
 				}
-				value = o;
+				if (o[0] instanceof Object[]) {
+					value[0] = o[0];
+				} else if (o[0] instanceof JsonArray) {
+					JsonArray ja = ((JsonArray) o[0]);
+					value[0] = ja.toList().toArray();
+				} else if (o[0] instanceof List) {
+					List l = ((List) o[0]);
+					value[0] = l.toArray();
+				}
 			} else {
-				value = new Object[1];
-				value[0] = o; // JsonArray.from(o);
+				// N1qlQueryCreatorTests.queryParametersArray()
+				// Query expected = (new Query()).addCriteria(where(i("firstname")).in("Oliver", "Charles"));
+				if (o instanceof Object[]) {
+					value[0] = o;
+				} else {
+					// see QueryCriteriaTests.testNestedNotIn() - if arg to notIn is not cast to Object
+					// notIn((Object) new String[] { "Alabama", "Florida" }));
+					throw new CouchbaseException("unhandled parameters "+o);
+				}
 			}
+
 		}
 		return this;
 	}
@@ -409,15 +429,13 @@ public class QueryCriteria implements QueryCriteriaDefinition {
 			if (paramIndexPtr[0] >= 0) {
 				JsonArray params = (JsonArray) parameters;
 				// from StringBasedN1qlQueryParser.getPositionalPlaceholderValues()
-				try {
-					params.add(convert(converter, value));
-				} catch (InvalidArgumentException iae) {
-					if (value instanceof Object[]) {
-						addAsArray(params, value, converter);
+
+				if (value instanceof Object[] || value instanceof Collection) {
+					addAsCollection(params, asCollection(value), converter);
 				} else {
-						throw iae;
-					}
+					params.add(convert(converter, value));
 				}
+
 				return "$" + (++paramIndexPtr[0]); // these are generated in order
 			} else {
 				JsonObject params = (JsonObject) parameters;
@@ -462,15 +480,27 @@ public class QueryCriteria implements QueryCriteriaDefinition {
 		return converter != null ? converter.convertForWriteIfNeeded(value) : value;
 	}
 
-	private void addAsArray(JsonArray posValues, Object o, CouchbaseConverter converter) {
-		Object[] array = (Object[]) o;
+	private void addAsCollection(JsonArray posValues, Collection collection, CouchbaseConverter converter) {
 		JsonArray ja = JsonValue.ja();
-		for (Object e : array) {
+		for (Object e : collection) {
 			ja.add(String.valueOf(convert(converter, e)));
 		}
 		posValues.add(ja);
 	}
 
+	/**
+	 * Returns a collection from the given source object. From MappingCouchbaseConverter.
+	 *
+	 * @param source the source object.
+	 * @return the target collection.
+	 */
+	private static Collection<?> asCollection(final Object source) {
+		if (source instanceof Collection) {
+			return (Collection<?>) source;
+		}
+		return source.getClass().isArray() ? CollectionUtils.arrayToList(source) : Collections.singleton(source);
+	}
+
 	private String maybeBackTic(String value) {
 		if (value == null || (value.startsWith("`") && value.endsWith("`"))) {
 			return value;
diff --git a/src/main/java/org/springframework/data/couchbase/core/query/StringQuery.java b/src/main/java/org/springframework/data/couchbase/core/query/StringQuery.java
index 47248e62..52ed05d1 100644
--- a/src/main/java/org/springframework/data/couchbase/core/query/StringQuery.java
+++ b/src/main/java/org/springframework/data/couchbase/core/query/StringQuery.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2020 the original author or authors.
+ * Copyright 2017-2022 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -28,7 +28,7 @@ import com.couchbase.client.java.json.JsonValue;
  * 
  * <pre>
  * &#64;Query("#{#n1ql.selectEntity} where #{#n1ql.filter} and firstname = $1 and lastname = $2")
- * List<User> getByFirstnameAndLastname(String firstname, String lastname);
+ * List&lt;User&gt; getByFirstnameAndLastname(String firstname, String lastname);
  * </pre>
  * 
  * It must include the SELECT ... FROM ... preferably via the #n1ql expression, in addition to any predicates required,
diff --git a/src/main/java/org/springframework/data/couchbase/core/query/ViewIndexed.java b/src/main/java/org/springframework/data/couchbase/core/query/ViewIndexed.java
index 43b21215..001ecd40 100644
--- a/src/main/java/org/springframework/data/couchbase/core/query/ViewIndexed.java
+++ b/src/main/java/org/springframework/data/couchbase/core/query/ViewIndexed.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2020 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -26,10 +26,10 @@ import org.springframework.data.couchbase.repository.CouchbaseRepository;
 /**
  * This annotation is targeted at {@link CouchbaseRepository Repository} interfaces, indicating that the framework
  * should ensure a View is present when the repository is instantiated.
- * <p/>
+ * <p>
  * The view must at least be described as a design document name and view name. Default map function will filter
  * documents on the type associated to the repository, and default reduce function is "_count".
- * <p/>
+ * <p>
  * One can specify a custom reduce function as well as a non-default map function.
  *
  * @author Simon Baslé
diff --git a/src/main/java/org/springframework/data/couchbase/core/query/WithConsistency.java b/src/main/java/org/springframework/data/couchbase/core/query/WithConsistency.java
index e44bc787..99470174 100644
--- a/src/main/java/org/springframework/data/couchbase/core/query/WithConsistency.java
+++ b/src/main/java/org/springframework/data/couchbase/core/query/WithConsistency.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013-2020 the original author or authors.
+ * Copyright 2013-2022 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -30,7 +30,7 @@ import com.couchbase.client.java.query.QueryScanConsistency;
 /**
  * Annotation to set the scan consistency of N1QL queries with Couchbase. This controls whether couchbase waits for all
  * changes to be processed by an index or whether stale results are acceptable.
- * <p/>
+ * <p>
  * If not set, the default consistency set in {@link AbstractCouchbaseConfiguration#getDefaultConsistency()} is used.
  *
  * @author Johannes Jasper.
diff --git a/src/main/java/org/springframework/data/couchbase/core/support/AnyId.java b/src/main/java/org/springframework/data/couchbase/core/support/AnyId.java
index ea3a7fac..9b77d031 100644
--- a/src/main/java/org/springframework/data/couchbase/core/support/AnyId.java
+++ b/src/main/java/org/springframework/data/couchbase/core/support/AnyId.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020 the original author or authors
+ * Copyright 2020-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,7 +18,7 @@ package org.springframework.data.couchbase.core.support;
 import java.util.Collection;
 
 /**
- * A common interface for those that support one(T), all(Collection<T>)
+ * A common interface for those that support one(T), all(Collection&lt;T&gt;)
  *
  * @author Michael Reiche
  * @param <T> - the entity class
diff --git a/src/main/java/org/springframework/data/couchbase/core/support/AnyIdReactive.java b/src/main/java/org/springframework/data/couchbase/core/support/AnyIdReactive.java
index 9bd97ae1..7a387fcb 100644
--- a/src/main/java/org/springframework/data/couchbase/core/support/AnyIdReactive.java
+++ b/src/main/java/org/springframework/data/couchbase/core/support/AnyIdReactive.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020 the original author or authors
+ * Copyright 2020-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -21,7 +21,7 @@ import reactor.core.publisher.Mono;
 import java.util.Collection;
 
 /**
- * A common interface for those that support one(T), all(Collection<T>)
+ * A common interface for those that support one(T), all(Collection&lt;T%gt;)
  *
  * @author Michael Reiche
  * @param <T> - the entity class
diff --git a/src/main/java/org/springframework/data/couchbase/core/support/OneAndAll.java b/src/main/java/org/springframework/data/couchbase/core/support/OneAndAll.java
index cacad7ec..1cc17c63 100644
--- a/src/main/java/org/springframework/data/couchbase/core/support/OneAndAll.java
+++ b/src/main/java/org/springframework/data/couchbase/core/support/OneAndAll.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020 the original author or authors
+ * Copyright 2020-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,7 +20,7 @@ import java.util.Optional;
 import java.util.stream.Stream;
 
 /**
- * A common interface for those that support one(T), all(Collection<T>)
+ * A common interface for those that support one(T), all(Collection&lt;T&gt;)
  *
  * @author Michael Reiche
  *
diff --git a/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllEntity.java b/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllEntity.java
index be028fa8..da4f0dcb 100644
--- a/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllEntity.java
+++ b/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllEntity.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020 the original author or authors
+ * Copyright 2020-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,7 +18,7 @@ package org.springframework.data.couchbase.core.support;
 import java.util.Collection;
 
 /**
- * A common interface for those that support one(T), all(Collection<T>)
+ * A common interface for those that support one(T), all(Collection&lt;T&gt;)
  *
  * @author Michael Reiche
  *
diff --git a/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllEntityReactive.java b/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllEntityReactive.java
index 67fbba7b..a4f77fea 100644
--- a/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllEntityReactive.java
+++ b/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllEntityReactive.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020 the original author or authors
+ * Copyright 2020-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -21,7 +21,7 @@ import reactor.core.publisher.Mono;
 import java.util.Collection;
 
 /**
- * A common interface for those that support one(T), all(Collection<T>)
+ * A common interface for those that support one(T), all(Collection&lt;T&gt;)
  *
  * @author Michael Reiche
  * @param <T> - the entity class
diff --git a/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllExists.java b/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllExists.java
index 1b4041ae..42736507 100644
--- a/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllExists.java
+++ b/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllExists.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020 the original author or authors
+ * Copyright 2020-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -21,11 +21,9 @@ import java.util.Optional;
 import java.util.stream.Stream;
 
 /**
- * A common interface for those that support one(T), all(Collection<T>)
+ * A common interface for those that support one(T), all(Collection&lt;T&gt;)
  *
  * @author Michael Reiche
- *
- * @param <T> - the entity class
  */
 public interface OneAndAllExists {
   boolean one(String id);
diff --git a/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllExistsReactive.java b/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllExistsReactive.java
index 67487c3b..03d244d4 100644
--- a/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllExistsReactive.java
+++ b/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllExistsReactive.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020 the original author or authors
+ * Copyright 2020-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -21,11 +21,10 @@ import java.util.Collection;
 import java.util.Map;
 
 /**
- * A common interface for those that support one(T), all(Collection<T>)
+ * A common interface for those that support one(T), all(Collection&lt;T&gt;)
  *
  * @author Michael Reiche
  *
- * @param <T> - the entity class
  */
 public interface OneAndAllExistsReactive {
   Mono<Boolean> one(String id);
diff --git a/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllId.java b/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllId.java
index 370388c0..10484900 100644
--- a/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllId.java
+++ b/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllId.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020 the original author or authors
+ * Copyright 2020-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,7 +18,7 @@ package org.springframework.data.couchbase.core.support;
 import java.util.Collection;
 
 /**
- * A common interface for those that support one(String), all(Collection<String>)
+ * A common interface for those that support one(String), all(Collection&lt;String&gt;)
  *
  * @author Michael Reiche
  *
diff --git a/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllIdReactive.java b/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllIdReactive.java
index 5c8b74f2..b7e000d6 100644
--- a/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllIdReactive.java
+++ b/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllIdReactive.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020 the original author or authors
+ * Copyright 2020-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -21,7 +21,7 @@ import reactor.core.publisher.Mono;
 import java.util.Collection;
 
 /**
- * A common interface for those that support one(String), all(Collection<String>)
+ * A common interface for those that support one(String), all(Collection&lt;String&gt;)
  *
  * @author Michael Reiche
  * @param <T> - the entity class
diff --git a/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllReactive.java b/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllReactive.java
index 7e5414da..ef477759 100644
--- a/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllReactive.java
+++ b/src/main/java/org/springframework/data/couchbase/core/support/OneAndAllReactive.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020 the original author or authors
+ * Copyright 2020-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -23,7 +23,7 @@ import java.util.Optional;
 import java.util.stream.Stream;
 
 /**
- * A common interface for those that support one(T), all(Collection<T>)
+ * A common interface for those that support one(T), all(Collection&lt;T&gt;)
  *
  * @author Michael Reiche
  * @param <T> - the entity class
diff --git a/src/main/java/org/springframework/data/couchbase/core/support/PseudoArgs.java b/src/main/java/org/springframework/data/couchbase/core/support/PseudoArgs.java
index fb1bc9da..3a5ef7a7 100644
--- a/src/main/java/org/springframework/data/couchbase/core/support/PseudoArgs.java
+++ b/src/main/java/org/springframework/data/couchbase/core/support/PseudoArgs.java
@@ -19,19 +19,23 @@ import static org.springframework.data.couchbase.core.query.OptionsBuilder.fromF
 import static org.springframework.data.couchbase.core.query.OptionsBuilder.getCollectionFrom;
 import static org.springframework.data.couchbase.core.query.OptionsBuilder.getScopeFrom;
 
+import com.couchbase.client.core.error.CouchbaseException;
 import org.springframework.data.couchbase.core.ReactiveCouchbaseTemplate;
 
 import com.couchbase.client.core.io.CollectionIdentifier;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 
 public class PseudoArgs<OPTS> {
 	private final OPTS options;
 	private final String scopeName;
 	private final String collectionName;
+	private final CouchbaseTransactionalOperator transactionalOperator;
 
-	public PseudoArgs(String scopeName, String collectionName, OPTS options) {
+	public PseudoArgs(String scopeName, String collectionName, OPTS options, CouchbaseTransactionalOperator transactionalOperator) {
 		this.options = options;
 		this.scopeName = scopeName;
 		this.collectionName = collectionName;
+		this.transactionalOperator = transactionalOperator;
 	}
 
 	/**
@@ -47,11 +51,12 @@ public class PseudoArgs<OPTS> {
 	 * @param domainType - entity that may have annotations
 	 */
 	public PseudoArgs(ReactiveCouchbaseTemplate template, String scope, String collection, OPTS options,
-			Class<?> domainType) {
+					  CouchbaseTransactionalOperator transactionalOperator, Class<?> domainType) {
 
 		String scopeForQuery = null;
 		String collectionForQuery = null;
 		OPTS optionsForQuery = null;
+		CouchbaseTransactionalOperator txOpForQuery = null;
 
 		// 1) repository from DynamicProxy via template threadLocal - has precedence over annotation
 
@@ -61,16 +66,20 @@ public class PseudoArgs<OPTS> {
 			scopeForQuery = threadLocal.getScope();
 			collectionForQuery = threadLocal.getCollection();
 			optionsForQuery = threadLocal.getOptions();
+			//throw new RuntimeException("PseudoArgs fix me 1");
+			txOpForQuery = threadLocal.getTxOp();
+			//System.err.println("threadLocal: txOpForQuery: "+txOpForQuery+" session: ");
 		}
 
 		scopeForQuery = fromFirst(null, scopeForQuery, scope, getScopeFrom(domainType));
 		collectionForQuery = fromFirst(null, collectionForQuery, collection, getCollectionFrom(domainType));
 		optionsForQuery = fromFirst(null, options, optionsForQuery);
+		txOpForQuery = fromFirst( null, transactionalOperator, txOpForQuery , template.txOperator() );
 
 		// if a collection was specified but no scope, use the scope from the clientFactory
 
 		if (collectionForQuery != null && scopeForQuery == null) {
-			scopeForQuery = template.getCouchbaseClientFactory().getScope().name();
+			scopeForQuery = template.getScopeName();
 		}
 
 		// specifying scope and collection = _default is not necessary and will fail if server doesn't have collections
@@ -84,7 +93,11 @@ public class PseudoArgs<OPTS> {
 
 		this.scopeName = scopeForQuery;
 		this.collectionName = collectionForQuery;
+		if( scopeForQuery != null && collectionForQuery == null){
+			throw new CouchbaseException(new IllegalArgumentException("if scope is not default or null, then collection must be specified"));
+		}
 		this.options = optionsForQuery;
+		this.transactionalOperator = txOpForQuery;
 
 	}
 
@@ -109,8 +122,16 @@ public class PseudoArgs<OPTS> {
 		return this.collectionName;
 	}
 
+	/**
+	 * @return the attempt context
+	 */
+	public CouchbaseTransactionalOperator getTxOp() {
+		return transactionalOperator;
+	}
+
 	@Override
 	public String toString() {
-		return "scope: " + getScope() + " collection: " + getCollection() + " options: " + getOptions();
+		return "scope: " + getScope() + " collection: " + getCollection() + " options: " + getOptions()+" txOp: "+transactionalOperator;
 	}
+
 }
diff --git a/src/main/java/org/springframework/data/couchbase/core/support/WithCas.java b/src/main/java/org/springframework/data/couchbase/core/support/WithCas.java
new file mode 100644
index 00000000..1399235a
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/core/support/WithCas.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2020 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.couchbase.core.support;
+
+import com.couchbase.client.java.query.QueryScanConsistency;
+
+/**
+ * A common interface operations that take scan consistency
+ *
+ * @author Michael Reiche
+ * @param <T> - the entity class
+ */
+public interface WithCas<T> {
+	/**
+	 * Specify scan consistency
+	 *
+	 * @param cas
+	 */
+	Object withCas(Long cas);
+}
diff --git a/src/main/java/org/springframework/data/couchbase/core/support/WithTransaction.java b/src/main/java/org/springframework/data/couchbase/core/support/WithTransaction.java
new file mode 100644
index 00000000..b5fd14be
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/core/support/WithTransaction.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2020 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.couchbase.core.support;
+
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
+
+/**
+ * Interface for operations that take distinct fields
+ *
+ * @author Michael Reiche
+ * @param <T> - the entity class
+ */
+public interface WithTransaction<T> {
+	/**
+	 * Specify transactions
+	 *
+	 * @param txCtx
+	 */
+	Object transaction(CouchbaseTransactionalOperator txCtx);
+}
diff --git a/src/main/java/org/springframework/data/couchbase/repository/DynamicProxyable.java b/src/main/java/org/springframework/data/couchbase/repository/DynamicProxyable.java
index c97f9b9e..fbbe66ad 100644
--- a/src/main/java/org/springframework/data/couchbase/repository/DynamicProxyable.java
+++ b/src/main/java/org/springframework/data/couchbase/repository/DynamicProxyable.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2021 the original author or authors.
+ * Copyright 2017-2022 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -22,11 +22,12 @@ import org.springframework.data.couchbase.repository.query.CouchbaseEntityInform
 import org.springframework.data.couchbase.repository.support.DynamicInvocationHandler;
 
 import com.couchbase.client.java.CommonOptions;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 
 /**
  * The generic parameter needs to be REPO which is either a CouchbaseRepository parameterized on T,ID or a
  * ReactiveCouchbaseRepository parameterized on T,ID. i.e.: interface AirportRepository extends
- * CouchbaseRepository<Airport, String>, DynamicProxyable<AirportRepository>
+ * CouchbaseRepository&lt;Airport, String&gt;, DynamicProxyable&lt;AirportRepository&gt;
  *
  * @param <REPO>
  * @author Michael Reiche
@@ -38,40 +39,70 @@ public interface DynamicProxyable<REPO> {
 	Object getOperations();
 
 	/**
-	 * Support for Couchbase-specific options, scope and collections The three "with" methods will return a new proxy
-	 * instance with the specified options, scope, or collections set. The setters are called with the corresponding
-	 * options, scope and collection to set the ThreadLocal fields on the CouchbaseOperations of the repository just
-	 * before the call is made to the repository, and called again with 'null' just after the call is made. The repository
-	 * method will fetch those values to use in the call.
+	 * Support for Couchbase-specific options, scope and collections The four "with" methods will return a new proxy
+	 * instance with the specified options, scope, collection or transactionalOperator set. The setters are called with
+	 * the corresponding options, scope and collection to set the ThreadLocal fields on the CouchbaseOperations of the
+	 * repository just before the call is made to the repository, and called again with 'null' just after the call is
+	 * made. The repository method will fetch those values to use in the call.
 	 */
 
 	/**
+	 * Note that this is is always the first/only call and therefore only one of options, collection, scope or ctx is set.
+	 * Subsequent "with" calls are processed through the DynamicInvocationHandler and sets all of those which have already
+	 * been set.
+	 *
 	 * @param options - the options to set on the returned repository object
 	 */
 	@SuppressWarnings("unchecked")
 	default REPO withOptions(CommonOptions<?> options) {
 		REPO proxyInstance = (REPO) Proxy.newProxyInstance(this.getClass().getClassLoader(),
-				this.getClass().getInterfaces(), new DynamicInvocationHandler(this, options, null, (String) null));
+				this.getClass().getInterfaces(), new DynamicInvocationHandler(this, options, null, null, null));
 		return proxyInstance;
 	}
 
 	/**
+	 * Note that this is is always the first/only call and therefore only one of options, collection, scope or ctx is set.
+	 * Subsequent "with" calls are processed through the DynamicInvocationHandler and sets all of those which have already
+	 * been set.
+	 *
 	 * @param scope - the scope to set on the returned repository object
 	 */
 	@SuppressWarnings("unchecked")
 	default REPO withScope(String scope) {
 		REPO proxyInstance = (REPO) Proxy.newProxyInstance(this.getClass().getClassLoader(),
-				this.getClass().getInterfaces(), new DynamicInvocationHandler<>(this, null, null, scope));
+				this.getClass().getInterfaces(), new DynamicInvocationHandler<>(this, null, null, scope, null));
 		return proxyInstance;
 	}
 
 	/**
+	 * Note that this is is always the first/only call and therefore only one of options, collection, scope or ctx is set.
+	 * Subsequent "with" calls are processed through the DynamicInvocationHandler and sets all of those which have already
+	 * been set.
+	 *
 	 * @param collection - the collection to set on the returned repository object
 	 */
 	@SuppressWarnings("unchecked")
 	default REPO withCollection(String collection) {
 		REPO proxyInstance = (REPO) Proxy.newProxyInstance(this.getClass().getClassLoader(),
-				this.getClass().getInterfaces(), new DynamicInvocationHandler<>(this, null, collection, null));
+				this.getClass().getInterfaces(), new DynamicInvocationHandler<>(this, null, collection, null, null));
+		return proxyInstance;
+	}
+
+	/**
+	 * @param ctx - the transactionalOperator for transactions
+	 */
+	@SuppressWarnings("unchecked")
+	/*
+	default REPO withTransaction(TransactionalOperator ctx) {
+		REPO proxyInstance = (REPO) Proxy.newProxyInstance(this.getClass().getClassLoader(),
+				this.getClass().getInterfaces(), new DynamicInvocationHandler<>(this, null, null, null, ctx));
+		return proxyInstance;
+	}
+	 */
+
+	default REPO withTransaction(CouchbaseTransactionalOperator ctx) {
+		REPO proxyInstance = (REPO) Proxy.newProxyInstance(this.getClass().getClassLoader(),
+				this.getClass().getInterfaces(), new DynamicInvocationHandler<>(this, null, null, null, ctx));
 		return proxyInstance;
 	}
 
diff --git a/src/main/java/org/springframework/data/couchbase/repository/Query.java b/src/main/java/org/springframework/data/couchbase/repository/Query.java
index 21562a78..39eab142 100644
--- a/src/main/java/org/springframework/data/couchbase/repository/Query.java
+++ b/src/main/java/org/springframework/data/couchbase/repository/Query.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2020 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -23,23 +23,25 @@ import java.lang.annotation.Target;
 
 import org.springframework.data.annotation.QueryAnnotation;
 import org.springframework.data.couchbase.core.CouchbaseTemplate;
+import org.springframework.data.couchbase.repository.query.StringBasedN1qlQueryParser;
+import org.springframework.data.couchbase.repository.query.StringN1qlQueryCreator;
 
 /**
- * Annotation to support the use of N1QL queries with Couchbase.
- * <p/>
+ * Annotation to support the use of N1QL queries with Couchbase. Queries are crated by {@link StringN1qlQueryCreator}
+ * <p>
  * Using it without parameter will resolve the query from the method name. Providing a value (an inline N1QL statement)
  * will execute that statement instead.
- * <p/>
+ * <p>
  * In this case, one can use a placeholder notation of {@code ?0}, {@code ?1} and so on.
- * <p/>
+ * <p>
  * Also, SpEL in the form <code>#{spelExpression}</code> is supported, including the following N1QL variables that will
  * be replaced by the underlying {@link CouchbaseTemplate} associated information:
  * <ul>
- * <li>{@value StringN1qlBasedQuery#SPEL_SELECT_FROM_CLAUSE} (see {@link StringN1qlBasedQuery#SPEL_SELECT_FROM_CLAUSE})
+ * <li>{@value StringBasedN1qlQueryParser#SPEL_SELECT_FROM_CLAUSE} (see {@link StringBasedN1qlQueryParser#SPEL_SELECT_FROM_CLAUSE})
  * </li>
- * <li>{@value StringN1qlBasedQuery#SPEL_BUCKET} (see {@link StringN1qlBasedQuery#SPEL_BUCKET})</li>
- * <li>{@value StringN1qlBasedQuery#SPEL_ENTITY} (see {@link StringN1qlBasedQuery#SPEL_ENTITY})</li>
- * <li>{@value StringN1qlBasedQuery#SPEL_FILTER} (see {@link StringN1qlBasedQuery#SPEL_FILTER})</li>
+ * <li>{@value StringBasedN1qlQueryParser#SPEL_BUCKET} (see {@link StringBasedN1qlQueryParser#SPEL_BUCKET})</li>
+ * <li>{@value StringBasedN1qlQueryParser#SPEL_ENTITY} (see {@link StringBasedN1qlQueryParser#SPEL_ENTITY})</li>
+ * <li>{@value StringBasedN1qlQueryParser#SPEL_FILTER} (see {@link StringBasedN1qlQueryParser#SPEL_FILTER})</li>
  * </ul>
  *
  * @author Simon Baslé.
diff --git a/src/main/java/org/springframework/data/couchbase/repository/ReactiveCouchbaseRepository.java b/src/main/java/org/springframework/data/couchbase/repository/ReactiveCouchbaseRepository.java
index db41820f..bf8707e9 100644
--- a/src/main/java/org/springframework/data/couchbase/repository/ReactiveCouchbaseRepository.java
+++ b/src/main/java/org/springframework/data/couchbase/repository/ReactiveCouchbaseRepository.java
@@ -32,4 +32,5 @@ public interface ReactiveCouchbaseRepository<T, ID> extends ReactiveSortingRepos
 	ReactiveCouchbaseOperations getOperations();
 
 	CouchbaseEntityInformation<T, String> getEntityInformation();
+
 }
diff --git a/src/main/java/org/springframework/data/couchbase/repository/TransactionMeta.java b/src/main/java/org/springframework/data/couchbase/repository/TransactionMeta.java
new file mode 100644
index 00000000..ae33ddef
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/repository/TransactionMeta.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2021 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.couchbase.repository;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+import org.springframework.data.annotation.QueryAnnotation;
+
+/**
+ * Indicates the field should hold key to lookup the TransactionGetResult and should NOT be considered part of the
+ * document.
+ *
+ * @author Michael Reiche
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ ElementType.FIELD })
+@Documented
+@QueryAnnotation
+public @interface TransactionMeta {
+
+  String value() default "";
+
+}
diff --git a/src/main/java/org/springframework/data/couchbase/repository/TransactionResult.java b/src/main/java/org/springframework/data/couchbase/repository/TransactionResult.java
new file mode 100644
index 00000000..d2236d52
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/repository/TransactionResult.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2012-2021 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.couchbase.repository;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+import org.springframework.data.annotation.QueryAnnotation;
+
+/**
+ * Indicates the field should hold Transaction*Result and should NOT be considered part of the document.
+ *
+ * @author Michael Reiche
+ */
+// todo gp can we give this a different name since there is an existing TransactionResult
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ ElementType.FIELD })
+@Documented
+@QueryAnnotation
+public @interface TransactionResult {
+
+	String value() default "";
+
+}
diff --git a/src/main/java/org/springframework/data/couchbase/repository/auditing/CouchbaseAuditingRegistrar.java b/src/main/java/org/springframework/data/couchbase/repository/auditing/CouchbaseAuditingRegistrar.java
index 7120205c..9338caaf 100644
--- a/src/main/java/org/springframework/data/couchbase/repository/auditing/CouchbaseAuditingRegistrar.java
+++ b/src/main/java/org/springframework/data/couchbase/repository/auditing/CouchbaseAuditingRegistrar.java
@@ -19,6 +19,7 @@ package org.springframework.data.couchbase.repository.auditing;
 import java.lang.annotation.Annotation;
 
 import org.springframework.beans.factory.config.BeanDefinition;
+import org.springframework.beans.factory.support.AbstractBeanDefinition;
 import org.springframework.beans.factory.support.BeanDefinitionBuilder;
 import org.springframework.beans.factory.support.BeanDefinitionRegistry;
 import org.springframework.beans.factory.support.RootBeanDefinition;
@@ -70,7 +71,11 @@ public class CouchbaseAuditingRegistrar extends AuditingBeanDefinitionRegistrarS
 		Assert.notNull(configuration, "AuditingConfiguration must not be null!");
 
 		BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(IsNewAwareAuditingHandler.class);
-		builder.addConstructorArgReference(BeanNames.COUCHBASE_MAPPING_CONTEXT);
+
+		BeanDefinitionBuilder definition = BeanDefinitionBuilder.genericBeanDefinition(PersistentEntitiesFactoryBean.class);
+		definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);
+
+		builder.addConstructorArgValue(definition.getBeanDefinition());
 		return configureDefaultAuditHandlerAttributes(configuration, builder);
 	}
 
diff --git a/src/main/java/org/springframework/data/couchbase/repository/query/AbstractCouchbaseQuery.java b/src/main/java/org/springframework/data/couchbase/repository/query/AbstractCouchbaseQuery.java
index 115d1872..4174eef5 100644
--- a/src/main/java/org/springframework/data/couchbase/repository/query/AbstractCouchbaseQuery.java
+++ b/src/main/java/org/springframework/data/couchbase/repository/query/AbstractCouchbaseQuery.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020-2021 the original author or authors
+ * Copyright 2020-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -22,6 +22,7 @@ import org.springframework.data.couchbase.core.ExecutableFindByQueryOperation.Te
 import org.springframework.data.couchbase.core.query.Query;
 import org.springframework.data.couchbase.repository.query.CouchbaseQueryExecution.DeleteExecution;
 import org.springframework.data.couchbase.repository.query.CouchbaseQueryExecution.PagedExecution;
+import org.springframework.data.couchbase.repository.query.CouchbaseQueryExecution.SlicedExecution;
 import org.springframework.data.repository.core.EntityMetadata;
 import org.springframework.data.repository.query.ParameterAccessor;
 import org.springframework.data.repository.query.ParametersParameterAccessor;
@@ -127,6 +128,8 @@ public abstract class AbstractCouchbaseQuery extends AbstractCouchbaseQueryBase<
 			return (q, t, r, c) -> operation.as(r).matching(q).exists();
 		} else if (getQueryMethod().isPageQuery()) {
 			return new PagedExecution(operation, accessor.getPageable());
+		} else if (getQueryMethod().isSliceQuery()) {
+			return new SlicedExecution(operation, accessor.getPageable());
 		} else {
 			return (q, t, r, c) -> {
 				TerminatingFindByQuery<?> find = operation.as(r).matching(q);
diff --git a/src/main/java/org/springframework/data/couchbase/repository/query/CouchbaseQueryExecution.java b/src/main/java/org/springframework/data/couchbase/repository/query/CouchbaseQueryExecution.java
index 9a98018f..a2204879 100644
--- a/src/main/java/org/springframework/data/couchbase/repository/query/CouchbaseQueryExecution.java
+++ b/src/main/java/org/springframework/data/couchbase/repository/query/CouchbaseQueryExecution.java
@@ -22,11 +22,11 @@ import org.springframework.data.couchbase.core.CouchbaseOperations;
 import org.springframework.data.couchbase.core.ExecutableFindByQueryOperation.ExecutableFindByQuery;
 import org.springframework.data.couchbase.core.ExecutableFindByQueryOperation.TerminatingFindByQuery;
 import org.springframework.data.couchbase.core.query.Query;
+import org.springframework.data.domain.PageImpl;
 import org.springframework.data.domain.Pageable;
 import org.springframework.data.domain.Slice;
 import org.springframework.data.domain.SliceImpl;
 import org.springframework.data.repository.query.QueryMethod;
-import org.springframework.data.repository.support.PageableExecutionUtils;
 import org.springframework.util.Assert;
 
 /**
@@ -93,13 +93,13 @@ interface CouchbaseQueryExecution {
 	 */
 	final class SlicedExecution implements CouchbaseQueryExecution {
 
-		private final ExecutableFindByQuery<?> find;
+		private final ExecutableFindByQuery<?> operation;
 		private final Pageable pageable;
 
-		public SlicedExecution(ExecutableFindByQuery find, Pageable pageable) {
-			Assert.notNull(find, "Find must not be null!");
+		public SlicedExecution(ExecutableFindByQuery operation, Pageable pageable) {
+			Assert.notNull(operation, "Find must not be null!");
 			Assert.notNull(pageable, "Pageable must not be null!");
-			this.find = find;
+			this.operation = operation;
 			this.pageable = pageable;
 		}
 
@@ -110,12 +110,14 @@ interface CouchbaseQueryExecution {
 		@Override
 		@SuppressWarnings({ "unchecked", "rawtypes" })
 		public Object execute(Query query, Class<?> type, Class<?> returnType, String collection) {
-			int pageSize = pageable.getPageSize();
-			// Apply Pageable but tweak limit to peek into next page
-			Query modifiedQuery = query.skip(pageable.getOffset()).limit(pageSize + 1);
-			List result = find.as(returnType).matching(modifiedQuery).all();
-			boolean hasNext = result.size() > pageSize;
-			return new SliceImpl<Object>(hasNext ? result.subList(0, pageSize) : result, pageable, hasNext);
+			int overallLimit = 0; // query.getLimit();
+			TerminatingFindByQuery<?> matching = operation.as(returnType).matching(query);
+			// Adjust limit if page would exceed the overall limit
+			if (overallLimit != 0 && pageable.getOffset() + pageable.getPageSize() > overallLimit) {
+				query.limit((int) (overallLimit - pageable.getOffset()));
+			}
+			List<?> results = matching.all();
+			return new SliceImpl(results, pageable, results != null && !results.isEmpty());
 		}
 	}
 
@@ -146,10 +148,13 @@ interface CouchbaseQueryExecution {
 			if (overallLimit != 0 && pageable.getOffset() + pageable.getPageSize() > overallLimit) {
 				query.limit((int) (overallLimit - pageable.getOffset()));
 			}
-			return PageableExecutionUtils.getPage(matching.all(), pageable, () -> {
+
+			List<?> result = matching.all(); // this needs to be done before count, as count clears the skip and limit
+
 			long count = operation.matching(query.skip(-1).limit(-1).withoutSort()).count();
-				return overallLimit != 0 ? Math.min(count, overallLimit) : count;
-			});
+			count = overallLimit != 0 ? Math.min(count, overallLimit) : count;
+
+			return new PageImpl(result, pageable, count);
 		}
 	}
 
diff --git a/src/main/java/org/springframework/data/couchbase/repository/query/CountFragment.java b/src/main/java/org/springframework/data/couchbase/repository/query/CountFragment.java
index 918192c9..0503e1b4 100644
--- a/src/main/java/org/springframework/data/couchbase/repository/query/CountFragment.java
+++ b/src/main/java/org/springframework/data/couchbase/repository/query/CountFragment.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2020 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,9 +18,9 @@ package org.springframework.data.couchbase.repository.query;
 
 /**
  * An utility entity that allows to extract total row count out of a COUNT(*) N1QL query.
- * <p/>
+ * <p>
  * The query should use the COUNT_ALIAS, eg.: SELECT COUNT(*) AS count FROM default;
- * <p/>
+ * <p>
  * This ensures that the framework will be able to map the JSON result to this {@link CountFragment} class so that it
  * can be used.
  */
diff --git a/src/main/java/org/springframework/data/couchbase/repository/query/DtoInstantiatingConverter.java b/src/main/java/org/springframework/data/couchbase/repository/query/DtoInstantiatingConverter.java
deleted file mode 100644
index d62767e4..00000000
--- a/src/main/java/org/springframework/data/couchbase/repository/query/DtoInstantiatingConverter.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Copyright 2015-2020 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.springframework.data.couchbase.repository.query;
-
-import org.springframework.core.convert.converter.Converter;
-import org.springframework.data.couchbase.core.mapping.CouchbasePersistentEntity;
-import org.springframework.data.couchbase.core.mapping.CouchbasePersistentProperty;
-import org.springframework.data.mapping.PersistentEntity;
-import org.springframework.data.mapping.PersistentProperty;
-import org.springframework.data.mapping.PersistentPropertyAccessor;
-import org.springframework.data.mapping.PreferredConstructor;
-import org.springframework.data.mapping.PreferredConstructor.Parameter;
-import org.springframework.data.mapping.SimplePropertyHandler;
-import org.springframework.data.mapping.context.MappingContext;
-import org.springframework.data.mapping.model.EntityInstantiator;
-import org.springframework.data.mapping.model.EntityInstantiators;
-import org.springframework.data.mapping.model.ParameterValueProvider;
-import org.springframework.util.Assert;
-
-/**
- * {@link Converter} to instantiate DTOs from fully equipped domain objects.
- *
- * @author Michael Reiche
- * @since 4.1
- */
-class DtoInstantiatingConverter implements Converter<Object, Object> {
-
-	private final Class<?> targetType;
-	private final MappingContext<? extends PersistentEntity<?, ?>, ? extends PersistentProperty<?>> context;
-	private final EntityInstantiator instantiator;
-
-	/**
-	 * Creates a new {@link Converter} to instantiate DTOs.
-	 *
-	 * @param dtoType must not be {@literal null}.
-	 * @param context must not be {@literal null}.
-	 * @param entityInstantiators must not be {@literal null}.
-	 */
-	public DtoInstantiatingConverter(Class<?> dtoType,
-			MappingContext<? extends CouchbasePersistentEntity<?>, CouchbasePersistentProperty> context,
-			EntityInstantiators entityInstantiators) {
-
-		Assert.notNull(dtoType, "DTO type must not be null!");
-		Assert.notNull(context, "MappingContext must not be null!");
-		Assert.notNull(entityInstantiators, "EntityInstantiators must not be null!");
-
-		this.targetType = dtoType;
-		this.context = context;
-		this.instantiator = entityInstantiators.getInstantiatorFor(context.getRequiredPersistentEntity(dtoType));
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * @see org.springframework.core.convert.converter.Converter#convert(java.lang.Object)
-	 */
-	@Override
-	public Object convert(Object source) {
-
-		if (targetType.isInterface()) {
-			return source;
-		}
-
-		final PersistentEntity<?, ?> sourceEntity = context.getRequiredPersistentEntity(source.getClass());
-		final PersistentPropertyAccessor sourceAccessor = sourceEntity.getPropertyAccessor(source);
-		final PersistentEntity<?, ?> targetEntity = context.getRequiredPersistentEntity(targetType);
-		final PreferredConstructor<?, ? extends PersistentProperty<?>> constructor = targetEntity
-				.getPersistenceConstructor();
-
-		@SuppressWarnings({ "rawtypes", "unchecked" })
-		Object dto = instantiator.createInstance(targetEntity, new ParameterValueProvider() {
-
-			@Override
-			public Object getParameterValue(Parameter parameter) {
-				return sourceAccessor.getProperty(sourceEntity.getPersistentProperty(parameter.getName().toString()));
-			}
-		});
-
-		final PersistentPropertyAccessor dtoAccessor = targetEntity.getPropertyAccessor(dto);
-
-		targetEntity.doWithProperties(new SimplePropertyHandler() {
-
-			@Override
-			public void doWithPersistentProperty(PersistentProperty<?> property) {
-
-				if (constructor.isConstructorParameter(property)) {
-					return;
-				}
-
-				dtoAccessor.setProperty(property,
-						sourceAccessor.getProperty(sourceEntity.getPersistentProperty(property.getName())));
-			}
-		});
-
-		return dto;
-	}
-}
diff --git a/src/main/java/org/springframework/data/couchbase/repository/query/N1qlQueryCreator.java b/src/main/java/org/springframework/data/couchbase/repository/query/N1qlQueryCreator.java
index e4b3279e..08313fc8 100644
--- a/src/main/java/org/springframework/data/couchbase/repository/query/N1qlQueryCreator.java
+++ b/src/main/java/org/springframework/data/couchbase/repository/query/N1qlQueryCreator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -69,14 +69,14 @@ public class N1qlQueryCreator extends AbstractQueryCreator<Query, QueryCriteria>
 		this.queryMethod = queryMethod;
 		this.converter = converter;
 		this.bucketName = bucketName;
-		this.entity = converter.getMappingContext().getPersistentEntity(queryMethod.getReturnedObjectType());
+		this.entity = converter.getMappingContext().getPersistentEntity(queryMethod.getEntityInformation().getJavaType());
 	}
 
 	@Override
 	protected QueryCriteria create(final Part part, final Iterator<Object> iterator) {
 		PersistentPropertyPath<CouchbasePersistentProperty> path = context.getPersistentPropertyPath(part.getProperty());
 		CouchbasePersistentProperty property = path.getLeafProperty();
-		return from(part, property, where(addMetaIfRequired(bucketName, path, property, entity)), iterator);
+		return from(part, property, where(addMetaIfRequired(null, path, property, entity)), iterator);
 	}
 
 	@Override
@@ -187,17 +187,28 @@ public class N1qlQueryCreator extends AbstractQueryCreator<Query, QueryCriteria>
 		}
 	}
 
+	/**
+	 * Translate meta-fields to META(bucketName).id, cas, expiry.<br>
+	 * If bucketName is null, META().id etc, <br>
+	 * If not a meta-field, just create the corresponding path
+	 *
+	 * @param bucketName
+	 * @param persistentPropertyPath
+	 * @param property
+	 * @param entity
+	 * @return N1QLExpression
+	 */
 	public static N1QLExpression addMetaIfRequired(String bucketName,
 			final PersistentPropertyPath<CouchbasePersistentProperty> persistentPropertyPath,
 			final CouchbasePersistentProperty property, final PersistentEntity entity) {
 		if (entity != null && property == entity.getIdProperty()) {
-			return path(meta(i(bucketName)), i(META_ID_PROPERTY));
+			return path(meta(bucketName != null ? i(bucketName) : x("")), i(META_ID_PROPERTY));
 		}
 		if (property == entity.getVersionProperty()) {
-			return path(meta(i(bucketName)), i(META_CAS_PROPERTY));
+			return path(meta(bucketName != null ? i(bucketName) : x("")), i(META_CAS_PROPERTY));
 		}
 		if (property.isExpirationProperty()) {
-			return path(meta(i(bucketName)), i(META_EXPIRATION_PROPERTY));
+			return path(meta(bucketName != null ? i(bucketName) : x("")), i(META_EXPIRATION_PROPERTY));
 		}
 		return x(persistentPropertyPath.toDotPath(cvtr));
 	}
diff --git a/src/main/java/org/springframework/data/couchbase/repository/query/OldN1qlQueryCreator.java b/src/main/java/org/springframework/data/couchbase/repository/query/OldN1qlQueryCreator.java
index 0bda1358..a8bbe221 100644
--- a/src/main/java/org/springframework/data/couchbase/repository/query/OldN1qlQueryCreator.java
+++ b/src/main/java/org/springframework/data/couchbase/repository/query/OldN1qlQueryCreator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2019 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -75,7 +75,6 @@ import com.couchbase.client.java.json.JsonValue;
  * <ul>
  * <li><b>NEAR, WITHIN:</b> geospatial is not supported in N1QL as of now</li>
  * </ul>
- * </p>
  *
  * @author Simon Baslé
  * @author Subhashni Balakrishnan
diff --git a/src/main/java/org/springframework/data/couchbase/repository/query/ResultProcessingConverter.java b/src/main/java/org/springframework/data/couchbase/repository/query/ResultProcessingConverter.java
index dd8e017d..64066e02 100644
--- a/src/main/java/org/springframework/data/couchbase/repository/query/ResultProcessingConverter.java
+++ b/src/main/java/org/springframework/data/couchbase/repository/query/ResultProcessingConverter.java
@@ -18,6 +18,7 @@ package org.springframework.data.couchbase.repository.query;
 
 import org.reactivestreams.Publisher;
 import org.springframework.core.convert.converter.Converter;
+import org.springframework.data.convert.DtoInstantiatingConverter;
 import org.springframework.data.couchbase.core.CouchbaseOperations;
 import org.springframework.data.couchbase.core.ReactiveCouchbaseOperations;
 import org.springframework.data.couchbase.core.convert.CouchbaseConverter;
diff --git a/src/main/java/org/springframework/data/couchbase/repository/query/StringBasedN1qlQueryParser.java b/src/main/java/org/springframework/data/couchbase/repository/query/StringBasedN1qlQueryParser.java
index 3aa20072..d8140e89 100644
--- a/src/main/java/org/springframework/data/couchbase/repository/query/StringBasedN1qlQueryParser.java
+++ b/src/main/java/org/springframework/data/couchbase/repository/query/StringBasedN1qlQueryParser.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2021 the original author or authors.
+ * Copyright 2017-2022 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,6 +20,7 @@ import static org.springframework.data.couchbase.core.query.N1QLExpression.x;
 import static org.springframework.data.couchbase.core.support.TemplateUtils.SELECT_CAS;
 import static org.springframework.data.couchbase.core.support.TemplateUtils.SELECT_ID;
 
+import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -33,10 +34,10 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.springframework.data.couchbase.core.convert.CouchbaseConverter;
 import org.springframework.data.couchbase.core.mapping.CouchbasePersistentProperty;
+import org.springframework.data.couchbase.core.mapping.Expiration;
 import org.springframework.data.couchbase.core.query.N1QLExpression;
 import org.springframework.data.couchbase.repository.Query;
 import org.springframework.data.couchbase.repository.query.support.N1qlUtils;
-import org.springframework.data.domain.Pageable;
 import org.springframework.data.mapping.PersistentEntity;
 import org.springframework.data.mapping.PersistentPropertyPath;
 import org.springframework.data.mapping.PropertyHandler;
@@ -44,7 +45,6 @@ import org.springframework.data.repository.query.Parameter;
 import org.springframework.data.repository.query.ParameterAccessor;
 import org.springframework.data.repository.query.QueryMethodEvaluationContextProvider;
 import org.springframework.data.repository.query.ReturnedType;
-import org.springframework.data.util.TypeInformation;
 import org.springframework.expression.EvaluationContext;
 import org.springframework.expression.common.TemplateParserContext;
 import org.springframework.expression.spel.standard.SpelExpressionParser;
@@ -130,11 +130,12 @@ public class StringBasedN1qlQueryParser {
 		this.queryMethod = queryMethod;
 		this.couchbaseConverter = couchbaseConverter;
 		String collection = queryMethod.getCollection();
-		this.statementContext = createN1qlSpelValues(bucketName, collection, null, null, typeField, typeValue, false, null,
-				null);
-		this.countContext = createN1qlSpelValues(bucketName, collection, null, null, typeField, typeValue, true, null,
-				null);
-		this.parsedExpression = getExpression(accessor, getParameters(accessor), null, parser, evaluationContextProvider);
+		this.statementContext = createN1qlSpelValues(bucketName, collection,
+				queryMethod.getEntityInformation().getJavaType(), queryMethod.getReturnedObjectType(), typeField, typeValue,
+				false, null, null);
+		this.countContext = createN1qlSpelValues(bucketName, collection, queryMethod.getEntityInformation().getJavaType(),
+				queryMethod.getReturnedObjectType(), typeField, typeValue, true, null, null);
+		this.parsedExpression = getExpression(accessor, null, parser, evaluationContextProvider);
 		checkPlaceholders(this.parsedExpression.toString());
 	}
 
@@ -161,12 +162,12 @@ public class StringBasedN1qlQueryParser {
 		String b = collection != null ? collection : bucketName;
 		Assert.isTrue(!(distinctFields != null && fields != null),
 				"only one of project(fields) and distinct(distinctFields) can be specified");
-		String projectedFields = getProjectedFields(b, resultClass, fields);
-		String entity = "META(" + i(b) + ").id AS " + SELECT_ID + ", META(" + i(b) + ").cas AS " + SELECT_CAS;
+		String entity = "META(" + i(b) + ").id AS " + SELECT_ID + ", META(" + i(b) + ").cas AS " + SELECT_CAS + ", "
+				+ i(typeField);
 		String count = "COUNT(*) AS " + CountFragment.COUNT_ALIAS;
 		String selectEntity;
 		if (distinctFields != null) {
-			String distinctFieldsStr = distinctFields.length == 0 ? projectedFields : getDistinctFields(distinctFields);
+			String distinctFieldsStr = getProjectedOrDistinctFields(b, domainClass, typeField, fields, distinctFields);
 			if (isCount) {
 				selectEntity = "SELECT COUNT( DISTINCT {" + distinctFieldsStr + "} ) " + CountFragment.COUNT_ALIAS + " FROM "
 						+ i(b);
@@ -176,6 +177,7 @@ public class StringBasedN1qlQueryParser {
 		} else if (isCount) {
 			selectEntity = "SELECT " + count + " FROM " + i(b);
 		} else {
+			String projectedFields = getProjectedOrDistinctFields(b, domainClass, typeField, fields, distinctFields);
 			selectEntity = "SELECT " + entity + (!projectedFields.isEmpty() ? ", " : " ") + projectedFields + " FROM " + i(b);
 		}
 		String typeSelection = "`" + typeField + "` = \"" + typeValue + "\"";
@@ -183,47 +185,50 @@ public class StringBasedN1qlQueryParser {
 		String delete = N1QLExpression.delete().from(b).toString();
 		String returning = " returning " + N1qlUtils.createReturningExpressionForDelete(b).toString();
 
-		return new N1qlSpelValues(selectEntity, entity, b, typeSelection, delete, returning);
+		return new N1qlSpelValues(selectEntity, entity, i(b).toString(), typeSelection, delete, returning);
 	}
 
-	private String getDistinctFields(String... distinctFields) {
+	private String getProjectedOrDistinctFields(String b, Class resultClass, String typeField, String[] fields,
+			String[] distinctFields) {
+		if (distinctFields != null && distinctFields.length != 0) {
 			return i(distinctFields).toString();
 		}
-
-	private String getProjectedFields(String b, Class resultClass, String[] fields) {
-
-		String projectedFields = i(b) + ".*";
-		if (resultClass != null) {
+		String projectedFields = i(b) + ".*"; // if we can't get further information of the fields needed project everything
+		if (resultClass != null && !Modifier.isAbstract(resultClass.getModifiers())) {
 			PersistentEntity persistentEntity = couchbaseConverter.getMappingContext().getPersistentEntity(resultClass);
 			StringBuilder sb = new StringBuilder();
-			getProjectedFieldsInternal(b, null, sb, persistentEntity.getTypeInformation(), fields/*, ""*/);
+			getProjectedFieldsInternal(b, null, sb, persistentEntity, typeField, fields, distinctFields != null);
 			projectedFields = sb.toString();
 		}
 		return projectedFields;
 	}
 
 	private void getProjectedFieldsInternal(String bucketName, CouchbasePersistentProperty parent, StringBuilder sb,
-			TypeInformation resultClass, String[] fields/*, String path*/) {
+			PersistentEntity persistentEntity, String typeField, String[] fields, boolean forDistinct) {
 
-		if (resultClass != null) {
+		if (persistentEntity != null) {
 			Set<String> fieldList = fields != null ? new HashSet<>(Arrays.asList(fields)) : null;
-			PersistentEntity persistentEntity = couchbaseConverter.getMappingContext().getPersistentEntity(resultClass);
-			// CouchbasePersistentProperty property = path.getLeafProperty();
 
-			persistentEntity.doWithProperties(new PropertyHandler<CouchbasePersistentProperty>() {
-				@Override
-				public void doWithPersistentProperty(final CouchbasePersistentProperty prop) {
+			// do not include the id and cas metadata fields.
+
+			persistentEntity.doWithProperties((PropertyHandler<CouchbasePersistentProperty>) prop -> {
 				if (prop == persistentEntity.getIdProperty() && parent == null) {
 					return;
 				}
 				if (prop == persistentEntity.getVersionProperty() && parent == null) {
 					return;
 				}
+				if (prop.getFieldName().equals(typeField)) // typeField already projected
+					return;
+				// for distinct when no distinctFields were provided, do not include the expiration field.
+				if (forDistinct && prop.findAnnotation(Expiration.class) != null && parent == null) {
+					return;
+				}
 				String projectField = null;
 
 				if (fieldList == null || fieldList.contains(prop.getFieldName())) {
 					PersistentPropertyPath<CouchbasePersistentProperty> path = couchbaseConverter.getMappingContext()
-								.getPersistentPropertyPath(prop.getName(), resultClass.getType());
+							.getPersistentPropertyPath(prop.getName(), persistentEntity.getTypeInformation().getType());
 					projectField = N1qlQueryCreator.addMetaIfRequired(bucketName, path, prop, persistentEntity).toString();
 					if (sb.length() > 0) {
 						sb.append(", ");
@@ -242,9 +247,7 @@ public class StringBasedN1qlQueryParser {
 				// if (!conversions.isSimpleType(prop.getType())) {
 				// getProjectedFieldsInternal(prop, sb, prop.getTypeInformation(), path+prop.getName()+".");
 				// } else {
-
 				// }
-				}
 			});
 			// throw an exception if there is an request for a field not in the entity.
 			// needs further discussion as removing a field from an entity could cause this and not necessarily be an error
@@ -254,9 +257,11 @@ public class StringBasedN1qlQueryParser {
 			}
 		} else {
 			for (String field : fields) {
+				if (!field.equals(typeField)) { // typeField is already projected
 					if (sb.length() > 0) {
 						sb.append(", ");
 					}
+				}
 				sb.append(x(field));
 			}
 
@@ -524,23 +529,16 @@ public class StringBasedN1qlQueryParser {
 	}
 
 	// copied from StringN1qlBasedQuery
-	private N1QLExpression getExpression(ParameterAccessor accessor, Object[] runtimeParameters,
-			ReturnedType returnedType, SpelExpressionParser parser,
-			QueryMethodEvaluationContextProvider evaluationContextProvider) {
+	private N1QLExpression getExpression(ParameterAccessor accessor, ReturnedType returnedType,
+			SpelExpressionParser parser, QueryMethodEvaluationContextProvider evaluationContextProvider) {
 		boolean isCountQuery = queryMethod.isCountQuery();
+		Object[] runtimeParameters = getParameters(accessor);
 		EvaluationContext evaluationContext = evaluationContextProvider.getEvaluationContext(queryMethod.getParameters(),
 				runtimeParameters);
 		N1QLExpression parsedStatement = x(this.doParse(parser, evaluationContext, isCountQuery));
-
-		if (queryMethod.isSliceQuery()) {
-			Pageable pageable = accessor.getPageable();
-			Assert.notNull(pageable, "Pageable must not be null!");
-			parsedStatement = parsedStatement.limit(pageable.getPageSize() + 1).offset(Math.toIntExact(pageable.getOffset()));
-		}
 		return parsedStatement;
 	}
 
-	// getExpression() could do this itself, but pass as an arg to be consistent with StringN1qlBasedQuery
 	private static Object[] getParameters(ParameterAccessor accessor) {
 		ArrayList<Object> params = new ArrayList<>();
 		for (Object o : accessor) {
diff --git a/src/main/java/org/springframework/data/couchbase/repository/query/support/N1qlUtils.java b/src/main/java/org/springframework/data/couchbase/repository/query/support/N1qlUtils.java
index 522b018e..bd3668f6 100644
--- a/src/main/java/org/springframework/data/couchbase/repository/query/support/N1qlUtils.java
+++ b/src/main/java/org/springframework/data/couchbase/repository/query/support/N1qlUtils.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2020 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -26,6 +26,7 @@ import org.springframework.core.convert.converter.Converter;
 import org.springframework.data.couchbase.core.convert.CouchbaseConverter;
 import org.springframework.data.couchbase.core.mapping.CouchbasePersistentEntity;
 import org.springframework.data.couchbase.core.mapping.CouchbasePersistentProperty;
+import org.springframework.data.couchbase.core.mapping.Field;
 import org.springframework.data.couchbase.core.query.N1QLExpression;
 import org.springframework.data.couchbase.core.query.N1QLQuery;
 import org.springframework.data.couchbase.repository.query.CouchbaseEntityInformation;
diff --git a/src/main/java/org/springframework/data/couchbase/repository/support/CouchbaseRepositoryBase.java b/src/main/java/org/springframework/data/couchbase/repository/support/CouchbaseRepositoryBase.java
index 992c4d0d..e24e10db 100644
--- a/src/main/java/org/springframework/data/couchbase/repository/support/CouchbaseRepositoryBase.java
+++ b/src/main/java/org/springframework/data/couchbase/repository/support/CouchbaseRepositoryBase.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2021 the original author or authors.
+ * Copyright 2022 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -51,12 +51,21 @@ public class CouchbaseRepositoryBase<T, ID> {
 		return entityInformation;
 	}
 
+	/**
+	 * Returns the repository interface
+	 *
+	 * @return the underlying entity information.
+	 */
+	public Class<?> getRepositoryInterface() {
+		return repositoryInterface;
+	}
+
 	Class<T> getJavaType() {
 		return getEntityInformation().getJavaType();
 	}
 
 	<S extends T> String getId(S entity) {
-		return getEntityInformation().getId(entity);
+		return String.valueOf(getEntityInformation().getId(entity));
 	}
 
 	/**
@@ -68,7 +77,7 @@ public class CouchbaseRepositoryBase<T, ID> {
 	 * 1. repository.withCollection() 2. Annotation on the method
 	 */
 
-	String getScope() {
+	protected String getScope() {
 		String fromAnnotation = OptionsBuilder.annotationString(Scope.class, CollectionIdentifier.DEFAULT_SCOPE,
 				new AnnotatedElement[] { getJavaType(), repositoryInterface });
 		String fromMetadata = crudMethodMetadata.getScope();
@@ -83,7 +92,7 @@ public class CouchbaseRepositoryBase<T, ID> {
 	 * This can be overriden in the operation method by<br>
 	 * 1. repository.withCollection()
 	 */
-	String getCollection() {
+	protected String getCollection() {
 		String fromAnnotation = OptionsBuilder.annotationString(Collection.class, CollectionIdentifier.DEFAULT_COLLECTION,
 				new AnnotatedElement[] { getJavaType(), repositoryInterface });
 		String fromMetadata = crudMethodMetadata.getCollection();
diff --git a/src/main/java/org/springframework/data/couchbase/repository/support/CrudMethodMetadataPostProcessor.java b/src/main/java/org/springframework/data/couchbase/repository/support/CrudMethodMetadataPostProcessor.java
index 0e5dd19b..e37636b7 100644
--- a/src/main/java/org/springframework/data/couchbase/repository/support/CrudMethodMetadataPostProcessor.java
+++ b/src/main/java/org/springframework/data/couchbase/repository/support/CrudMethodMetadataPostProcessor.java
@@ -168,10 +168,10 @@ class CrudMethodMetadataPostProcessor implements RepositoryProxyPostProcessor, B
 				try {
 					return invocation.proceed();
 				} finally {
-					// TransactionSynchronizationManager.unbindResource(method);
+					TransactionSynchronizationManager.unbindResource(method);
 				}
 			} finally {
-				// currentInvocation.set(oldInvocation);
+				currentInvocation.set(oldInvocation);
 			}
 		}
 	}
diff --git a/src/main/java/org/springframework/data/couchbase/repository/support/DynamicInvocationHandler.java b/src/main/java/org/springframework/data/couchbase/repository/support/DynamicInvocationHandler.java
index dedba009..9c003285 100644
--- a/src/main/java/org/springframework/data/couchbase/repository/support/DynamicInvocationHandler.java
+++ b/src/main/java/org/springframework/data/couchbase/repository/support/DynamicInvocationHandler.java
@@ -29,6 +29,7 @@ import org.springframework.data.couchbase.repository.ReactiveCouchbaseRepository
 import org.springframework.data.couchbase.repository.query.CouchbaseEntityInformation;
 
 import com.couchbase.client.java.CommonOptions;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
 
 /**
  * Invocation Handler for scope/collection/options proxy for repositories
@@ -44,25 +45,40 @@ public class DynamicInvocationHandler<T> implements InvocationHandler {
 	final ReactiveCouchbaseTemplate reactiveTemplate;
 	CommonOptions<?> options;
 	String collection;
-	String scope;;
+	String scope;
+	CouchbaseTransactionalOperator ctx;
 
-	public DynamicInvocationHandler(T target, CommonOptions<?> options, String collection, String scope) {
+	public DynamicInvocationHandler(T target, CommonOptions<?> options, String collection, String scope,
+									CouchbaseTransactionalOperator ctx) {
 		this.target = target;
 		if (target instanceof CouchbaseRepository) {
 			reactiveTemplate = ((CouchbaseTemplate) ((CouchbaseRepository) target).getOperations()).reactive();
 			this.entityInformation = ((CouchbaseRepository<?, String>) target).getEntityInformation();
 		} else if (target instanceof ReactiveCouchbaseRepository) {
-			reactiveTemplate = (ReactiveCouchbaseTemplate) ((ReactiveCouchbaseRepository) target).getOperations();
-			this.entityInformation = ((ReactiveCouchbaseRepository<?, String>) target).getEntityInformation();
+			reactiveTemplate = (ReactiveCouchbaseTemplate) ((ReactiveCouchbaseRepository) this.target).getOperations();
+			this.entityInformation = ((ReactiveCouchbaseRepository<?, String>) this.target).getEntityInformation();
 		} else {
+			if( CouchbaseRepository.class.isAssignableFrom(target.getClass()))
+				System.err.println("isAssignable");
+			printInterfaces(target.getClass(), "  ");
 			throw new RuntimeException("Unknown target type: " + target.getClass());
 		}
 		this.options = options;
 		this.collection = collection;
 		this.scope = scope;
+		this.ctx = ctx;
 		this.repositoryClass = target.getClass();
 	}
 
+	void printInterfaces(Class clazz, String tab){
+		System.out.println(tab+"{");
+		for(Class c:clazz.getInterfaces()){
+			System.out.println(tab+"  " +c.getSimpleName());
+			if(c.getInterfaces().length > 0)
+				printInterfaces(c, tab+"  ");
+		}
+		System.out.println(tab+"}");
+	}
 	@Override
 	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
 
@@ -75,17 +91,22 @@ public class DynamicInvocationHandler<T> implements InvocationHandler {
 
 		if (method.getName().equals("withOptions")) {
 			return Proxy.newProxyInstance(repositoryClass.getClassLoader(), target.getClass().getInterfaces(),
-					new DynamicInvocationHandler<>(target, (CommonOptions) args[0], collection, scope));
+					new DynamicInvocationHandler<>(target, (CommonOptions) args[0], collection, scope, ctx));
 		}
 
 		if (method.getName().equals("withScope")) {
 			return Proxy.newProxyInstance(repositoryClass.getClassLoader(), target.getClass().getInterfaces(),
-					new DynamicInvocationHandler<>(target, options, collection, (String) args[0]));
+					new DynamicInvocationHandler<>(target, options, collection, (String) args[0], ctx));
 		}
 
 		if (method.getName().equals("withCollection")) {
 			return Proxy.newProxyInstance(repositoryClass.getClassLoader(), target.getClass().getInterfaces(),
-					new DynamicInvocationHandler<>(target, options, (String) args[0], scope));
+					new DynamicInvocationHandler<>(target, options, (String) args[0], scope, ctx));
+		}
+
+		if (method.getName().equals("withTransaction")) {
+			return Proxy.newProxyInstance(repositoryClass.getClassLoader(), target.getClass().getInterfaces(),
+					new DynamicInvocationHandler<>(target, options, collection, scope, (CouchbaseTransactionalOperator) args[0]));
 		}
 
 		Class<?>[] paramTypes = null;
@@ -117,7 +138,7 @@ public class DynamicInvocationHandler<T> implements InvocationHandler {
 		if (reactiveTemplate.getPseudoArgs() != null) {
 			throw new RuntimeException("pseudoArgs not yet consumed by previous caller");
 		}
-		reactiveTemplate.setPseudoArgs(new PseudoArgs(this.scope, this.collection, this.options));
+		reactiveTemplate.setPseudoArgs(new PseudoArgs(this.scope, this.collection, this.options, this.ctx));
 	}
 
 }
diff --git a/src/main/java/org/springframework/data/couchbase/repository/support/SimpleCouchbaseRepository.java b/src/main/java/org/springframework/data/couchbase/repository/support/SimpleCouchbaseRepository.java
index e2cc0338..7ae667ac 100644
--- a/src/main/java/org/springframework/data/couchbase/repository/support/SimpleCouchbaseRepository.java
+++ b/src/main/java/org/springframework/data/couchbase/repository/support/SimpleCouchbaseRepository.java
@@ -16,8 +16,6 @@
 
 package org.springframework.data.couchbase.repository.support;
 
-import static org.springframework.data.couchbase.repository.support.Util.hasNonZeroVersionProperty;
-
 import java.util.Collection;
 import java.util.List;
 import java.util.Objects;
@@ -25,6 +23,8 @@ import java.util.Optional;
 import java.util.stream.Collectors;
 
 import org.springframework.data.couchbase.core.CouchbaseOperations;
+import org.springframework.data.couchbase.core.mapping.CouchbasePersistentEntity;
+import org.springframework.data.couchbase.core.mapping.CouchbasePersistentProperty;
 import org.springframework.data.couchbase.core.query.Query;
 import org.springframework.data.couchbase.repository.CouchbaseRepository;
 import org.springframework.data.couchbase.repository.query.CouchbaseEntityInformation;
@@ -35,6 +35,7 @@ import org.springframework.data.domain.Sort;
 import org.springframework.data.util.StreamUtils;
 import org.springframework.data.util.Streamable;
 import org.springframework.util.Assert;
+import org.springframework.util.ReflectionUtils;
 
 import com.couchbase.client.java.query.QueryScanConsistency;
 
@@ -71,12 +72,25 @@ public class SimpleCouchbaseRepository<T, ID> extends CouchbaseRepositoryBase<T,
 	@SuppressWarnings("unchecked")
 	public <S extends T> S save(S entity) {
 		Assert.notNull(entity, "Entity must not be null!");
-		// if entity has non-null, non-zero version property, then replace()
 		S result;
-		if (hasNonZeroVersionProperty(entity, operations.getConverter())) {
-			result = (S) operations.replaceById(getJavaType()).inScope(getScope()).inCollection(getCollection()).one(entity);
-		} else {
+
+		final CouchbasePersistentEntity<?> mapperEntity = operations.getConverter().getMappingContext()
+				.getPersistentEntity(entity.getClass());
+		final CouchbasePersistentProperty versionProperty = mapperEntity.getVersionProperty();
+		final boolean versionPresent = versionProperty != null;
+		final Long version = versionProperty == null || versionProperty.getField() == null ? null
+				: (Long) ReflectionUtils.getField(versionProperty.getField(), entity);
+		final boolean existingDocument = version != null && version > 0;
+
+		if (!versionPresent) { // the entity doesn't have a version property
+			// No version field - no cas
 			result = (S) operations.upsertById(getJavaType()).inScope(getScope()).inCollection(getCollection()).one(entity);
+		} else if (existingDocument) { // there is a version property, and it is non-zero
+			// Updating existing document with cas
+			result = (S) operations.replaceById(getJavaType()).inScope(getScope()).inCollection(getCollection()).one(entity);
+		} else { // there is a version property, but it's zero or not set.
+			// Creating new document
+			result = (S) operations.insertById(getJavaType()).inScope(getScope()).inCollection(getCollection()).one(entity);
 		}
 		return result;
 	}
@@ -137,14 +151,14 @@ public class SimpleCouchbaseRepository<T, ID> extends CouchbaseRepositoryBase<T,
 
 	@Override
 	public long count() {
-		return operations.findByQuery(getJavaType()).withConsistency(buildQueryScanConsistency()).inScope(getScope())
-				.inCollection(getCollection()).count();
+		return operations.findByQuery(getJavaType()).inScope(getScope()).inCollection(getCollection())
+				.withConsistency(buildQueryScanConsistency()).count();
 	}
 
 	@Override
 	public void deleteAll() {
-		operations.removeByQuery(getJavaType()).withConsistency(buildQueryScanConsistency()).inScope(getScope())
-				.inCollection(getCollection()).all();
+		operations.removeByQuery(getJavaType()).inScope(getScope()).inCollection(getCollection())
+				.withConsistency(buildQueryScanConsistency()).all();
 	}
 
 	@Override
@@ -175,8 +189,8 @@ public class SimpleCouchbaseRepository<T, ID> extends CouchbaseRepositoryBase<T,
 	 * @return the list of found entities, already executed.
 	 */
 	private List<T> findAll(Query query) {
-		return operations.findByQuery(getJavaType()).withConsistency(buildQueryScanConsistency()).inScope(getScope())
-				.inCollection(getCollection()).matching(query).all();
+		return operations.findByQuery(getJavaType()).inScope(getScope()).inCollection(getCollection()).matching(query)
+				.withConsistency(buildQueryScanConsistency()).all();
 	}
 
 	@Override
diff --git a/src/main/java/org/springframework/data/couchbase/repository/support/SimpleReactiveCouchbaseRepository.java b/src/main/java/org/springframework/data/couchbase/repository/support/SimpleReactiveCouchbaseRepository.java
index 2aa7ac6e..0e4a2803 100644
--- a/src/main/java/org/springframework/data/couchbase/repository/support/SimpleReactiveCouchbaseRepository.java
+++ b/src/main/java/org/springframework/data/couchbase/repository/support/SimpleReactiveCouchbaseRepository.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2021 the original author or authors.
+ * Copyright 2017-2022 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,8 +16,6 @@
 
 package org.springframework.data.couchbase.repository.support;
 
-import static org.springframework.data.couchbase.repository.support.Util.hasNonZeroVersionProperty;
-
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 
@@ -28,12 +26,15 @@ import java.util.stream.Collectors;
 import org.reactivestreams.Publisher;
 import org.springframework.data.couchbase.core.CouchbaseOperations;
 import org.springframework.data.couchbase.core.ReactiveCouchbaseOperations;
+import org.springframework.data.couchbase.core.mapping.CouchbasePersistentEntity;
+import org.springframework.data.couchbase.core.mapping.CouchbasePersistentProperty;
 import org.springframework.data.couchbase.core.query.Query;
 import org.springframework.data.couchbase.repository.ReactiveCouchbaseRepository;
 import org.springframework.data.couchbase.repository.query.CouchbaseEntityInformation;
 import org.springframework.data.domain.Sort;
 import org.springframework.data.util.Streamable;
 import org.springframework.util.Assert;
+import org.springframework.util.ReflectionUtils;
 
 /**
  * Reactive repository base implementation for Couchbase.
@@ -70,17 +71,7 @@ public class SimpleReactiveCouchbaseRepository<T, ID> extends CouchbaseRepositor
 	@SuppressWarnings("unchecked")
 	@Override
 	public <S extends T> Mono<S> save(S entity) {
-		Assert.notNull(entity, "Entity must not be null!");
-		// if entity has non-null, non-zero version property, then replace()
-		Mono<S> result;
-		if (hasNonZeroVersionProperty(entity, operations.getConverter())) {
-			result = (Mono<S>) operations.replaceById(getJavaType()).inScope(getScope()).inCollection(getCollection())
-					.one(entity);
-		} else {
-			result = (Mono<S>) operations.upsertById(getJavaType()).inScope(getScope()).inCollection(getCollection())
-					.one(entity);
-		}
-		return result;
+		return save(entity, getScope(), getCollection());
 	}
 
 	@Override
@@ -91,7 +82,37 @@ public class SimpleReactiveCouchbaseRepository<T, ID> extends CouchbaseRepositor
 	@Override
 	public <S extends T> Flux<S> saveAll(Iterable<S> entities) {
 		Assert.notNull(entities, "The given Iterable of entities must not be null!");
-		return Flux.fromIterable(entities).flatMap(e -> save(e));
+		String scopeName = getScope();
+		String collection = getCollection();
+		return Flux.fromIterable(entities).flatMap(e -> save(e, scopeName, collection));
+	}
+
+	@SuppressWarnings("unchecked")
+	public <S extends T> Mono<S> save(S entity, String scopeName, String collectionName) {
+		Assert.notNull(entity, "Entity must not be null!");
+		Mono<S> result;
+		final CouchbasePersistentEntity<?> mapperEntity = operations.getConverter().getMappingContext()
+				.getPersistentEntity(entity.getClass());
+		final CouchbasePersistentProperty versionProperty = mapperEntity.getVersionProperty();
+		final boolean versionPresent = versionProperty != null;
+		final Long version = versionProperty == null || versionProperty.getField() == null ? null
+				: (Long) ReflectionUtils.getField(versionProperty.getField(), entity);
+		final boolean existingDocument = version != null && version > 0;
+
+		if (!versionPresent) { // the entity doesn't have a version property
+			// No version field - no cas
+			result = (Mono<S>) operations.upsertById(getJavaType()).inScope(scopeName).inCollection(collectionName)
+					.one(entity);
+		} else if (existingDocument) { // there is a version property, and it is non-zero
+			// Updating existing document with cas
+			result = (Mono<S>) operations.replaceById(getJavaType()).inScope(scopeName).inCollection(collectionName)
+					.one(entity);
+		} else { // there is a version property, but it's zero or not set.
+			// Creating new document
+			result = (Mono<S>) operations.insertById(getJavaType()).inScope(scopeName).inCollection(collectionName)
+					.one(entity);
+		}
+		return result;
 	}
 
 	@Override
@@ -158,7 +179,7 @@ public class SimpleReactiveCouchbaseRepository<T, ID> extends CouchbaseRepositor
 	@Override
 	public Mono<Void> delete(T entity) {
 		Assert.notNull(entity, "Entity must not be null!");
-		return operations.removeById(getJavaType()).inScope(getScope()).inCollection(getCollection()).one(getId(entity))
+		return operations.removeById(getJavaType()).inScope(getScope()).inCollection(getCollection()).oneEntity(entity)
 				.then();
 	}
 
@@ -171,7 +192,7 @@ public class SimpleReactiveCouchbaseRepository<T, ID> extends CouchbaseRepositor
 	@Override
 	public Mono<Void> deleteAll(Iterable<? extends T> entities) {
 		return operations.removeById(getJavaType()).inScope(getScope()).inCollection(getCollection())
-				.all(Streamable.of(entities).map(this::getId).toList()).then();
+				.allEntities((java.util.Collection<Object>)(Streamable.of(entities).toList())).then();
 	}
 
 	@Override
@@ -182,19 +203,19 @@ public class SimpleReactiveCouchbaseRepository<T, ID> extends CouchbaseRepositor
 
 	@Override
 	public Mono<Long> count() {
-		return operations.findByQuery(getJavaType()).withConsistency(buildQueryScanConsistency()).inScope(getScope())
-				.inCollection(getCollection()).count();
+		return operations.findByQuery(getJavaType()).inScope(getScope()).inCollection(getCollection())
+				.withConsistency(buildQueryScanConsistency()).count();
 	}
 
 	@Override
 	public Mono<Void> deleteAll() {
-		return operations.removeByQuery(getJavaType()).withConsistency(buildQueryScanConsistency()).inScope(getScope())
-				.inCollection(getCollection()).all().then();
+		return operations.removeByQuery(getJavaType()).inScope(getScope()).inCollection(getCollection())
+				.withConsistency(buildQueryScanConsistency()).all().then();
 	}
 
 	private Flux<T> findAll(Query query) {
-		return operations.findByQuery(getJavaType()).withConsistency(buildQueryScanConsistency()).inScope(getScope())
-				.inCollection(getCollection()).matching(query).all();
+		return operations.findByQuery(getJavaType()).inScope(getScope()).inCollection(getCollection()).matching(query)
+				.withConsistency(buildQueryScanConsistency()).all();
 	}
 
 	@Override
@@ -202,4 +223,26 @@ public class SimpleReactiveCouchbaseRepository<T, ID> extends CouchbaseRepositor
 		return operations;
 	}
 
+	/**
+	 * Get the TransactionalOperator from <br>
+	 * 1. The template.clientFactory<br>
+	 * 2. The template.threadLocal<br>
+	 * 3. otherwise null<br>
+	 * This can be overriden in the operation method by<br>
+	 * 1. repository.withCollection()
+	 */
+	/*
+	private CouchbaseStuffHandle getTransactionalOperator() {
+		if (operations.getCouchbaseClientFactory().getTransactionalOperator() != null) {
+			return operations.getCouchbaseClientFactory().getTransactionalOperator();
+		}
+		ReactiveCouchbaseTemplate t = (ReactiveCouchbaseTemplate) operations;
+		PseudoArgs pArgs = t.getPseudoArgs();
+		if (pArgs != null && pArgs.getTxOp() != null) {
+			return pArgs.getTxOp();
+		}
+		return null;
+	}
+	 */
+
 }
diff --git a/src/main/java/org/springframework/data/couchbase/repository/support/TransactionResultHolder.java b/src/main/java/org/springframework/data/couchbase/repository/support/TransactionResultHolder.java
new file mode 100644
index 00000000..653bba57
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/repository/support/TransactionResultHolder.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2012-2021 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.data.couchbase.repository.support;
+
+import com.couchbase.client.core.transaction.CoreTransactionGetResult;
+import com.couchbase.client.java.query.QueryResult;
+import com.couchbase.client.java.transactions.TransactionGetResult;
+import reactor.util.annotation.Nullable;
+
+/**
+ * Holds previously obtained Transaction*Result
+ *
+ * @author Michael Reiche
+ */
+public class TransactionResultHolder {
+
+	private final @Nullable CoreTransactionGetResult getResult;
+	// todo gp needed?
+	private final @Nullable QueryResult singleQueryResult;
+
+	public TransactionResultHolder(CoreTransactionGetResult getResult) {
+		// we don't need the content and we don't have access to the transcoder an txnMeta (and we don't need them either).
+		// todo gp will need to expose a copy ctor if a copy is needed
+		this.getResult = getResult;
+//		this.getResult = new TransactionGetResult(getResult.id(), null, getResult.cas(), getResult.collection(),
+//				getResult.links(), getResult.status(), getResult.documentMetadata(), null, null);
+		this.singleQueryResult = null;
+	}
+
+	public TransactionResultHolder(QueryResult singleQueryResult) {
+		this.getResult = null;
+		this.singleQueryResult = singleQueryResult;
+	}
+
+	public @Nullable CoreTransactionGetResult transactionGetResult() {
+		return getResult;
+	}
+
+	public @Nullable QueryResult singleQueryResult() {
+		return singleQueryResult;
+	}
+}
diff --git a/src/main/java/org/springframework/data/couchbase/repository/support/ViewPostProcessor.java b/src/main/java/org/springframework/data/couchbase/repository/support/ViewPostProcessor.java
index 34851e30..c0ec3516 100644
--- a/src/main/java/org/springframework/data/couchbase/repository/support/ViewPostProcessor.java
+++ b/src/main/java/org/springframework/data/couchbase/repository/support/ViewPostProcessor.java
@@ -62,7 +62,7 @@ public enum ViewPostProcessor implements RepositoryProxyPostProcessor {
 
 	/**
 	 * {@link MethodInterceptor} to inspect the currently invoked {@link Method} for a {@link View} annotation.
-	 * <p/>
+	 * <p>
 	 * If a View annotation is found, it will bind it to a locally held ThreadLocal for later lookup in the
 	 * SimpleCouchbaseRepository class.
 	 *
diff --git a/src/main/java/org/springframework/data/couchbase/transaction/CouchbaseCallbackTransactionManager.java b/src/main/java/org/springframework/data/couchbase/transaction/CouchbaseCallbackTransactionManager.java
new file mode 100644
index 00000000..19ae0a92
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/transaction/CouchbaseCallbackTransactionManager.java
@@ -0,0 +1,296 @@
+///*
+// * Copyright 2021 the original author or authors
+// *
+// * Licensed under the Apache License, Version 2.0 (the "License");
+// * you may not use this file except in compliance with the License.
+// * You may obtain a copy of the License at
+// *
+// *        https://www.apache.org/licenses/LICENSE-2.0
+// *
+// * Unless required by applicable law or agreed to in writing, software
+// * distributed under the License is distributed on an "AS IS" BASIS,
+// * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// * See the License for the specific language governing permissions and
+// * limitations under the License.
+// */
+//package org.springframework.data.couchbase.transaction;
+//
+//import com.couchbase.client.core.error.transaction.TransactionOperationFailedException;
+//import com.couchbase.client.java.transactions.ReactiveTransactionAttemptContext;
+//import com.couchbase.client.java.transactions.TransactionResult;
+//import reactor.core.publisher.Mono;
+//
+//import java.time.Duration;
+//import java.time.temporal.ChronoUnit;
+//import java.util.concurrent.atomic.AtomicReference;
+//
+//import org.slf4j.Logger;
+//import org.slf4j.LoggerFactory;
+//import org.springframework.beans.factory.DisposableBean;
+//import org.springframework.data.couchbase.CouchbaseClientFactory;
+//import org.springframework.data.couchbase.ReactiveCouchbaseClientFactory;
+//import org.springframework.data.couchbase.core.CouchbaseTemplate;
+//import org.springframework.data.couchbase.core.ReactiveCouchbaseTemplate;
+//import org.springframework.transaction.TransactionDefinition;
+//import org.springframework.transaction.TransactionException;
+//import org.springframework.transaction.reactive.TransactionContextManager;
+//import org.springframework.transaction.reactive.TransactionSynchronizationManager;
+//import org.springframework.transaction.support.AbstractPlatformTransactionManager;
+//import org.springframework.transaction.support.CallbackPreferringPlatformTransactionManager;
+//import org.springframework.transaction.support.DefaultTransactionStatus;
+//import org.springframework.transaction.support.ResourceTransactionManager;
+//import org.springframework.transaction.support.SmartTransactionObject;
+//import org.springframework.transaction.support.TransactionCallback;
+//import org.springframework.transaction.support.TransactionSynchronizationUtils;
+//import org.springframework.util.Assert;
+//
+///**
+// * Blocking TransactionManager
+// *
+// * @author Michael Nitschinger
+// * @author Michael Reiche
+// */
+//
+//public class CouchbaseCallbackTransactionManager extends AbstractPlatformTransactionManager
+//		implements DisposableBean, ResourceTransactionManager, CallbackPreferringPlatformTransactionManager {
+//
+//	private static final Logger LOGGER = LoggerFactory.getLogger(CouchbaseTransactionManager.class);
+//
+//	private final CouchbaseTemplate template;
+//	private final ReactiveCouchbaseTemplate reactiveTemplate;
+//	private final ReactiveCouchbaseClientFactory reactiveCouchbaseClientFactory;
+//	private final CouchbaseClientFactory couchbaseClientFactory;
+//
+//	private ReactiveCouchbaseTransactionManager.ReactiveCouchbaseTransactionObject transaction;
+//
+//	public CouchbaseCallbackTransactionManager(CouchbaseTemplate template, ReactiveCouchbaseTemplate reactiveTemplate) {
+//		this.template = template;
+//		this.reactiveTemplate = reactiveTemplate;
+//		this.reactiveCouchbaseClientFactory = this.reactiveTemplate.getCouchbaseClientFactory();
+//		this.couchbaseClientFactory = this.template.getCouchbaseClientFactory();
+//	}
+//
+//	public ReactiveCouchbaseTemplate template() {
+//		return reactiveTemplate;
+//	}
+//
+//	private CouchbaseResourceHolder newResourceHolder(TransactionDefinition definition, ClientSessionOptions options,
+//			ReactiveTransactionAttemptContext atr) {
+//
+//		CouchbaseClientFactory databaseFactory = template.getCouchbaseClientFactory();
+//
+//		CouchbaseResourceHolder resourceHolder = new CouchbaseResourceHolder(
+//				databaseFactory.getSession(options, atr), databaseFactory);
+//		return resourceHolder;
+//	}
+//
+//	@Override
+//	public <T> T execute(TransactionDefinition definition, TransactionCallback<T> callback) throws TransactionException {
+//		final AtomicReference<T> execResult = new AtomicReference<>();
+//		AtomicReference<Long> startTime = new AtomicReference<>(0L);
+//
+//		Mono<TransactionResult> txnResult = couchbaseClientFactory.getCluster().reactive().transactions().run(ctx -> {
+//			/* begin spring-data-couchbase transaction 1/2 */
+//			ClientSession clientSession = reactiveCouchbaseClientFactory // couchbaseClientFactory
+//					.getSession(ClientSessionOptions.builder().causallyConsistent(true).build())
+//					.block();
+//			ReactiveCouchbaseResourceHolder reactiveResourceHolder = new ReactiveCouchbaseResourceHolder(clientSession,
+//					reactiveCouchbaseClientFactory);
+//
+//			CouchbaseResourceHolder resourceHolder = new CouchbaseResourceHolder(clientSession,
+//					template.getCouchbaseClientFactory());
+//
+//			Mono<TransactionSynchronizationManager> sync = TransactionContextManager.currentContext()
+//					.map(TransactionSynchronizationManager::new)
+//					.<TransactionSynchronizationManager> flatMap(synchronizationManager -> {
+//						System.err.println("CallbackTransactionManager: " + this);
+//						System.err.println("bindResource: " + reactiveCouchbaseClientFactory.getCluster().block());
+//						// todo gp not sure why we bind, unbind, bind again?
+//            // todo msr - to avoid the NotBound exception on unbind. Should use unbindIfPossible.
+//						synchronizationManager.bindResource(reactiveCouchbaseClientFactory.getCluster().block(),
+//								reactiveResourceHolder);
+//						org.springframework.transaction.support.TransactionSynchronizationManager
+//								.unbindResourceIfPossible(reactiveCouchbaseClientFactory.getCluster().block());
+//						org.springframework.transaction.support.TransactionSynchronizationManager
+//						 .bindResource(reactiveCouchbaseClientFactory.getCluster().block(), resourceHolder);
+//						ReactiveCouchbaseTransactionManager.ReactiveCouchbaseTransactionObject transaction = new ReactiveCouchbaseTransactionManager.ReactiveCouchbaseTransactionObject(
+//								reactiveResourceHolder);
+//						setTransaction(transaction);
+//
+//						// todo gp experimenting with replacing the ClientSession, the ReactiveCouchbaseTransactionObject,
+//						// the resource holders etc., with just storing the TransactionAttemptContext.
+//						synchronizationManager.bindResource(ReactiveTransactionAttemptContext.class, ctx);
+//
+//						/* end spring-data-couchbase transaction  1/2 */
+//
+//						// todo gp do we need TransactionSynchronizationManager.forCurrentTransaction()? as we already have synchronizationManager
+//						Mono<Void> result = TransactionSynchronizationManager.forCurrentTransaction().flatMap((sm) -> {
+//							// todo gp not sure why re-binding again?
+//							sm.unbindResourceIfPossible(reactiveCouchbaseClientFactory.getCluster().block());
+//							sm.bindResource(reactiveCouchbaseClientFactory.getCluster().block(),
+//									reactiveResourceHolder);
+//							CouchbaseTransactionStatus status = new CouchbaseTransactionStatus(transaction, true, false, false, true, null, sm);
+//							prepareSynchronization(status, new CouchbaseTransactionDefinition());
+//							// System.err.println("deferContextual.ctx : " + xxx);
+//							//Mono<ContextView> cxView = Mono.deferContextual(cx -> { System.err.println("CallbackTransactionManager.cx: "+cx); return Mono.just(cx);});
+//							try {
+//								// Since we are on a different thread now transparently, at least make sure
+//								// that the original method invocation is synchronized.
+//								synchronized (this) {
+//									// todo gp this will execute the lambda, and so we likely don't want that to be inside a synchronized block
+//									execResult.set(callback.doInTransaction(status));
+//								}
+//							} catch (RuntimeException e) {
+//								throw e;
+//							} catch (Throwable e) {
+//								throw new RuntimeException(e);
+//							}
+//							return Mono.empty();
+//						}).contextWrite(TransactionContextManager.getOrCreateContext()) // this doesn't create a context on the desired publisher
+//								.contextWrite(TransactionContextManager.getOrCreateContextHolder()).then();
+//
+//						// todo gp this isn't part of the chain (no `result = result.onErrorResume...`) so isn't called
+//						// and presumably isn't needed?
+////						result.onErrorResume(err -> {
+////							AttemptContextReactiveAccessor.getLogger(ctx).info(ctx.attemptId(),
+////									"caught exception '%s' in async, rethrowing", err);
+////							return Mono.error(ctx.TransactionOperationFailedException.convertToOperationFailedIfNeeded(err, ctx));
+////						}).thenReturn(ctx);
+//
+//						return result.then(Mono.just(synchronizationManager));
+//					});
+//			/* begin spring-data-couchbase transaction  2/2 */  // this doesn't create a context on the desired publisher
+//			return sync.contextWrite(TransactionContextManager.getOrCreateContext())
+//					.contextWrite(TransactionContextManager.getOrCreateContextHolder()).then();
+//			/* end spring-data-couchbase transaction 2/2 */
+//		}).doOnSubscribe(v -> startTime.set(System.nanoTime()));
+//
+//		txnResult.block();
+//		return execResult.get(); // transactions.reactive().executeTransaction(merged,overall,ob).doOnNext(v->overall.span().finish()).doOnError(err->overall.span().failWith(err));});
+//
+//	}
+//
+//	private void setTransaction(ReactiveCouchbaseTransactionManager.ReactiveCouchbaseTransactionObject transaction) {
+//		this.transaction = transaction;
+//	}
+//
+//	@Override
+//	protected ReactiveCouchbaseTransactionManager.ReactiveCouchbaseTransactionObject doGetTransaction()
+//			throws TransactionException {
+//		/*
+//		CouchbaseResourceHolder resourceHolder = (CouchbaseResourceHolder) TransactionSynchronizationManager
+//				.getResource(template.getCouchbaseClientFactory());
+//		return new CouchbaseTransactionManager.CouchbaseTransactionObject(resourceHolder);
+//		*/
+//		return (ReactiveCouchbaseTransactionManager.ReactiveCouchbaseTransactionObject) transaction;
+//	}
+//
+//	@Override
+//	protected boolean isExistingTransaction(Object transaction) throws TransactionException {
+//		return extractTransaction(transaction).hasResourceHolder();
+//	}
+//
+//	@Override
+//	protected void doBegin(Object transaction, TransactionDefinition definition) throws TransactionException {
+//		LOGGER.debug("Beginning Couchbase Transaction with Definition {}", definition);
+//	}
+//
+//	@Override
+//	protected void doCommit(DefaultTransactionStatus status) throws TransactionException {
+//		LOGGER.debug("Committing Couchbase Transaction with status {}", status);
+//	}
+//
+//	@Override
+//	protected void doRollback(DefaultTransactionStatus status) throws TransactionException {
+//		LOGGER.warn("Rolling back Couchbase Transaction with status {}", status);
+//		org.springframework.transaction.support.TransactionSynchronizationManager
+//				.unbindResource(reactiveCouchbaseClientFactory);
+//	}
+//
+//	@Override
+//	protected void doCleanupAfterCompletion(Object transaction) {
+//		LOGGER.trace("Performing cleanup of Couchbase Transaction {}", transaction);
+//		org.springframework.transaction.support.TransactionSynchronizationManager
+//				.unbindResource(reactiveCouchbaseClientFactory);
+//		return;
+//	}
+//
+//	@Override
+//	public void destroy() {
+//	}
+//
+//	@Override
+//	public Object getResourceFactory() {
+//		return reactiveTemplate.getCouchbaseClientFactory();
+//	}
+//
+//	private static CouchbaseTransactionObject extractTransaction(Object transaction) {
+//		Assert.isInstanceOf(CouchbaseTransactionObject.class, transaction,
+//				() -> String.format("Expected to find a %s but it turned out to be %s.", CouchbaseTransactionObject.class,
+//						transaction.getClass()));
+//
+//		return (CouchbaseTransactionObject) transaction;
+//	}
+//	/*
+//	public class CouchbaseResourceHolder extends ResourceHolderSupport {
+//
+//	  private volatile ReactiveTransactionAttemptContext attemptContext;
+//	  //private volatile TransactionResultMap resultMap = new TransactionResultMap(template);
+//
+//	  public CouchbaseResourceHolder(ReactiveTransactionAttemptContext attemptContext) {
+//	    this.attemptContext = attemptContext;
+//	  }
+//
+//	  public ReactiveTransactionAttemptContext getAttemptContext() {
+//	    return attemptContext;
+//	  }
+//
+//	  public void setAttemptContext(ReactiveTransactionAttemptContext attemptContext) {
+//	    this.attemptContext = attemptContext;
+//	  }
+//
+//	  //public TransactionResultMap getTxResultMap() {
+//	  //  return resultMap;
+//	  //}
+//
+//	  @Override
+//	  public String toString() {
+//	    return "CouchbaseResourceHolder{" + "attemptContext=" + attemptContext + "}";
+//	  }
+//	}
+//
+//	 */
+//
+//	protected static class CouchbaseTransactionObject implements SmartTransactionObject {
+//
+//		private final CouchbaseResourceHolder resourceHolder;
+//
+//		CouchbaseTransactionObject(CouchbaseResourceHolder resourceHolder) {
+//			this.resourceHolder = resourceHolder;
+//		}
+//
+//		@Override
+//		public boolean isRollbackOnly() {
+//			return this.resourceHolder != null && this.resourceHolder.isRollbackOnly();
+//		}
+//
+//		@Override
+//		public void flush() {
+//			TransactionSynchronizationUtils.triggerFlush();
+//		}
+//
+//		public boolean hasResourceHolder() {
+//			return resourceHolder != null;
+//		}
+//
+//		@Override
+//		public String toString() {
+//			return "CouchbaseTransactionObject{" + "resourceHolder=" + resourceHolder + '}';
+//		}
+//	}
+//
+//	private static Duration now() {
+//		return Duration.of(System.nanoTime(), ChronoUnit.NANOS);
+//	}
+//
+//}
diff --git a/src/main/java/org/springframework/data/couchbase/transaction/CouchbaseResourceHolderx.java b/src/main/java/org/springframework/data/couchbase/transaction/CouchbaseResourceHolderx.java
new file mode 100644
index 00000000..a4ba0457
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/transaction/CouchbaseResourceHolderx.java
@@ -0,0 +1,120 @@
+/*
+   * Copyright 2019-2021 the original author or authors.
+   *
+   * Licensed under the Apache License, Version 2.0 (the "License");
+   * you may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at
+   *
+   *      https://www.apache.org/licenses/LICENSE-2.0
+   *
+   * Unless required by applicable law or agreed to in writing, software
+   * distributed under the License is distributed on an "AS IS" BASIS,
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   */
+
+package org.springframework.data.couchbase.transaction;
+
+import org.springframework.data.couchbase.CouchbaseClientFactory;
+import org.springframework.data.couchbase.core.CouchbaseTemplate;
+import org.springframework.lang.Nullable;
+import org.springframework.transaction.support.ResourceHolderSupport;
+
+import com.couchbase.client.core.transaction.CoreTransactionAttemptContext;
+
+/**
+ * MongoDB specific resource holder, wrapping a {@link CoreTransactionAttemptContext}.
+ * {@link ReactiveCouchbaseTransactionManager} binds instances of this class to the subscriber context.
+ * <p />
+ * <strong>Note:</strong> Intended for internal usage only.
+ *
+ * @author Mark Paluch
+ * @author Christoph Strobl
+ * @since 2.2
+ * @see CouchbaseTransactionManager
+ * @see CouchbaseTemplate
+ */
+// todo gp understand why this is needed - can we not just hold ctx in Mono context?
+public class CouchbaseResourceHolderx extends ResourceHolderSupport {
+
+	private @Nullable CoreTransactionAttemptContext core; // which holds the atr
+	private CouchbaseClientFactory databaseFactory;
+
+	/**
+	 * Create a new {@link org.springframework.data.couchbase.transaction.ReactiveCouchbaseResourceHolder} for a given
+	 * {@link CoreTransactionAttemptContext session}.
+	 *
+	 * @param core the associated {@link CoreTransactionAttemptContext}. Can be {@literal null}.
+	 * @param databaseFactory the associated {@link CouchbaseClientFactory}. must not be {@literal null}.
+	 */
+	public CouchbaseResourceHolderx(@Nullable CoreTransactionAttemptContext core, CouchbaseClientFactory databaseFactory) {
+
+		this.core = core;
+		this.databaseFactory = databaseFactory;
+	}
+
+	/**
+	 * @return the associated {@link CoreTransactionAttemptContext}. Can be {@literal null}.
+	 */
+	@Nullable
+	public CoreTransactionAttemptContext getCore() {
+		return core;
+	}
+
+	/**
+	 * @return the required associated {@link CoreTransactionAttemptContext}.
+	 * @throws IllegalStateException if no session is associated.
+	 */
+	CoreTransactionAttemptContext getRequiredSession() {
+
+		CoreTransactionAttemptContext session = getCore();
+
+		if (session == null) {
+			throw new IllegalStateException("No ClientSession associated");
+		}
+		return session;
+	}
+
+	/**
+	 * @return the associated {@link CouchbaseClientFactory}.
+	 */
+	public CouchbaseClientFactory getDatabaseFactory() {
+		return databaseFactory;
+	}
+
+	/**
+	 * Set the {@link CoreTransactionAttemptContext} to guard.
+	 *
+	 * @param core can be {@literal null}.
+	 */
+	public void setCore(@Nullable CoreTransactionAttemptContext core) {
+		this.core = core;
+	}
+
+	/**
+	 * @return {@literal true} if session is not {@literal null}.
+	 */
+	boolean hasCore() {
+		return core != null;
+	}
+
+	/**
+	 * If the {@link org.springframework.data.couchbase.transaction.ReactiveCouchbaseResourceHolder} is {@link #hasCore()}
+	 * not already associated} with a {@link CoreTransactionAttemptContext} the given value is
+	 * {@link #setCore(CoreTransactionAttemptContext) set} and returned, otherwise the current bound session is returned.
+	 *
+	 * @param core
+	 * @return
+	 */
+	@Nullable
+	public CoreTransactionAttemptContext setSessionIfAbsent(@Nullable CoreTransactionAttemptContext core) {
+
+		if (!hasCore()) {
+			setCore(core);
+		}
+
+		return core;
+	}
+
+}
diff --git a/src/main/java/org/springframework/data/couchbase/transaction/CouchbaseSimpleCallbackTransactionManager.java b/src/main/java/org/springframework/data/couchbase/transaction/CouchbaseSimpleCallbackTransactionManager.java
new file mode 100644
index 00000000..772ed285
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/transaction/CouchbaseSimpleCallbackTransactionManager.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright 2021 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.couchbase.transaction;
+
+import com.couchbase.client.core.transaction.CoreTransactionAttemptContext;
+import com.couchbase.client.java.transactions.AttemptContextReactiveAccessor;
+import com.couchbase.client.java.transactions.ReactiveTransactionAttemptContext;
+import com.couchbase.client.java.transactions.TransactionAttemptContext;
+import com.couchbase.client.java.transactions.TransactionResult;
+import com.couchbase.client.java.transactions.config.TransactionOptions;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.data.couchbase.CouchbaseClientFactory;
+import org.springframework.data.couchbase.ReactiveCouchbaseClientFactory;
+import org.springframework.lang.Nullable;
+import org.springframework.transaction.IllegalTransactionStateException;
+import org.springframework.transaction.InvalidTimeoutException;
+import org.springframework.transaction.PlatformTransactionManager;
+import org.springframework.transaction.TransactionDefinition;
+import org.springframework.transaction.TransactionException;
+import org.springframework.transaction.TransactionStatus;
+import org.springframework.transaction.reactive.TransactionContextManager;
+import org.springframework.transaction.support.AbstractPlatformTransactionManager;
+import org.springframework.transaction.support.CallbackPreferringPlatformTransactionManager;
+import org.springframework.transaction.support.DefaultTransactionStatus;
+import org.springframework.transaction.support.TransactionCallback;
+import org.springframework.transaction.support.TransactionSynchronizationManager;
+import org.springframework.util.Assert;
+import reactor.core.publisher.Mono;
+
+import java.lang.reflect.Field;
+import java.time.Duration;
+import java.util.concurrent.atomic.AtomicReference;
+
+public class CouchbaseSimpleCallbackTransactionManager implements CallbackPreferringPlatformTransactionManager {
+
+	private static final Logger LOGGER = LoggerFactory.getLogger(CouchbaseTransactionManager.class);
+
+	private final ReactiveCouchbaseClientFactory couchbaseClientFactory;
+	private TransactionOptions options;
+
+	public CouchbaseSimpleCallbackTransactionManager(ReactiveCouchbaseClientFactory couchbaseClientFactory, TransactionOptions options) {
+		this.couchbaseClientFactory = couchbaseClientFactory;
+		this.options = options;
+	}
+
+	@Override
+	public <T> T execute(TransactionDefinition definition, TransactionCallback<T> callback) throws TransactionException {
+		final AtomicReference<T> execResult = new AtomicReference<>();
+
+		setOptionsFromDefinition(definition);
+
+		TransactionResult result = couchbaseClientFactory.getCluster().block().transactions().run(ctx -> {
+			CouchbaseTransactionStatus status = new CouchbaseTransactionStatus(null, true, false, false, true, null, null);
+
+			populateTransactionSynchronizationManager(ctx);
+
+			try {
+				execResult.set(callback.doInTransaction(status));
+			}
+			finally {
+				TransactionSynchronizationManager.clear();
+			}
+		}, this.options);
+
+		TransactionSynchronizationManager.clear();
+
+		return execResult.get();
+	}
+
+	/**
+	 * @param definition reflects the @Transactional options
+	 */
+	private void setOptionsFromDefinition(TransactionDefinition definition) {
+		if (definition != null) {
+			if (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) {
+				options = options.timeout(Duration.ofSeconds(definition.getTimeout()));
+			}
+
+			if (!(definition.getIsolationLevel() == TransactionDefinition.ISOLATION_DEFAULT
+					|| definition.getIsolationLevel() == TransactionDefinition.ISOLATION_READ_COMMITTED)) {
+				throw new IllegalArgumentException("Couchbase Transactions run at Read Committed isolation - other isolation levels are not supported");
+			}
+
+			// readonly is ignored as it is documented as being a hint that won't necessarily cause writes to fail
+
+			// todo gpx what about propagation?
+		}
+
+	}
+
+	// Setting ThreadLocal storage
+	private void populateTransactionSynchronizationManager(TransactionAttemptContext ctx) {
+		TransactionSynchronizationManager.setActualTransactionActive(true);
+		TransactionSynchronizationManager.initSynchronization();
+		ReactiveCouchbaseResourceHolder resourceHolder = new ReactiveCouchbaseResourceHolder(AttemptContextReactiveAccessor.getCore(ctx));
+		TransactionSynchronizationManager.unbindResourceIfPossible(couchbaseClientFactory.getCluster().block());
+		TransactionSynchronizationManager.bindResource(couchbaseClientFactory.getCluster().block(), resourceHolder);
+	}
+
+	/**
+	 * Test transaction infrastructure uses this to determine if transaction is active
+	 *
+	 * @param definition
+	 * @return
+	 * @throws TransactionException
+	 */
+	@Override
+	public TransactionStatus getTransaction(@Nullable TransactionDefinition definition)
+			throws TransactionException {
+		TransactionStatus status = new DefaultTransactionStatus(		null, true, true,
+				false, true, false);
+		return status;
+	}
+
+	@Override
+	public void commit(TransactionStatus status) throws TransactionException {
+		// todo gpx somewhat nervous that commit/rollback/getTransaction are all left empty but things seem to be working
+		// anyway... - what are these used for exactly?
+		LOGGER.debug("NO-OP: Committing Couchbase Transaction with status {}", status);
+	}
+
+	@Override
+	public void rollback(TransactionStatus status) throws TransactionException {
+		LOGGER.warn("NO-OP: Rolling back Couchbase Transaction with status {}", status);
+	}
+
+}
diff --git a/src/main/java/org/springframework/data/couchbase/transaction/CouchbaseSimpleTransactionManager.java b/src/main/java/org/springframework/data/couchbase/transaction/CouchbaseSimpleTransactionManager.java
new file mode 100644
index 00000000..1947cb7a
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/transaction/CouchbaseSimpleTransactionManager.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2018-2021 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.data.couchbase.transaction;
+
+import org.springframework.data.couchbase.CouchbaseClientFactory;
+import org.springframework.transaction.PlatformTransactionManager;
+import org.springframework.transaction.TransactionDefinition;
+import org.springframework.transaction.TransactionException;
+import org.springframework.transaction.TransactionStatus;
+import org.springframework.transaction.TransactionSystemException;
+
+// todo gp experimenting with the simplest possible class, extending PlatformTransactionManager not AbstractPlatformTransactionManager
+public class CouchbaseSimpleTransactionManager implements PlatformTransactionManager {
+
+	private final CouchbaseClientFactory clientFactory;
+
+	public CouchbaseSimpleTransactionManager(CouchbaseClientFactory clientFactory) {
+		this.clientFactory = clientFactory;
+	}
+
+	@Override
+	public TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException {
+		return null;
+	}
+
+	@Override
+	public void commit(TransactionStatus status) throws TransactionException {
+		// todo gp what here - do we need to re-allow explicit commit? how to handle retries of this part?
+	}
+
+	@Override
+	public void rollback(TransactionStatus status) throws TransactionException {
+		// todo gp same as commit()
+	}
+}
diff --git a/src/main/java/org/springframework/data/couchbase/transaction/CouchbaseTransactionDefinition.java b/src/main/java/org/springframework/data/couchbase/transaction/CouchbaseTransactionDefinition.java
new file mode 100644
index 00000000..d46d73bc
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/transaction/CouchbaseTransactionDefinition.java
@@ -0,0 +1,37 @@
+package org.springframework.data.couchbase.transaction;
+
+import com.couchbase.client.java.transactions.ReactiveTransactionAttemptContext;
+import com.couchbase.client.java.transactions.TransactionAttemptContext;
+import org.springframework.transaction.TransactionDefinition;
+import org.springframework.transaction.support.DefaultTransactionDefinition;
+
+public class CouchbaseTransactionDefinition extends DefaultTransactionDefinition {
+
+  ReactiveTransactionAttemptContext atr;
+  TransactionAttemptContext at;
+
+  public CouchbaseTransactionDefinition(){
+    super();
+    setIsolationLevel(ISOLATION_READ_COMMITTED);
+  }
+
+  public CouchbaseTransactionDefinition(TransactionDefinition that) {
+    super(that);
+  }
+
+  public CouchbaseTransactionDefinition(int propagationBehavior) {
+    super(propagationBehavior);
+  }
+
+  public void setAttemptContextReactive(ReactiveTransactionAttemptContext atr){
+    this.atr = atr;
+  }
+
+  public ReactiveTransactionAttemptContext getAttemptContextReactive(){
+    return atr;
+  }
+
+  public void setAttemptContext(TransactionAttemptContext attemptContext) {
+    at = attemptContext;
+  }
+}
diff --git a/src/main/java/org/springframework/data/couchbase/transaction/CouchbaseTransactionManager.java b/src/main/java/org/springframework/data/couchbase/transaction/CouchbaseTransactionManager.java
new file mode 100644
index 00000000..3f5d7a39
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/transaction/CouchbaseTransactionManager.java
@@ -0,0 +1,507 @@
+/*
+ * Copyright 2018-2021 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.data.couchbase.transaction;
+
+import com.couchbase.client.core.transaction.CoreTransactionAttemptContext;
+import com.couchbase.client.java.transactions.ReactiveTransactionAttemptContext;
+import com.couchbase.client.java.transactions.TransactionAttemptContext;
+import com.couchbase.client.java.transactions.Transactions;
+import com.couchbase.client.java.transactions.config.TransactionOptions;
+import org.springframework.beans.factory.InitializingBean;
+import org.springframework.data.couchbase.CouchbaseClientFactory;
+import org.springframework.lang.Nullable;
+import org.springframework.transaction.TransactionDefinition;
+import org.springframework.transaction.TransactionException;
+import org.springframework.transaction.TransactionSystemException;
+import org.springframework.transaction.support.AbstractPlatformTransactionManager;
+import org.springframework.transaction.support.DefaultTransactionStatus;
+import org.springframework.transaction.support.ResourceTransactionManager;
+import org.springframework.transaction.support.SmartTransactionObject;
+import org.springframework.transaction.support.TransactionSynchronizationManager;
+import org.springframework.transaction.support.TransactionSynchronizationUtils;
+import org.springframework.util.Assert;
+import org.springframework.util.ClassUtils;
+
+import com.couchbase.client.core.error.CouchbaseException;
+import reactor.core.publisher.Mono;
+
+/**
+ * A {@link org.springframework.transaction.PlatformTransactionManager} implementation that manages
+ * {@link CoreTransactionAttemptContext} based transactions for a single {@link CouchbaseClientFactory}.
+ * <p />
+ * Binds a {@link CoreTransactionAttemptContext} from the specified {@link CouchbaseClientFactory} to the thread.
+ * <p />
+ * {@link TransactionDefinition#isReadOnly() Readonly} transactions operate on a {@link CoreTransactionAttemptContext} and enable causal
+ * consistency, and also {@link CoreTransactionAttemptContext#startTransaction() start}, {@link CoreTransactionAttemptContext#commitTransaction()
+ * commit} or {@link CoreTransactionAttemptContext#abortTransaction() abort} a transaction.
+ * <p />
+ * TODO: Application code is required to retrieve the {@link com.couchbase.client.java.Cluster} ????? via
+ * {@link ?????#getDatabase(CouchbaseClientFactory)} instead of a standard {@link CouchbaseClientFactory#getCluster()}
+ * call. Spring classes such as {@link org.springframework.data.couchbase.core.CouchbaseTemplate} use this strategy
+ * implicitly.
+ * <p />
+ * By default failure of a {@literal commit} operation raises a {@link TransactionSystemException}. One may override
+ * {@link #doCommit(CouchbaseTransactionObject)} to implement the
+ * <a href="https://docs.mongodb.com/manual/core/transactions/#retry-commit-operation">Retry Commit Operation</a>
+ * behavior as outlined in the MongoDB reference manual.
+ *
+ * @author Christoph Strobl
+ * @author Mark Paluch
+ * @since 2.1
+ * @see <a href="https://www.mongodb.com/transactions">MongoDB Transaction Documentation</a>
+ * @see MongoDatabaseUtils#getDatabase(CouchbaseClientFactory, SessionSynchronization)
+ */
+// todo gp is this needed, or can we only have the CallbackPreferring one?
+public class CouchbaseTransactionManager extends AbstractPlatformTransactionManager
+		implements ResourceTransactionManager, InitializingBean {
+
+	private Transactions transactions;
+	private @Nullable CouchbaseClientFactory databaseFactory;
+	private @Nullable TransactionOptions options;
+
+	/**
+	 * Create a new {@link CouchbaseTransactionManager} for bean-style usage.
+	 * <p />
+	 * <strong>Note:</strong>The {@link CouchbaseClientFactory db factory} has to be
+	 * {@link #setDbFactory(CouchbaseClientFactory) set} before using the instance. Use this constructor to prepare a
+	 * {@link CouchbaseTransactionManager} via a {@link org.springframework.beans.factory.BeanFactory}.
+	 * <p />
+	 * TODO: Optionally it is possible to set default {@link TransactionOptions transaction options} defining TODO:
+	 * {@link ReadConcern} and {@link WriteConcern}.
+	 *
+	 * @see #setDbFactory(CouchbaseClientFactory)
+	 * @see #setTransactionSynchronization(int)
+	 */
+	public CouchbaseTransactionManager() {}
+
+	/**
+	 * Create a new {@link CouchbaseTransactionManager} obtaining sessions from the given {@link CouchbaseClientFactory}
+	 * applying the given {@link TransactionOptions options}, if present, when starting a new transaction.
+	 *
+	 * @param databaseFactory must not be {@literal null}. @//param options can be {@literal null}.
+	 */
+	public CouchbaseTransactionManager(CouchbaseClientFactory databaseFactory, @Nullable TransactionOptions options) {
+
+		Assert.notNull(databaseFactory, "DbFactory must not be null!");
+		System.err.println(this);
+		System.err.println(databaseFactory.getCluster());
+		this.databaseFactory = databaseFactory;
+		this.options = options;
+		this.transactions = databaseFactory.getCluster().transactions();
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * org.springframework.transaction.support.AbstractPlatformTransactionManager#doGetTransaction()
+	 */
+	@Override
+	protected Object doGetTransaction() throws TransactionException {
+		ReactiveCouchbaseResourceHolder resourceHolder = (ReactiveCouchbaseResourceHolder) TransactionSynchronizationManager
+				.getResource(getRequiredDatabaseFactory().getCluster());
+		return new CouchbaseTransactionObject(resourceHolder);
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * org.springframework.transaction.support.AbstractPlatformTransactionManager#isExistingTransaction(java.lang.Object)
+	 */
+	@Override
+	protected boolean isExistingTransaction(Object transaction) throws TransactionException {
+		return extractCouchbaseTransaction(transaction).hasResourceHolder();
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * org.springframework.transaction.support.AbstractPlatformTransactionManager#doBegin(java.lang.Object, org.springframework.transaction.TransactionDefinition)
+	 */
+	@Override
+	protected void doBegin(Object transaction, TransactionDefinition definition) throws TransactionException {
+
+		CouchbaseTransactionObject couchbaseTransactionObject = extractCouchbaseTransaction(transaction);
+// 	should ACR already be in TSM?	TransactionSynchronizationManager.bindResource(getRequiredDbFactory().getCluster(), resourceHolder);
+		ReactiveCouchbaseResourceHolder resourceHolder = newResourceHolder(getDatabaseFactory(), definition, TransactionOptions.transactionOptions(),
+				null /* ((CouchbaseTransactionDefinition) definition).getAttemptContextReactive()*/);
+		couchbaseTransactionObject.setResourceHolder(resourceHolder);
+
+		if (logger.isDebugEnabled()) {
+			logger
+					.debug(String.format("About to start transaction for session %s.", debugString(resourceHolder.getCore())));
+		}
+
+		try {
+			couchbaseTransactionObject.startTransaction(options);
+		} catch (CouchbaseException ex) {
+			throw new TransactionSystemException(String.format("Could not start Mongo transaction for session %s.",
+					debugString(couchbaseTransactionObject.getCore())), ex);
+		}
+
+		if (logger.isDebugEnabled()) {
+			logger.debug(String.format("Started transaction for session %s.", debugString(resourceHolder.getCore())));
+		}
+
+		TransactionSynchronizationManager.setActualTransactionActive(true);
+		resourceHolder.setSynchronizedWithTransaction(true);
+		TransactionSynchronizationManager.unbindResourceIfPossible(getRequiredDatabaseFactory().getCluster());
+		System.err.println("CouchbaseTransactionManager: " + this);
+		System.err.println("bindResource: " + getRequiredDatabaseFactory().getCluster() + " value: " + resourceHolder);
+		TransactionSynchronizationManager.bindResource(getRequiredDatabaseFactory().getCluster(), resourceHolder);
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * org.springframework.transaction.support.AbstractPlatformTransactionManager#doSuspend(java.lang.Object)
+	 */
+	@Override
+	protected Object doSuspend(Object transaction) throws TransactionException {
+
+		CouchbaseTransactionObject couchbaseTransactionObject = extractCouchbaseTransaction(transaction);
+		couchbaseTransactionObject.setResourceHolder(null);
+
+		return TransactionSynchronizationManager.unbindResource(getRequiredDatabaseFactory().getCluster());
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * org.springframework.transaction.support.AbstractPlatformTransactionManager#doResume(java.lang.Object, java.lang.Object)
+	 */
+	@Override
+	protected void doResume(@Nullable Object transaction, Object suspendedResources) {
+		TransactionSynchronizationManager.bindResource(getRequiredDatabaseFactory().getCluster(), suspendedResources);
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * org.springframework.transaction.support.AbstractPlatformTransactionManager#doCommit(org.springframework.transaction.support.DefaultTransactionStatus)
+	 */
+	@Override
+	protected final void doCommit(DefaultTransactionStatus status) throws TransactionException {
+
+		CouchbaseTransactionObject couchbaseTransactionObject = extractCouchbaseTransaction(status);
+
+		if (logger.isDebugEnabled()) {
+			logger.debug(String.format("About to commit transaction for session %s.",
+					debugString(couchbaseTransactionObject.getCore())));
+		}
+
+		try {
+			doCommit(couchbaseTransactionObject);
+		} catch (Exception ex) {
+			logger.debug("could not commit Couchbase transaction for session "+debugString(couchbaseTransactionObject.getCore()));
+			throw new TransactionSystemException(String.format("Could not commit Couchbase transaction for session %s.",
+					debugString(couchbaseTransactionObject.getCore())), ex);
+		}
+	}
+
+	/**
+	 * Customization hook to perform an actual commit of the given transaction.<br />
+	 * If a commit operation encounters an error, the MongoDB driver throws a {@link CouchbaseException} holding
+	 * {@literal error labels}. <br />
+	 * By default those labels are ignored, nevertheless one might check for
+	 * {@link CouchbaseException transient commit errors labels} and retry the the
+	 * commit. <br />
+	 * <code>
+	 *     <pre>
+	 * int retries = 3;
+	 * do {
+	 *     try {
+	 *         transactionObject.commitTransaction();
+	 *         break;
+	 *     } catch (CouchbaseException ex) {
+	 *         if (!ex.hasErrorLabel(CouchbaseException.UNKNOWN_TRANSACTION_COMMIT_RESULT_LABEL)) {
+	 *             throw ex;
+	 *         }
+	 *     }
+	 *     Thread.sleep(500);
+	 * } while (--retries > 0);
+	 *     </pre>
+	 * </code>
+	 *
+	 * @param transactionObject never {@literal null}.
+	 * @throws Exception in case of transaction errors.
+	 */
+	protected void doCommit(CouchbaseTransactionObject transactionObject) throws Exception {
+		transactionObject.commitTransaction();
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * org.springframework.transaction.support.AbstractPlatformTransactionManager#doRollback(org.springframework.transaction.support.DefaultTransactionStatus)
+	 */
+	@Override
+	protected void doRollback(DefaultTransactionStatus status) throws TransactionException {
+
+		CouchbaseTransactionObject couchbaseTransactionObject = extractCouchbaseTransaction(status);
+
+		if (logger.isDebugEnabled()) {
+			logger.debug(String.format("About to abort transaction for session %s.",
+					debugString(couchbaseTransactionObject.getCore())));
+		}
+
+		try {
+			couchbaseTransactionObject.abortTransaction();
+		} catch (CouchbaseException ex) {
+
+			throw new TransactionSystemException(String.format("Could not abort Couchbase transaction for session %s.",
+					debugString(couchbaseTransactionObject.getCore())), ex);
+		}
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * org.springframework.transaction.support.AbstractPlatformTransactionManager#doSetRollbackOnly(org.springframework.transaction.support.DefaultTransactionStatus)
+	 */
+	@Override
+	protected void doSetRollbackOnly(DefaultTransactionStatus status) throws TransactionException {
+
+		CouchbaseTransactionObject transactionObject = extractCouchbaseTransaction(status);
+		throw new TransactionException("need to setRollbackOnly() here"){};
+		//transactionObject.getRequiredResourceHolder().setRollbackOnly();
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * org.springframework.transaction.support.AbstractPlatformTransactionManager#doCleanupAfterCompletion(java.lang.Object)
+	 */
+	@Override
+	protected void doCleanupAfterCompletion(Object transaction) {
+
+		Assert.isInstanceOf(CouchbaseTransactionObject.class, transaction,
+				() -> String.format("Expected to find a %s but it turned out to be %s.", CouchbaseTransactionObject.class,
+						transaction.getClass()));
+
+		CouchbaseTransactionObject couchbaseTransactionObject = (CouchbaseTransactionObject) transaction;
+
+		// Remove the connection holder from the thread.
+		TransactionSynchronizationManager.unbindResourceIfPossible(getRequiredDatabaseFactory().getCluster());
+		//couchbaseTransactionObject.getRequiredResourceHolder().clear();
+
+		if (logger.isDebugEnabled()) {
+			logger.debug(String.format("About to release Core %s after transaction.",
+					debugString(couchbaseTransactionObject.getCore())));
+		}
+
+		couchbaseTransactionObject.closeSession();
+	}
+
+	/**
+	 * Set the {@link CouchbaseClientFactory} that this instance should manage transactions for.
+	 *
+	 * @param databaseFactory must not be {@literal null}.
+	 */
+	public void setDbFactory(CouchbaseClientFactory databaseFactory) {
+
+		Assert.notNull(databaseFactory, "DbFactory must not be null!");
+		this.databaseFactory = databaseFactory;
+	}
+
+	/**
+	 * Set the {@link TransactionOptions} to be applied when starting transactions.
+	 *
+	 * @param options can be {@literal null}.
+	 */
+	public void setOptions(@Nullable TransactionOptions options) {
+		this.options = options;
+	}
+
+	/**
+	 * Get the {@link CouchbaseClientFactory} that this instance manages transactions for.
+	 *
+	 * @return can be {@literal null}.
+	 */
+	@Nullable
+	public CouchbaseClientFactory getDbFactory() {
+		return databaseFactory;
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * @see org.springframework.transaction.support.ResourceTransactionManager#getResourceFactory()
+	 */
+	@Override
+	public CouchbaseClientFactory getResourceFactory() {
+		return getRequiredDatabaseFactory();
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet()
+	 */
+	@Override
+	public void afterPropertiesSet() {
+		getRequiredDatabaseFactory();
+	}
+
+	static ReactiveCouchbaseResourceHolder newResourceHolder(CouchbaseClientFactory databaseFactory, TransactionDefinition definition,
+			TransactionOptions options, CoreTransactionAttemptContext atr) {
+		ReactiveCouchbaseResourceHolder resourceHolder = new ReactiveCouchbaseResourceHolder(
+				databaseFactory.getCore(options, atr));
+		return resourceHolder;
+	}
+
+	/**
+	 * @throws IllegalStateException if {@link #databaseFactory} is {@literal null}.
+	 */
+	private CouchbaseClientFactory getRequiredDatabaseFactory() {
+
+		Assert.state(databaseFactory != null,
+				"MongoTransactionManager operates upon a MongoDbFactory. Did you forget to provide one? It's required.");
+
+		return databaseFactory;
+	}
+
+	private static CouchbaseTransactionObject extractCouchbaseTransaction(Object transaction) {
+
+		Assert.isInstanceOf(CouchbaseTransactionObject.class, transaction,
+				() -> String.format("Expected to find a %s but it turned out to be %s.", CouchbaseTransactionObject.class,
+						transaction.getClass()));
+
+		return (CouchbaseTransactionObject) transaction;
+	}
+
+	private static CouchbaseTransactionObject extractCouchbaseTransaction(DefaultTransactionStatus status) {
+
+		Assert.isInstanceOf(CouchbaseTransactionObject.class, status.getTransaction(),
+				() -> String.format("Expected to find a %s but it turned out to be %s.", CouchbaseTransactionObject.class,
+						status.getTransaction().getClass()));
+
+		return (CouchbaseTransactionObject) status.getTransaction();
+	}
+
+	 static String debugString(@Nullable CoreTransactionAttemptContext ctx) {
+		if (ctx == null) {
+			return "null";
+		}
+		String debugString = String.format("[%s@%s ", ClassUtils.getShortName(ctx.getClass()),
+				Integer.toHexString(ctx.hashCode()));
+		try {
+			debugString += String.format("core=%s", ctx);
+		} catch (RuntimeException e) {
+			debugString += String.format("error = %s", e.getMessage());
+		}
+		debugString += "]";
+		return debugString;
+	}
+
+	public CouchbaseClientFactory getDatabaseFactory() {
+		return databaseFactory;
+	}
+
+	/**
+	 * MongoDB specific transaction object, representing a {@link ReactiveCouchbaseResourceHolder}. Used as transaction
+	 * object by {@link CouchbaseTransactionManager}.
+	 *
+	 * @author Christoph Strobl
+	 * @author Mark Paluch
+	 * @since 2.1
+	 * @see ReactiveCouchbaseResourceHolder
+	 */
+	protected static class CouchbaseTransactionObject implements SmartTransactionObject {
+
+		private @Nullable ReactiveCouchbaseResourceHolder resourceHolder;
+
+		CouchbaseTransactionObject(@Nullable ReactiveCouchbaseResourceHolder resourceHolder) {
+			this.resourceHolder = resourceHolder;
+		}
+
+		/**
+		 * Set the {@link ReactiveCouchbaseResourceHolder}.
+		 *
+		 * @param resourceHolder can be {@literal null}.
+		 */
+		void setResourceHolder(@Nullable ReactiveCouchbaseResourceHolder resourceHolder) {
+			this.resourceHolder = resourceHolder;
+		}
+
+		/**
+		 * @return {@literal true} if a {@link ReactiveCouchbaseResourceHolder} is set.
+		 */
+		final boolean hasResourceHolder() {
+			return resourceHolder != null;
+		}
+
+		/**
+		 * Start a MongoDB transaction optionally given {@link TransactionOptions}.
+		 *
+		 * @param options can be {@literal null}
+		 */
+		void startTransaction(TransactionOptions options) {
+
+			CoreTransactionAttemptContext core = getRequiredCore();
+			// if (options != null) {
+			// session.startTransaction(options);
+			// } else {
+			//core.startTransaction();
+			// }
+		}
+
+		/**
+		 * Commit the transaction.
+		 */
+		public void commitTransaction() {
+			getRequiredCore().commit().block();
+		}
+
+		/**
+		 * Rollback (abort) the transaction.
+		 */
+		public void abortTransaction() {
+			getRequiredCore().rollback().block();
+		}
+
+		/**
+		 * Close a {@link CoreTransactionAttemptContext} without regard to its transactional state.
+		 */
+		void closeSession() {
+			CoreTransactionAttemptContext core = getRequiredCore();
+		}
+
+		@Nullable
+		public CoreTransactionAttemptContext getCore() {
+			return resourceHolder != null ? resourceHolder.getCore() : null;
+		}
+
+		private ReactiveCouchbaseResourceHolder getRequiredResourceHolder() {
+			Assert.state(resourceHolder != null, "CouchbaseResourceHolder is required but not present. o_O");
+			return resourceHolder;
+		}
+
+		private CoreTransactionAttemptContext getRequiredCore() {
+			CoreTransactionAttemptContext core = getCore();
+			Assert.state(core != null, "A Core is required but it turned out to be null.");
+			return core;
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * @see  org.springframework.transaction.support.SmartTransactionObject#isRollbackOnly()
+		 */
+		@Override
+		public boolean isRollbackOnly() {
+			return this.resourceHolder != null && this.resourceHolder.isRollbackOnly();
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * @see  org.springframework.transaction.support.SmartTransactionObject#flush()
+		 */
+		@Override
+		public void flush() {
+			TransactionSynchronizationUtils.triggerFlush();
+		}
+
+	}
+}
diff --git a/src/main/java/org/springframework/data/couchbase/transaction/CouchbaseTransactionStatus.java b/src/main/java/org/springframework/data/couchbase/transaction/CouchbaseTransactionStatus.java
new file mode 100644
index 00000000..5331cea5
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/transaction/CouchbaseTransactionStatus.java
@@ -0,0 +1,33 @@
+package org.springframework.data.couchbase.transaction;
+
+import org.springframework.transaction.reactive.TransactionSynchronizationManager;
+import org.springframework.transaction.support.DefaultTransactionStatus;
+
+public class CouchbaseTransactionStatus extends DefaultTransactionStatus {
+
+  final TransactionSynchronizationManager transactionSynchronizationManager;
+  /**
+   * Create a new {@code DefaultTransactionStatus} instance.
+   *
+   * @param transaction        underlying transaction object that can hold state
+   *                           for the internal transaction implementation
+   * @param newTransaction     if the transaction is new, otherwise participating
+   *                           in an existing transaction
+   * @param newSynchronization if a new transaction synchronization has been
+   *                           opened for the given transaction
+   * @param readOnly           whether the transaction is marked as read-only
+   * @param debug              should debug logging be enabled for the handling of this transaction?
+   *                           Caching it in here can prevent repeated calls to ask the logging system whether
+   *                           debug logging should be enabled.
+   * @param suspendedResources a holder for resources that have been suspended
+   */
+  public CouchbaseTransactionStatus(Object transaction, boolean newTransaction, boolean newSynchronization, boolean readOnly, boolean debug, Object suspendedResources, TransactionSynchronizationManager sm) {
+    super(transaction,
+        newTransaction,
+        newSynchronization,
+        readOnly,
+        debug,
+        suspendedResources);
+    transactionSynchronizationManager = sm;
+  }
+}
diff --git a/src/main/java/org/springframework/data/couchbase/transaction/CouchbaseTransactionalOperator.java b/src/main/java/org/springframework/data/couchbase/transaction/CouchbaseTransactionalOperator.java
new file mode 100644
index 00000000..10002be9
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/transaction/CouchbaseTransactionalOperator.java
@@ -0,0 +1,231 @@
+package org.springframework.data.couchbase.transaction;
+
+import com.couchbase.client.core.transaction.CoreTransactionAttemptContext;
+import com.couchbase.client.core.transaction.CoreTransactionGetResult;
+import com.couchbase.client.java.transactions.AttemptContextReactiveAccessor;
+import com.couchbase.client.java.transactions.ReactiveTransactionAttemptContext;
+import com.couchbase.client.java.transactions.TransactionGetResult;
+import com.couchbase.client.java.transactions.TransactionResult;
+import org.springframework.data.couchbase.core.CouchbaseTemplate;
+import org.springframework.transaction.ReactiveTransaction;
+import org.springframework.transaction.TransactionException;
+import org.springframework.transaction.TransactionSystemException;
+import org.springframework.transaction.reactive.TransactionCallback;
+import org.springframework.transaction.reactive.TransactionContextManager;
+import org.springframework.transaction.reactive.TransactionalOperator;
+import reactor.core.publisher.Flux;
+import reactor.core.publisher.Mono;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.Function;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.springframework.data.couchbase.core.ReactiveCouchbaseOperations;
+import org.springframework.data.couchbase.core.ReactiveCouchbaseTemplate;
+import org.springframework.data.couchbase.repository.DynamicProxyable;
+import org.springframework.data.couchbase.repository.support.TransactionResultHolder;
+import org.springframework.transaction.ReactiveTransactionManager;
+import org.springframework.transaction.TransactionDefinition;
+import org.springframework.util.Assert;
+
+import com.couchbase.client.core.error.CouchbaseException;
+
+/**
+ * What's this for again?
+ * A transaction-enabled operator that uses the CouchbaseStuffHandle txOp instead of
+ * what it finds in the currentContext()?
+ *
+ */
+public class CouchbaseTransactionalOperator implements TransactionalOperator {
+
+	// package org.springframework.transaction.reactive;
+	private static final Log logger = LogFactory.getLog(CouchbaseTransactionalOperator.class);
+	private final ReactiveTransactionManager transactionManager;
+	private final TransactionDefinition transactionDefinition;
+
+	Map<Integer, TransactionResultHolder> getResultMap = new HashMap<>();
+	private ReactiveTransactionAttemptContext attemptContextReactive;
+
+	public CouchbaseTransactionalOperator() {
+		transactionManager = null;
+		transactionDefinition = null;
+	}
+
+	public CouchbaseTransactionalOperator(ReactiveCouchbaseTransactionManager transactionManager) {
+		this(transactionManager, new CouchbaseTransactionDefinition());
+	}
+
+	public ReactiveCouchbaseTemplate getTemplate(){
+		return ((ReactiveCouchbaseTransactionManager)transactionManager).getDatabaseFactory().getTransactionalOperator()
+				.getTemplate();
+	}
+	public CouchbaseTransactionalOperator(ReactiveCouchbaseTransactionManager transactionManager,
+																				TransactionDefinition transactionDefinition) {
+		Assert.notNull(transactionManager, "ReactiveTransactionManager must not be null");
+		Assert.notNull(transactionDefinition, "TransactionDefinition must not be null");
+		this.transactionManager = transactionManager;
+		this.transactionDefinition = transactionDefinition;
+	}
+
+	public Mono<TransactionResult> reactive(Function<CouchbaseTransactionalOperator, Mono<Void>> transactionLogic) {
+		return reactive(transactionLogic, true);
+	}
+
+	public TransactionResult run(Function<CouchbaseTransactionalOperator, Object> transactionLogic) {
+		return reactive(new Function<CouchbaseTransactionalOperator, Mono<Void>>() {
+											@Override
+											public Mono<Void> apply(CouchbaseTransactionalOperator couchbaseTransactionalOperator) {
+												return Mono.defer(() -> {transactionLogic.apply( couchbaseTransactionalOperator); return Mono.empty();});
+											}
+										},
+				true).block();
+	}
+
+
+	/**
+	 * A convenience wrapper around {@link TransactionsReactive#run}, that provides a default
+	 * <code>PerTransactionConfig</code>.
+	 */
+	public Mono<TransactionResult> reactive(Function<CouchbaseTransactionalOperator, Mono<Void>> transactionLogic,
+											boolean commit) {
+//		// todo gp this needs access to a Cluster
+//		return Mono.empty();
+		return ((ReactiveCouchbaseTransactionManager) transactionManager).getDatabaseFactory().getCluster().block().reactive().transactions().run(ctx -> {
+			setAttemptContextReactive(ctx); // for getTxOp().getCtx() in Reactive*OperationSupport
+			// for transactional(), transactionDefinition.setAtr(ctx) is called at the beginning of that method
+			// and is eventually added to the ClientSession in transactionManager.doBegin() via newResourceHolder()
+			return transactionLogic.apply(this);
+		}/*, commit*/);
+	}
+
+	public TransactionResultHolder transactionResultHolder(Integer key) {
+		return getResultMap.get(key);
+	}
+
+	public TransactionResultHolder transactionResultHolder(CoreTransactionGetResult result) {
+		TransactionResultHolder holder = new TransactionResultHolder(result);
+		getResultMap.put(System.identityHashCode(holder), holder);
+		return holder;
+	}
+
+	public void setAttemptContextReactive(ReactiveTransactionAttemptContext attemptContextReactive) {
+		this.attemptContextReactive = attemptContextReactive;
+		// see ReactiveCouchbaseTransactionManager.doBegin()
+		// transactionManager.getReactiveTransaction(new CouchbaseTransactionDefinition()).block();
+	//	CouchbaseResourceHolder holder = null;
+	//TransactionSynchronizationManager.bindResource(((ReactiveCouchbaseTransactionManager)transactionManager).getDatabaseFactory(), holder);
+
+		/*
+		for savePerson that,  doBegin() is called from AbstractReactiveTransactionManager.getReactiveTransaction()
+		which is called from TransactionalOperatorImpl.transactional(Mono<T>)
+		[also called from TransactionalOperatorImpl.execute(TransactionCallback<T>)]
+		 */
+	}
+
+	public ReactiveTransactionAttemptContext getAttemptContextReactive() {
+		return attemptContextReactive;
+	}
+
+	public CoreTransactionAttemptContext getAttemptContext() {
+		return AttemptContextReactiveAccessor.getCore(attemptContextReactive);
+	}
+
+
+	public ReactiveTransactionManager getTransactionManager() {
+		return transactionManager;
+	}
+
+	public ReactiveCouchbaseTemplate template(ReactiveCouchbaseTemplate template) {
+		ReactiveCouchbaseTransactionManager txMgr = ((ReactiveCouchbaseTransactionManager) ((CouchbaseTransactionalOperator) this)
+				.getTransactionManager());
+		if (template.getCouchbaseClientFactory() != txMgr.getDatabaseFactory()) {
+			throw new CouchbaseException(
+					"Template must use the same clientFactory as the transactionManager of the transactionalOperator "
+							+ template);
+		}
+		return template.with(this); // template with a new couchbaseClient with txOperator
+	}
+
+	/*
+	public CouchbaseTemplate template(CouchbaseTemplate template) {
+		CouchbaseTransactionManager txMgr = ((CouchbaseTransactionManager) ((CouchbaseStuffHandle) this)
+				.getTransactionManager());
+		if (template.getCouchbaseClientFactory() != txMgr.getDatabaseFactory()) {
+			throw new CouchbaseException(
+					"Template must use the same clientFactory as the transactionManager of the transactionalOperator "
+							+ template);
+		}
+		return template.with(this); // template with a new couchbaseClient with txOperator
+	}
+*/
+	public <R extends DynamicProxyable<R>> R repository(R repo) {
+		if (!(repo.getOperations() instanceof ReactiveCouchbaseOperations)) {
+			throw new CouchbaseException("Repository must be a Reactive Couchbase repository" + repo);
+		}
+		ReactiveCouchbaseOperations reactiveOperations = (ReactiveCouchbaseOperations) repo.getOperations();
+		ReactiveCouchbaseTransactionManager txMgr = (ReactiveCouchbaseTransactionManager) this.getTransactionManager();
+
+		if (reactiveOperations.getCouchbaseClientFactory() != txMgr.getDatabaseFactory()) {
+			throw new CouchbaseException(
+					"Repository must use the same clientFactory as the transactionManager of the transactionalOperator " + repo);
+		}
+		return repo.withTransaction(this); // this returns a new repository proxy with txOperator in its threadLocal
+		// what if instead we returned a new repo with a new template with the txOperator?
+	}
+
+	@Override
+	public <T> Flux<T> transactional(Flux<T> flux) {
+		return execute(it -> flux);
+	}
+
+	@Override
+	public <T> Mono<T> transactional(Mono<T> mono) {
+		return TransactionContextManager.currentContext().flatMap(context -> {
+			// getCtx()/getAttemptTransActionReactive() has the atr
+			// atr : transactionalOpterator -> transactionDefinition -> transactionHolder ->
+			((CouchbaseTransactionDefinition) transactionDefinition).setAttemptContextReactive(getAttemptContextReactive());
+			Mono<ReactiveTransaction> status = this.transactionManager.getReactiveTransaction(this.transactionDefinition);
+			// This is an around advice: Invoke the next interceptor in the chain.
+			// This will normally result in a target object being invoked.
+			// Need re-wrapping of ReactiveTransaction until we get hold of the exception
+			// through usingWhen.
+			return status
+					.flatMap(it -> Mono
+							.usingWhen(Mono.just(it), ignore -> mono, this.transactionManager::commit, (res, err) -> { System.err.println("!!!!!!!!!! "+err+" "+res); return Mono.empty();},
+									this.transactionManager::rollback)
+							.onErrorResume(ex -> rollbackOnException(it, ex).then(Mono.error(ex))));
+		}).contextWrite(TransactionContextManager.getOrCreateContext())
+				.contextWrite(TransactionContextManager.getOrCreateContextHolder());
+	}
+
+	@Override
+	public <T> Flux<T> execute(TransactionCallback<T> action) throws TransactionException {
+		return TransactionContextManager.currentContext().flatMapMany(context -> {
+			Mono<ReactiveTransaction> status = this.transactionManager.getReactiveTransaction(this.transactionDefinition);
+			// This is an around advice: Invoke the next interceptor in the chain.
+			// This will normally result in a target object being invoked.
+			// Need re-wrapping of ReactiveTransaction until we get hold of the exception
+			// through usingWhen.
+			return status
+					.flatMapMany(it -> Flux
+							.usingWhen(Mono.just(it), action::doInTransaction, this.transactionManager::commit,
+									(tx, ex) -> Mono.empty(), this.transactionManager::rollback)
+							.onErrorResume(ex -> rollbackOnException(it, ex).then(Mono.error(ex))));
+		}).contextWrite(TransactionContextManager.getOrCreateContext())
+				.contextWrite(TransactionContextManager.getOrCreateContextHolder());
+	}
+
+	private Mono<Void> rollbackOnException(ReactiveTransaction status, Throwable ex) throws TransactionException {
+		logger.debug("Initiating transaction rollback on application exception", ex);
+		return this.transactionManager.rollback(status).onErrorMap((ex2) -> {
+			logger.error("Application exception overridden by rollback exception", ex);
+			if (ex2 instanceof TransactionSystemException) {
+				((TransactionSystemException) ex2).initApplicationException(ex);
+			}
+			return ex2;
+		});
+	}
+
+}
diff --git a/src/main/java/org/springframework/data/couchbase/transaction/ReactiveCouchbaseClientUtils.java b/src/main/java/org/springframework/data/couchbase/transaction/ReactiveCouchbaseClientUtils.java
new file mode 100644
index 00000000..31865f1b
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/transaction/ReactiveCouchbaseClientUtils.java
@@ -0,0 +1,305 @@
+package org.springframework.data.couchbase.transaction;
+
+import com.couchbase.client.core.transaction.CoreTransactionAttemptContext;
+import com.couchbase.client.java.ClusterInterface;
+import com.couchbase.client.java.transactions.config.TransactionOptions;
+import org.springframework.data.couchbase.ReactiveCouchbaseClientFactory;
+import org.springframework.data.couchbase.core.ReactiveCouchbaseTemplate;
+import org.springframework.data.couchbase.core.convert.CouchbaseConverter;
+import org.springframework.lang.Nullable;
+import org.springframework.transaction.NoTransactionException;
+import org.springframework.transaction.reactive.ReactiveResourceSynchronization;
+import org.springframework.transaction.reactive.TransactionSynchronization;
+import org.springframework.transaction.reactive.TransactionSynchronizationManager;
+import org.springframework.transaction.support.ResourceHolderSynchronization;
+import org.springframework.util.Assert;
+import org.springframework.util.StringUtils;
+import reactor.core.publisher.Mono;
+import reactor.util.context.Context;
+
+public class ReactiveCouchbaseClientUtils {
+
+	/**
+	 * Check if the {@link ReactiveMongoDatabaseFactory} is actually bound to a
+	 * {@link com.mongodb.reactivestreams.client.ClientSession} that has an active transaction, or if a
+	 * {@link org.springframework.transaction.reactive.TransactionSynchronization} has been registered for the
+	 * {@link ReactiveMongoDatabaseFactory resource} and if the associated
+	 * {@link com.mongodb.reactivestreams.client.ClientSession} has an
+	 * {@link com.mongodb.reactivestreams.client.ClientSession#hasActiveTransaction() active transaction}.
+	 *
+	 * @param databaseFactory the resource to check transactions for. Must not be {@literal null}.
+	 * @return a {@link Mono} emitting {@literal true} if the factory has an ongoing transaction.
+	 */
+	public static Mono<Boolean> isTransactionActive(ReactiveCouchbaseClientFactory databaseFactory) {
+
+		if (databaseFactory.isTransactionActive()) {
+			return Mono.just(true);
+		}
+
+		return TransactionSynchronizationManager.forCurrentTransaction() //
+				.map(it -> {
+
+					ReactiveCouchbaseResourceHolder holder = (ReactiveCouchbaseResourceHolder) it.getResource(databaseFactory);
+					return holder != null && holder.hasActiveTransaction();
+				}) //
+				.onErrorResume(NoTransactionException.class, e -> Mono.just(false));
+	}
+
+	/**
+	 * Obtain the default {@link MongoDatabase database} form the given {@link ReactiveMongoDatabaseFactory factory} using
+	 * {@link SessionSynchronization#ON_ACTUAL_TRANSACTION native session synchronization}. <br />
+	 * Registers a {@link MongoSessionSynchronization MongoDB specific transaction synchronization} within the subscriber
+	 * {@link Context} if {@link TransactionSynchronizationManager#isSynchronizationActive() synchronization is active}.
+	 *
+	 * @param factory the {@link ReactiveMongoDatabaseFactory} to get the {@link MongoDatabase} from.
+	 * @return the {@link MongoDatabase} that is potentially associated with a transactional {@link ClientSession}.
+	 */
+	public static Mono<ClusterInterface> getDatabase(ReactiveCouchbaseClientFactory factory) {
+		return doGetCouchbaseCluster(null, factory, SessionSynchronization.ON_ACTUAL_TRANSACTION);
+	}
+
+	/**
+	 * Obtain the default {@link MongoDatabase database} form the given {@link ReactiveMongoDatabaseFactory factory}.
+	 * <br />
+	 * Registers a {@link MongoSessionSynchronization MongoDB specific transaction synchronization} within the subscriber
+	 * {@link Context} if {@link TransactionSynchronizationManager#isSynchronizationActive() synchronization is active}.
+	 *
+	 * @param factory the {@link ReactiveMongoDatabaseFactory} to get the {@link MongoDatabase} from.
+	 * @param sessionSynchronization the synchronization to use. Must not be {@literal null}.
+	 * @return the {@link MongoDatabase} that is potentially associated with a transactional {@link ClientSession}.
+	 */
+	public static Mono<ClusterInterface> getDatabase(ReactiveCouchbaseClientFactory factory,
+													 SessionSynchronization sessionSynchronization) {
+		return doGetCouchbaseCluster(null, factory, sessionSynchronization);
+	}
+
+	public static Mono<ReactiveCouchbaseTemplate> getTemplate(ReactiveCouchbaseClientFactory factory,
+															  SessionSynchronization sessionSynchronization, CouchbaseConverter converter) {
+		return doGetCouchbaseTemplate(null, factory, sessionSynchronization, converter);
+	}
+
+	/**
+	 * Obtain the {@link MongoDatabase database} with given name form the given {@link ReactiveMongoDatabaseFactory
+	 * factory} using {@link SessionSynchronization#ON_ACTUAL_TRANSACTION native session synchronization}. <br />
+	 * Registers a {@link MongoSessionSynchronization MongoDB specific transaction synchronization} within the subscriber
+	 * {@link Context} if {@link TransactionSynchronizationManager#isSynchronizationActive() synchronization is active}.
+	 *
+	 * @param dbName the name of the {@link MongoDatabase} to get.
+	 * @param factory the {@link ReactiveMongoDatabaseFactory} to get the {@link MongoDatabase} from.
+	 * @return the {@link MongoDatabase} that is potentially associated with a transactional {@link ClientSession}.
+	 */
+	public static Mono<ClusterInterface> getDatabase(String dbName, ReactiveCouchbaseClientFactory factory) {
+		return doGetCouchbaseCluster(dbName, factory, SessionSynchronization.ON_ACTUAL_TRANSACTION);
+	}
+
+	/**
+	 * Obtain the {@link MongoDatabase database} with given name form the given {@link ReactiveMongoDatabaseFactory
+	 * factory}. <br />
+	 * Registers a {@link MongoSessionSynchronization MongoDB specific transaction synchronization} within the subscriber
+	 * {@link Context} if {@link TransactionSynchronizationManager#isSynchronizationActive() synchronization is active}.
+	 *
+	 * @param dbName the name of the {@link MongoDatabase} to get.
+	 * @param factory the {@link ReactiveMongoDatabaseFactory} to get the {@link MongoDatabase} from.
+	 * @param sessionSynchronization the synchronization to use. Must not be {@literal null}.
+	 * @return the {@link MongoDatabase} that is potentially associated with a transactional {@link ClientSession}.
+	 */
+	public static Mono<ClusterInterface> getCluster(String dbName, ReactiveCouchbaseClientFactory factory,
+													SessionSynchronization sessionSynchronization) {
+		return doGetCouchbaseCluster(dbName, factory, sessionSynchronization);
+	}
+
+	private static Mono<ClusterInterface> doGetCouchbaseCluster(@Nullable String dbName,
+																ReactiveCouchbaseClientFactory factory, SessionSynchronization sessionSynchronization) {
+
+		Assert.notNull(factory, "DatabaseFactory must not be null!");
+
+		if (sessionSynchronization == SessionSynchronization.NEVER) {
+			return getCouchbaseClusterOrDefault(dbName, factory);
+		}
+
+		return TransactionSynchronizationManager.forCurrentTransaction()
+				.filter(TransactionSynchronizationManager::isSynchronizationActive) //
+				.flatMap(synchronizationManager -> {
+
+					return doGetSession(synchronizationManager, factory, sessionSynchronization) //
+							.flatMap(it -> getCouchbaseClusterOrDefault(dbName, factory.withCore(it)));
+				}) //
+				.onErrorResume(NoTransactionException.class, e -> getCouchbaseClusterOrDefault(dbName, factory)) // hitting this
+				.switchIfEmpty(getCouchbaseClusterOrDefault(dbName, factory));
+	}
+
+	private static Mono<ReactiveCouchbaseTemplate> doGetCouchbaseTemplate(@Nullable String dbName,
+																		  ReactiveCouchbaseClientFactory factory, SessionSynchronization sessionSynchronization,
+																		  CouchbaseConverter converter) {
+
+		Assert.notNull(factory, "DatabaseFactory must not be null!");
+
+		if (sessionSynchronization == SessionSynchronization.NEVER) {
+			return getCouchbaseTemplateOrDefault(dbName, factory, converter);
+		}
+
+		//CouchbaseResourceHolder h = (CouchbaseResourceHolder) org.springframework.transaction.support.TransactionSynchronizationManager
+		//		.getResource(factory);
+
+		return TransactionSynchronizationManager.forCurrentTransaction()
+				.filter(TransactionSynchronizationManager::isSynchronizationActive) //
+				.flatMap(synchronizationManager -> {
+					return doGetSession(synchronizationManager, factory, sessionSynchronization) //
+							.flatMap(it -> getCouchbaseTemplateOrDefault(dbName, factory.withCore(it), converter)); // rx TxMgr
+				}) //
+				.onErrorResume(NoTransactionException.class,
+						e -> { return getCouchbaseTemplateOrDefault(dbName,
+								getNonReactiveSession(factory) != null ? factory.withCore(getNonReactiveSession(factory)) : factory,
+								converter);}) // blocking TxMgr
+				.switchIfEmpty(getCouchbaseTemplateOrDefault(dbName, factory, converter));
+	}
+
+	private static ReactiveCouchbaseResourceHolder getNonReactiveSession(ReactiveCouchbaseClientFactory factory) {
+		ReactiveCouchbaseResourceHolder h = ((ReactiveCouchbaseResourceHolder) org.springframework.transaction.support.TransactionSynchronizationManager
+				.getResource(factory.getCluster().block()));
+		if( h == null){  // no longer used
+			h = ((ReactiveCouchbaseResourceHolder) org.springframework.transaction.support.TransactionSynchronizationManager
+					.getResource(factory));// MN's CouchbaseTransactionManager
+		}
+		//System.err.println("getNonreactiveSession: "+ h);
+		return h;
+	}
+
+	private static Mono<ClusterInterface> getCouchbaseClusterOrDefault(@Nullable String dbName,
+																	   ReactiveCouchbaseClientFactory factory) {
+		return StringUtils.hasText(dbName) ? factory.getCluster() : factory.getCluster();
+	}
+
+	private static Mono<ReactiveCouchbaseTemplate> getCouchbaseTemplateOrDefault(@Nullable String dbName,
+																				 ReactiveCouchbaseClientFactory factory, CouchbaseConverter converter) {
+		return Mono.just(new ReactiveCouchbaseTemplate(factory, converter));
+	}
+
+	private static Mono<ReactiveCouchbaseResourceHolder> doGetSession(TransactionSynchronizationManager synchronizationManager,
+																	  ReactiveCouchbaseClientFactory dbFactory, SessionSynchronization sessionSynchronization) {
+
+		final ReactiveCouchbaseResourceHolder registeredHolder = (ReactiveCouchbaseResourceHolder) synchronizationManager
+				.getResource(dbFactory.getCluster().block()); // make sure this wasn't saved under the wrong key!!!
+
+		// check for native MongoDB transaction
+		if (registeredHolder != null
+				&& (registeredHolder.hasCore() || registeredHolder.isSynchronizedWithTransaction())) {
+			System.err.println("doGetSession: got: "+registeredHolder.getCore());
+			// TODO msr - mabye don't create a session unless it has an atr?
+			//return registeredHolder.hasCore() ? Mono.just(registeredHolder)
+			//		: createClientSession(dbFactory).map( core -> { registeredHolder.setCore(core); return registeredHolder;});
+			return Mono.just(registeredHolder);
+		}
+
+		if (SessionSynchronization.ON_ACTUAL_TRANSACTION.equals(sessionSynchronization)) {
+			System.err.println("doGetSession: ON_ACTUAL_TRANSACTION -> empty()");
+			return Mono.empty();
+		}
+
+		System.err.println("doGetSession: createClientSession()");
+
+		// init a non native MongoDB transaction by registering a MongoSessionSynchronization
+		return createClientSession(dbFactory).map(session -> {
+
+			ReactiveCouchbaseResourceHolder newHolder = new ReactiveCouchbaseResourceHolder(session);
+			//newHolder.getRequiredCore().startTransaction();
+			System.err.println(" need to call startTransaction() ");
+
+			synchronizationManager
+					.registerSynchronization(new CouchbaseSessionSynchronization(synchronizationManager, newHolder, dbFactory));
+			newHolder.setSynchronizedWithTransaction(true);
+			synchronizationManager.bindResource(dbFactory, newHolder);
+
+			return newHolder;
+		});
+	}
+
+	private static Mono<CoreTransactionAttemptContext> createClientSession(ReactiveCouchbaseClientFactory dbFactory) {
+		return null; // ?? dbFactory.getCore(TransactionOptions.transactionOptions());
+	}
+
+	/**
+	 * MongoDB specific {@link ResourceHolderSynchronization} for resource cleanup at the end of a transaction when
+	 * participating in a non-native MongoDB transaction, such as a R2CBC transaction.
+	 *
+	 * @author Mark Paluch
+	 * @since 2.2
+	 */
+	private static class CouchbaseSessionSynchronization
+			extends ReactiveResourceSynchronization<ReactiveCouchbaseResourceHolder, Object> {
+
+		private final ReactiveCouchbaseResourceHolder resourceHolder;
+
+		CouchbaseSessionSynchronization(TransactionSynchronizationManager synchronizationManager,
+										ReactiveCouchbaseResourceHolder resourceHolder, ReactiveCouchbaseClientFactory dbFactory) {
+
+			super(resourceHolder, dbFactory, synchronizationManager);
+			this.resourceHolder = resourceHolder;
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * @see org.springframework.transaction.reactive.ReactiveResourceSynchronization#shouldReleaseBeforeCompletion()
+		 */
+		@Override
+		protected boolean shouldReleaseBeforeCompletion() {
+			return false;
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * @see org.springframework.transaction.reactive.ReactiveResourceSynchronization#processResourceAfterCommit(java.lang.Object)
+		 */
+		@Override
+		protected Mono<Void> processResourceAfterCommit(ReactiveCouchbaseResourceHolder resourceHolder) {
+
+			if (isTransactionActive(resourceHolder)) {
+				return Mono.from(resourceHolder.getCore().commit());
+			}
+
+			return Mono.empty();
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * @see org.springframework.transaction.reactive.ReactiveResourceSynchronization#afterCompletion(int)
+		 */
+		@Override
+		public Mono<Void> afterCompletion(int status) {
+
+			return Mono.defer(() -> {
+
+				if (status == TransactionSynchronization.STATUS_ROLLED_BACK && isTransactionActive(this.resourceHolder)) {
+
+					return Mono.from(resourceHolder.getCore().rollback()) //
+							.then(super.afterCompletion(status));
+				}
+
+				return super.afterCompletion(status);
+			});
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * @see org.springframework.transaction.reactive.ReactiveResourceSynchronization#releaseResource(java.lang.Object, java.lang.Object)
+		 */
+		@Override
+		protected Mono<Void> releaseResource(ReactiveCouchbaseResourceHolder resourceHolder, Object resourceKey) {
+
+			return Mono.fromRunnable(() -> {
+				//if (resourceHolder.hasActiveSession()) {
+				//	resourceHolder.getRequiredSession().close();
+				//}
+			});
+		}
+
+		private boolean isTransactionActive(ReactiveCouchbaseResourceHolder resourceHolder) {
+
+			if (!resourceHolder.hasCore()) {
+				return false;
+			}
+
+			return resourceHolder.getRequiredCore() != null;
+		}
+	}
+}
diff --git a/src/main/java/org/springframework/data/couchbase/transaction/ReactiveCouchbaseResourceHolder.java b/src/main/java/org/springframework/data/couchbase/transaction/ReactiveCouchbaseResourceHolder.java
new file mode 100644
index 00000000..4e3d09d5
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/transaction/ReactiveCouchbaseResourceHolder.java
@@ -0,0 +1,140 @@
+/*
+ * Copyright 2019-2021 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.couchbase.transaction;
+
+import org.springframework.data.couchbase.core.ReactiveCouchbaseTemplate;
+import org.springframework.data.couchbase.repository.support.TransactionResultHolder;
+import org.springframework.lang.Nullable;
+import org.springframework.transaction.support.ResourceHolderSupport;
+
+import com.couchbase.client.core.transaction.CoreTransactionAttemptContext;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * MongoDB specific resource holder, wrapping a {@link CoreTransactionAttemptContext}.
+ * {@link ReactiveCouchbaseTransactionManager} binds instances of this class to the subscriber context.
+ * <p />
+ * <strong>Note:</strong> Intended for internal usage only.
+ *
+ * @author Mark Paluch
+ * @author Christoph Strobl
+ * @since 2.2
+ * @see ReactiveCouchbaseTransactionManager
+ * @see ReactiveCouchbaseTemplate
+ */
+// todo gp understand why this is needed
+public class ReactiveCouchbaseResourceHolder extends ResourceHolderSupport {
+
+	private @Nullable CoreTransactionAttemptContext core; // which holds the atr
+	Map<Integer, TransactionResultHolder> getResultMap = new HashMap<>();
+
+	// private ReactiveCouchbaseClientFactory databaseFactory;
+
+	/**
+	 * Create a new {@link ReactiveCouchbaseResourceHolder} for a given {@link CoreTransactionAttemptContext session}.
+	 *
+	 * @param core the associated {@link CoreTransactionAttemptContext}. Can be {@literal null}.
+	 */
+	public ReactiveCouchbaseResourceHolder(@Nullable CoreTransactionAttemptContext core) {
+
+		this.core = core;
+		// this.databaseFactory = databaseFactory;
+	}
+
+	/**
+	 * @return the associated {@link CoreTransactionAttemptContext}. Can be {@literal null}.
+	 */
+	@Nullable
+	public CoreTransactionAttemptContext getCore() {
+		return core;
+	}
+
+	/**
+	 * @return the required associated {@link CoreTransactionAttemptContext}.
+	 * @throws IllegalStateException if no session is associated.
+	 */
+	CoreTransactionAttemptContext getRequiredCore() {
+		CoreTransactionAttemptContext core = getCore();
+		if (core == null) {
+			throw new IllegalStateException("No CoreTransactionAttemptContext associated");
+		}
+		return core;
+	}
+
+	/*
+	 * @return the associated {@link CouchbaseClientFactory}.
+	ReactiveCouchbaseClientFactory getDatabaseFactory() {
+		return databaseFactory;
+	}
+	 */
+
+	/**
+	 * Set the {@link CoreTransactionAttemptContext} to guard.
+	 *
+	 * @param core can be {@literal null}.
+	 */
+	CoreTransactionAttemptContext setCore(@Nullable CoreTransactionAttemptContext core) {
+		System.err.println("setCore: " + core);
+		return this.core = core;
+	}
+
+	/**
+	 * @return {@literal true} if session is not {@literal null}.
+	 */
+	boolean hasCore() {
+		return core != null;
+	}
+
+	/**
+	 * If the {@link ReactiveCouchbaseResourceHolder} is {@link #hasCore() not already associated} with a
+	 * {@link CoreTransactionAttemptContext} the given value is {@link #setCore(CoreTransactionAttemptContext)} set} and
+	 * returned, otherwise the current bound session is returned.
+	 *
+	 * @param core
+	 * @return
+	 */
+	@Nullable
+	CoreTransactionAttemptContext setSessionIfAbsent(@Nullable CoreTransactionAttemptContext core) {
+
+		if (!hasCore()) {
+			setCore(core);
+		}
+
+		return this.core;
+	}
+
+	public boolean hasActiveTransaction() {
+		return getCore() != null;
+	}
+
+
+	public TransactionResultHolder transactionResultHolder(Integer key) {
+		TransactionResultHolder holder = getResultMap.get(key);
+		if(holder == null){
+			throw new RuntimeException("did not find transactionResultHolder for key="+key+" in session");
+		}
+		return holder;
+	}
+
+	public TransactionResultHolder transactionResultHolder(TransactionResultHolder holder, Object o) {
+		System.err.println("PUT: "+System.identityHashCode(o)+" "+o);
+		getResultMap.put(System.identityHashCode(o), holder);
+		return holder;
+	}
+
+}
diff --git a/src/main/java/org/springframework/data/couchbase/transaction/ReactiveCouchbaseTransactionManager.java b/src/main/java/org/springframework/data/couchbase/transaction/ReactiveCouchbaseTransactionManager.java
new file mode 100644
index 00000000..80665b95
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/transaction/ReactiveCouchbaseTransactionManager.java
@@ -0,0 +1,499 @@
+/*
+ * Copyright 2019-2021 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.couchbase.transaction;
+
+import com.couchbase.client.java.transactions.config.TransactionOptions;
+import reactor.core.publisher.Mono;
+
+import org.springframework.beans.factory.InitializingBean;
+import org.springframework.data.couchbase.CouchbaseClientFactory;
+import org.springframework.data.couchbase.ReactiveCouchbaseClientFactory;
+import org.springframework.lang.Nullable;
+import org.springframework.transaction.TransactionDefinition;
+import org.springframework.transaction.TransactionException;
+import org.springframework.transaction.TransactionSystemException;
+import org.springframework.transaction.reactive.AbstractReactiveTransactionManager;
+import org.springframework.transaction.reactive.GenericReactiveTransaction;
+import org.springframework.transaction.reactive.TransactionSynchronizationManager;
+import org.springframework.transaction.support.SmartTransactionObject;
+import org.springframework.util.Assert;
+import org.springframework.util.ClassUtils;
+
+import com.couchbase.client.core.error.CouchbaseException;
+import com.couchbase.client.core.transaction.CoreTransactionAttemptContext;
+import com.couchbase.client.java.transactions.Transactions;
+
+/**
+ * A {@link org.springframework.transaction.ReactiveTransactionManager} implementation that manages
+ * {@link CoreTransactionAttemptContext} based transactions for a single {@link CouchbaseClientFactory}.
+ * <p />
+ * Binds a {@link CoreTransactionAttemptContext} from the specified {@link CouchbaseClientFactory} to the subscriber
+ * {@link reactor.util.context.Context}.
+ * <p />
+ * {@link org.springframework.transaction.TransactionDefinition#isReadOnly() Readonly} transactions operate on a
+ * {@link CoreTransactionAttemptContext} and enable causal consistency, and also
+ * {@link CoreTransactionAttemptContext#startTransaction() start},
+ * {@link CoreTransactionAttemptContext#commitTransaction() commit} or
+ * {@link CoreTransactionAttemptContext#abortTransaction() abort} a transaction.
+ * <p />
+ * Application code is required to retrieve the {link com.xxxxxxx.reactivestreams.client.MongoDatabase} via {link
+ * org.springframework.data.xxxxxxx.ReactiveMongoDatabaseUtils#getDatabase(CouchbaseClientFactory)} instead of a
+ * standard {@link org.springframework.data.couchbase.CouchbaseClientFactory#getCluster()} call. Spring classes such as
+ * {@link org.springframework.data.couchbase.core.ReactiveCouchbaseTemplate} use this strategy implicitly.
+ * <p />
+ * By default failure of a {@literal commit} operation raises a {@link TransactionSystemException}. You can override
+ * {@link #doCommit(TransactionSynchronizationManager, ReactiveCouchbaseTransactionObject)} to implement the
+ * <a href="https://docs.xxxxxxx.com/manual/core/transactions/#retry-commit-operation">Retry Commit Operation</a>
+ * behavior as outlined in the XxxxxxXX reference manual.
+ *
+ * @author Christoph Strobl
+ * @author Mark Paluch
+ * @since 2.2
+ * @see <a href="https://www.xxxxxxx.com/transactions">XxxxxxXX Transaction Documentation</a> see
+ *      ReactiveMongoDatabaseUtils#getDatabase(CouchbaseClientFactory, SessionSynchronization)
+ */
+public class ReactiveCouchbaseTransactionManager extends AbstractReactiveTransactionManager
+		implements InitializingBean {
+
+	private @Nullable ReactiveCouchbaseClientFactory databaseFactory; // (why) does this need to be reactive?
+	private @Nullable Transactions transactions;
+
+	/**
+	 * Create a new {@link ReactiveCouchbaseTransactionManager} for bean-style usage.
+	 * <p />
+	 * <strong>Note:</strong>The {@link org.springframework.data.couchbase.CouchbaseClientFactory db factory} has to be
+	 * {@link #setDatabaseFactory(ReactiveCouchbaseClientFactory)} set} before using the instance. Use this constructor to
+	 * prepare a {@link ReactiveCouchbaseTransactionManager} via a {@link org.springframework.beans.factory.BeanFactory}.
+	 * <p />
+	 * Optionally it is possible to set default {@link TransactionQueryOptions transaction options} defining {link
+	 * com.xxxxxxx.ReadConcern} and {link com.xxxxxxx.WriteConcern}.
+	 *
+	 * @see #setDatabaseFactory(ReactiveCouchbaseClientFactory)
+	 */
+	public ReactiveCouchbaseTransactionManager() {}
+
+	/**
+	 * Create a new {@link ReactiveCouchbaseTransactionManager} obtaining sessions from the given
+	 * {@link CouchbaseClientFactory} applying the given {@link TransactionQueryOptions options}, if present, when
+	 * starting a new transaction.
+	 *
+	 * @param databaseFactory must not be {@literal null}.
+	 */
+	public ReactiveCouchbaseTransactionManager(ReactiveCouchbaseClientFactory databaseFactory) {
+		Assert.notNull(databaseFactory, "DatabaseFactory must not be null!");
+		this.databaseFactory = databaseFactory; // should be a clone? TransactionSynchronizationManager binds objs to it
+		System.err.println("ReactiveCouchbaseTransactionManager : created");
+	}
+
+	public ReactiveCouchbaseTransactionManager(ReactiveCouchbaseClientFactory databaseFactory,
+											   @Nullable Transactions transactions) {
+		Assert.notNull(databaseFactory, "DatabaseFactory must not be null!");
+		this.databaseFactory = databaseFactory; // databaseFactory; // should be a clone? TransactionSynchronizationManager
+		// binds objs to it
+		this.transactions = transactions;
+		System.err.println("ReactiveCouchbaseTransactionManager : created Transactions: " + transactions);
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * @see org.springframework.transaction.reactive.AbstractReactiveTransactionManager#doGetTransaction(org.springframework.transaction.reactive.TransactionSynchronizationManager)
+	 */
+	@Override
+	protected Object doGetTransaction(TransactionSynchronizationManager synchronizationManager)
+			throws TransactionException {
+		// creation of a new ReactiveCouchbaseTransactionObject (i.e. transaction).
+		// with an attempt to get the resourceHolder from the synchronizationManager
+		ReactiveCouchbaseResourceHolder resourceHolder = (ReactiveCouchbaseResourceHolder) synchronizationManager
+				.getResource(getRequiredDatabaseFactory().getCluster().block());
+		// TODO ACR from couchbase
+		// resourceHolder.getSession().setAttemptContextReactive(null);
+		return new ReactiveCouchbaseTransactionObject(resourceHolder);
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * @see org.springframework.transaction.reactive.AbstractReactiveTransactionManager#isExistingTransaction(java.lang.Object)
+	 */
+	@Override
+	protected boolean isExistingTransaction(Object transaction) throws TransactionException {
+		return extractCouchbaseTransaction(transaction).hasResourceHolder();
+	}
+
+	/**
+	 * doBegin() attaches the atr from the transactionOperator in the transactionDefinition to the transaction (via
+	 * resourceHolder -> Clientsession) (non-Javadoc)
+	 *
+	 * @see org.springframework.transaction.reactive.AbstractReactiveTransactionManager#doBegin(org.springframework.transaction.reactive.TransactionSynchronizationManager,
+	 *      java.lang.Object, org.springframework.transaction.TransactionDefinition)
+	 */
+	@Override
+	protected Mono<Void> doBegin(TransactionSynchronizationManager synchronizationManager, Object transaction,
+								 TransactionDefinition definition) throws TransactionException {
+
+		return Mono.defer(() -> {
+
+			ReactiveCouchbaseTransactionObject couchbaseTransactionObject = extractCouchbaseTransaction(transaction);
+			// TODO mr - why aren't we creating the AttemptContext here in the client session in the resourceholder?
+			Mono<ReactiveCouchbaseResourceHolder> holder = newResourceHolder(definition,
+					TransactionOptions.transactionOptions());
+			return holder.doOnNext(resourceHolder -> {
+				couchbaseTransactionObject.setResourceHolder(resourceHolder);
+				if (logger.isDebugEnabled()) {
+					logger.debug(
+							String.format("About to start transaction for session %s.", debugString(resourceHolder.getCore())));
+				}
+			}).doOnNext(resourceHolder -> {
+				couchbaseTransactionObject.startTransaction();
+				if (logger.isDebugEnabled()) {
+					logger.debug(String.format("Started transaction for session %s.", debugString(resourceHolder.getCore())));
+				}
+			})//
+					.onErrorMap(ex -> new TransactionSystemException(
+							String.format("Could not start Couchbase transaction for session %s.",
+									debugString(couchbaseTransactionObject.getCore())),
+							ex))
+					.doOnSuccess(resourceHolder -> {
+						System.err.println("ReactiveCouchbaseTransactionManager: " + this);
+						System.err.println(
+								"bindResource: " + getRequiredDatabaseFactory().getCluster().block() + " value: " + resourceHolder);
+						synchronizationManager.bindResource(getRequiredDatabaseFactory().getCluster().block(), resourceHolder);
+					}).then();
+		});
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * @see org.springframework.transaction.reactive.AbstractReactiveTransactionManager#doSuspend(org.springframework.transaction.reactive.TransactionSynchronizationManager, java.lang.Object)
+	 */
+	@Override
+	protected Mono<Object> doSuspend(TransactionSynchronizationManager synchronizationManager, Object transaction)
+			throws TransactionException {
+
+		return Mono.fromSupplier(() -> {
+
+			ReactiveCouchbaseTransactionObject mongoTransactionObject = extractCouchbaseTransaction(transaction);
+			mongoTransactionObject.setResourceHolder(null);
+
+			return synchronizationManager.unbindResource(getRequiredDatabaseFactory());
+		});
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * @see org.springframework.transaction.reactive.AbstractReactiveTransactionManager#doResume(org.springframework.transaction.reactive.TransactionSynchronizationManager, java.lang.Object, java.lang.Object)
+	 */
+	@Override
+	protected Mono<Void> doResume(TransactionSynchronizationManager synchronizationManager, @Nullable Object transaction,
+								  Object suspendedResources) {
+		return Mono
+				.fromRunnable(() -> synchronizationManager.bindResource(getRequiredDatabaseFactory(), suspendedResources));
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * @see org.springframework.transaction.reactive.AbstractReactiveTransactionManager#doCommit(org.springframework.transaction.reactive.TransactionSynchronizationManager, org.springframework.transaction.reactive.GenericReactiveTransaction)
+	 */
+	@Override
+	protected final Mono<Void> doCommit(TransactionSynchronizationManager synchronizationManager,
+										GenericReactiveTransaction status) throws TransactionException {
+		return Mono.defer(() -> {
+
+			ReactiveCouchbaseTransactionObject couchbaseTransactionObject = extractCouchbaseTransaction(status);
+
+			if (logger.isDebugEnabled()) {
+				logger.debug(String.format("About to doCommit transaction for session %s.",
+						debugString(couchbaseTransactionObject.getCore())));
+			}
+
+			return doCommit(synchronizationManager, couchbaseTransactionObject).onErrorMap(ex -> {
+				return new TransactionSystemException(String.format("Could not commit Couchbase transaction for session %s.",
+						debugString(couchbaseTransactionObject.getCore())), ex);
+			});
+		});
+	}
+
+	/**
+	 * Customization hook to perform an actual commit of the given transaction.<br />
+	 * If a commit operation encounters an error, the XxxxxxXX driver throws a {@link CouchbaseException} holding
+	 * {@literal error labels}. <br />
+	 * By default those labels are ignored, nevertheless one might check for {@link CouchbaseException transient commit
+	 * errors labels} and retry the the commit.
+	 *
+	 * @param synchronizationManager reactive synchronization manager.
+	 * @param transactionObject never {@literal null}.
+	 */
+	protected Mono<Void> doCommit(TransactionSynchronizationManager synchronizationManager,
+								  ReactiveCouchbaseTransactionObject transactionObject) {
+		return transactionObject.commitTransaction();
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * @see org.springframework.transaction.reactive.AbstractReactiveTransactionManager#doRollback(org.springframework.transaction.reactive.TransactionSynchronizationManager, org.springframework.transaction.reactive.GenericReactiveTransaction)
+	 */
+	@Override
+	protected Mono<Void> doRollback(TransactionSynchronizationManager synchronizationManager,
+									GenericReactiveTransaction status) {
+
+		return Mono.defer(() -> {
+
+			ReactiveCouchbaseTransactionObject couchbaseTransactionObject = extractCouchbaseTransaction(status);
+
+			if (logger.isDebugEnabled()) {
+				logger.debug(String.format("About to abort transaction for session %s.",
+						debugString(couchbaseTransactionObject.getCore())));
+			}
+
+			return couchbaseTransactionObject.abortTransaction().onErrorResume(CouchbaseException.class, ex -> {
+				return Mono.error(new TransactionSystemException(String.format("Could not abort transaction for session %s.",
+						debugString(couchbaseTransactionObject.getCore())), ex));
+			});
+		});
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * @see org.springframework.transaction.reactive.AbstractReactiveTransactionManager#doSetRollbackOnly(org.springframework.transaction.reactive.TransactionSynchronizationManager, org.springframework.transaction.reactive.GenericReactiveTransaction)
+	 */
+	@Override
+	protected Mono<Void> doSetRollbackOnly(TransactionSynchronizationManager synchronizationManager,
+										   GenericReactiveTransaction status) throws TransactionException {
+
+		return Mono.fromRunnable(() -> {
+			ReactiveCouchbaseTransactionObject transactionObject = extractCouchbaseTransaction(status);
+			transactionObject.getRequiredResourceHolder().setRollbackOnly();
+		});
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * @see org.springframework.transaction.reactive.AbstractReactiveTransactionManager#doCleanupAfterCompletion(org.springframework.transaction.reactive.TransactionSynchronizationManager, java.lang.Object)
+	 */
+	@Override
+	protected Mono<Void> doCleanupAfterCompletion(TransactionSynchronizationManager synchronizationManager,
+												  Object transaction) {
+
+		Assert.isInstanceOf(ReactiveCouchbaseTransactionObject.class, transaction,
+				() -> String.format("Expected to find a %s but it turned out to be %s.",
+						ReactiveCouchbaseTransactionObject.class, transaction.getClass()));
+
+		return Mono.fromRunnable(() -> {
+			ReactiveCouchbaseTransactionObject couchbaseTransactionObject = (ReactiveCouchbaseTransactionObject) transaction;
+
+			// Remove the connection holder from the thread.
+			synchronizationManager.unbindResource(getRequiredDatabaseFactory().getCluster().block());
+			couchbaseTransactionObject.getRequiredResourceHolder().clear();
+
+			if (logger.isDebugEnabled()) {
+				logger.debug(String.format("About to release Session %s after transaction.",
+						debugString(couchbaseTransactionObject.getCore())));
+			}
+
+			couchbaseTransactionObject.closeSession();
+		});
+	}
+
+	/**
+	 * Set the {@link CouchbaseClientFactory} that this instance should manage transactions for.
+	 *
+	 * @param databaseFactory must not be {@literal null}.
+	 */
+	public void setDatabaseFactory(ReactiveCouchbaseClientFactory databaseFactory) {
+
+		Assert.notNull(databaseFactory, "DatabaseFactory must not be null!");
+		this.databaseFactory = databaseFactory;
+	}
+
+	/**
+	 * Get the {@link CouchbaseClientFactory} that this instance manages transactions for.
+	 *
+	 * @return can be {@literal null}.
+	 */
+	@Nullable
+	public ReactiveCouchbaseClientFactory getDatabaseFactory() {
+		return databaseFactory;
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet()
+	 */
+	@Override
+	public void afterPropertiesSet() {
+		getRequiredDatabaseFactory();
+	}
+
+	private Mono<ReactiveCouchbaseResourceHolder> newResourceHolder(TransactionDefinition definition,
+																	TransactionOptions options) {
+
+		ReactiveCouchbaseClientFactory dbFactory = getRequiredDatabaseFactory();
+		// TODO MSR : config should be derived from config that was used for `transactions`
+		Mono<ReactiveCouchbaseResourceHolder> sess = Mono.just(dbFactory.getTransactionResources(options, null));
+		return sess;
+	}
+
+	/**
+	 * @throws IllegalStateException if {@link #databaseFactory} is {@literal null}.
+	 */
+	private ReactiveCouchbaseClientFactory getRequiredDatabaseFactory() {
+		Assert.state(databaseFactory != null,
+				"ReactiveCouchbaseTransactionManager operates upon a CouchbaseClientFactory. Did you forget to provide one? It's required.");
+		return databaseFactory;
+	}
+
+	private static ReactiveCouchbaseTransactionObject extractCouchbaseTransaction(Object transaction) {
+
+		Assert.isInstanceOf(ReactiveCouchbaseTransactionObject.class, transaction,
+				() -> String.format("Expected to find a %s but it turned out to be %s.",
+						ReactiveCouchbaseTransactionObject.class, transaction.getClass()));
+
+		return (ReactiveCouchbaseTransactionObject) transaction;
+	}
+
+	private static ReactiveCouchbaseTransactionObject extractCouchbaseTransaction(GenericReactiveTransaction status) {
+
+		Assert.isInstanceOf(ReactiveCouchbaseTransactionObject.class, status.getTransaction(),
+				() -> String.format("Expected to find a %s but it turned out to be %s.",
+						ReactiveCouchbaseTransactionObject.class, status.getTransaction().getClass()));
+
+		return (ReactiveCouchbaseTransactionObject) status.getTransaction();
+	}
+
+	private static String debugString(@Nullable CoreTransactionAttemptContext session) {
+
+		if (session == null) {
+			return "null";
+		}
+
+		String debugString = String.format("[%s@%s ", ClassUtils.getShortName(session.getClass()),
+				Integer.toHexString(session.hashCode()));
+
+		try {
+			debugString += String.format("core=%s", session);
+		} catch (RuntimeException e) {
+			debugString += String.format("error = %s", e.getMessage());
+		}
+
+		debugString += "]";
+
+		return debugString;
+	}
+
+	/**
+	 * Couchbase specific transaction object, representing a {@link ReactiveCouchbaseResourceHolder}. Used as transaction
+	 * object by {@link ReactiveCouchbaseTransactionManager}.
+	 *
+	 * @author Christoph Strobl
+	 * @author Mark Paluch
+	 * @since 2.2
+	 * @see ReactiveCouchbaseResourceHolder
+	 */
+	protected static class ReactiveCouchbaseTransactionObject implements SmartTransactionObject {
+
+		public @Nullable ReactiveCouchbaseResourceHolder resourceHolder;
+
+		ReactiveCouchbaseTransactionObject(@Nullable ReactiveCouchbaseResourceHolder resourceHolder) {
+			this.resourceHolder = resourceHolder;
+		}
+
+		/**
+		 * Set the {@link ReactiveCouchbaseResourceHolder}.
+		 *
+		 * @param resourceHolder can be {@literal null}.
+		 */
+		void setResourceHolder(@Nullable ReactiveCouchbaseResourceHolder resourceHolder) {
+			this.resourceHolder = resourceHolder;
+		}
+
+		/**
+		 * @return {@literal true} if a {@link ReactiveCouchbaseResourceHolder} is set.
+		 */
+		final boolean hasResourceHolder() {
+			return resourceHolder != null;
+		}
+
+		/**
+		 * Start a XxxxxxXX transaction optionally given {@link TransactionQueryOptions}. todo gp how to expose
+		 * TransactionOptions
+		 *
+		 * @param options can be {@literal null}
+		 */
+		void startTransaction() {
+
+			CoreTransactionAttemptContext core = getRequiredCore();
+			// core.startTransaction();
+		}
+
+		/**
+		 * Commit the transaction.
+		 */
+		public Mono<Void> commitTransaction() {
+			return getRequiredCore().commit();
+		}
+
+		/**
+		 * Rollback (abort) the transaction.
+		 */
+		public Mono<Void> abortTransaction() {
+			return getRequiredCore().rollback();
+		}
+
+		/**
+		 * Close a {@link CoreTransactionAttemptContext} without regard to its transactional state.
+		 */
+		void closeSession() {
+			CoreTransactionAttemptContext session = getRequiredCore();
+			// if (session.getServerSession() != null && !session.getServerSession().isClosed()) {
+			// session.close();
+			// }
+		}
+
+		@Nullable
+		public CoreTransactionAttemptContext getCore() {
+			return resourceHolder != null ? resourceHolder.getCore() : null;
+		}
+
+		private ReactiveCouchbaseResourceHolder getRequiredResourceHolder() {
+
+			Assert.state(resourceHolder != null, "ReactiveMongoResourceHolder is required but not present. o_O");
+			return resourceHolder;
+		}
+
+		private CoreTransactionAttemptContext getRequiredCore() {
+			CoreTransactionAttemptContext core = getCore();
+			Assert.state(core != null, "A CoreTransactionAttemptContext is required but it turned out to be null.");
+			return core;
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * @see org.springframework.transaction.support.SmartTransactionObject#isRollbackOnly()
+		 */
+		@Override
+		public boolean isRollbackOnly() {
+			return this.resourceHolder != null && this.resourceHolder.isRollbackOnly();
+		}
+
+		/*
+		 * (non-Javadoc)
+		 * @see org.springframework.transaction.support.SmartTransactionObject#flush()
+		 */
+		@Override
+		public void flush() {
+			throw new UnsupportedOperationException("flush() not supported");
+		}
+	}
+}
diff --git a/src/main/java/org/springframework/data/couchbase/transaction/ReactiveTransactionsWrapper.java b/src/main/java/org/springframework/data/couchbase/transaction/ReactiveTransactionsWrapper.java
new file mode 100644
index 00000000..b4aa21ce
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/transaction/ReactiveTransactionsWrapper.java
@@ -0,0 +1,71 @@
+package org.springframework.data.couchbase.transaction;
+
+import reactor.core.publisher.Mono;
+
+import java.util.function.Function;
+
+import org.springframework.data.couchbase.ReactiveCouchbaseClientFactory;
+import org.springframework.transaction.ReactiveTransaction;
+import org.springframework.transaction.TransactionDefinition;
+import org.springframework.transaction.reactive.TransactionContextManager;
+import org.springframework.transaction.reactive.TransactionSynchronizationManager;
+
+import com.couchbase.client.java.transactions.AttemptContextReactiveAccessor;
+import com.couchbase.client.java.transactions.ReactiveTransactionAttemptContext;
+import com.couchbase.client.java.transactions.TransactionResult;
+import com.couchbase.client.java.transactions.config.TransactionOptions;
+
+// todo gp needed now Transactions has gone?
+public class ReactiveTransactionsWrapper /* wraps ReactiveTransactions */ {
+	ReactiveCouchbaseClientFactory reactiveCouchbaseClientFactory;
+
+	public ReactiveTransactionsWrapper(ReactiveCouchbaseClientFactory reactiveCouchbaseClientFactory) {
+		this.reactiveCouchbaseClientFactory = reactiveCouchbaseClientFactory;
+	}
+
+	/**
+	 * A convenience wrapper around {@link TransactionsReactive#run}, that provides a default
+	 * <code>PerTransactionConfig</code>.
+	 */
+
+	public Mono<TransactionResult> run(Function<ReactiveTransactionAttemptContext, Mono<?>> transactionLogic) {
+		return run(transactionLogic, null);
+	}
+
+	public Mono<TransactionResult> run(Function<ReactiveTransactionAttemptContext, Mono<?>> transactionLogic,
+			TransactionOptions perConfig) {
+		// todo gp this is duplicating a lot of logic from the core loop, and is hopefully not needed.
+		// todo ^^^ I think I removed all the duplicate logic.
+		Function<ReactiveTransactionAttemptContext, Mono<?>> newTransactionLogic = (ctx) -> {
+			ReactiveCouchbaseResourceHolder resourceHolder = reactiveCouchbaseClientFactory.getTransactionResources(
+					TransactionOptions.transactionOptions(), AttemptContextReactiveAccessor.getCore(ctx));
+			Mono<TransactionSynchronizationManager> sync = TransactionContextManager.currentContext()
+					.map(TransactionSynchronizationManager::new).flatMap(synchronizationManager -> {
+						synchronizationManager.bindResource(reactiveCouchbaseClientFactory.getBlockingCluster(), resourceHolder);
+						prepareSynchronization(synchronizationManager, null, new CouchbaseTransactionDefinition());
+						return transactionLogic.apply(ctx) // <---- execute the transaction
+								.thenReturn(ctx).then(Mono.just(synchronizationManager));
+					});
+			return sync.contextWrite(TransactionContextManager.getOrCreateContext())
+					.contextWrite(TransactionContextManager.getOrCreateContextHolder());
+		};
+
+		return reactiveCouchbaseClientFactory.getBlockingCluster().reactive().transactions().run(newTransactionLogic,
+				perConfig);
+
+	}
+
+	private static void prepareSynchronization(TransactionSynchronizationManager synchronizationManager,
+			ReactiveTransaction status, TransactionDefinition definition) {
+		// if (status.isNewTransaction()) {
+		synchronizationManager.setActualTransactionActive(false /*status.hasTransaction()*/);
+		synchronizationManager.setCurrentTransactionIsolationLevel(
+				definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ? definition.getIsolationLevel()
+						: null);
+		synchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly());
+		synchronizationManager.setCurrentTransactionName(definition.getName());
+		synchronizationManager.initSynchronization();
+		// }
+	}
+
+}
diff --git a/src/main/java/org/springframework/data/couchbase/transaction/ServerSession.java b/src/main/java/org/springframework/data/couchbase/transaction/ServerSession.java
new file mode 100644
index 00000000..d53cf1f0
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/transaction/ServerSession.java
@@ -0,0 +1,19 @@
+package org.springframework.data.couchbase.transaction;
+
+/**
+ * used only by ClientSession.getServerSession() - which returns null
+ */
+
+public interface ServerSession {
+  String getIdentifier();
+
+  long getTransactionNumber();
+
+  long advanceTransactionNumber();
+
+  boolean isClosed();
+
+  void markDirty();
+
+  boolean isMarkedDirty();
+}
diff --git a/src/main/java/org/springframework/data/couchbase/transaction/SessionAwareMethodInterceptor.java b/src/main/java/org/springframework/data/couchbase/transaction/SessionAwareMethodInterceptor.java
new file mode 100644
index 00000000..ebf1c284
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/transaction/SessionAwareMethodInterceptor.java
@@ -0,0 +1,213 @@
+/*
+ * Copyright 2018-2021 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.couchbase.transaction;
+
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+import java.util.Optional;
+import java.util.function.BiFunction;
+
+import com.couchbase.client.core.transaction.CoreTransactionAttemptContext;
+import org.aopalliance.intercept.MethodInterceptor;
+import org.aopalliance.intercept.MethodInvocation;
+import org.springframework.core.MethodClassKey;
+import org.springframework.lang.Nullable;
+import org.springframework.util.Assert;
+import org.springframework.util.ClassUtils;
+import org.springframework.util.ConcurrentReferenceHashMap;
+import org.springframework.util.ReflectionUtils;
+
+/**
+ * {@link MethodInterceptor} implementation looking up and invoking an alternative target method having
+ * {@link CoreTransactionAttemptContext} as its first argument. This allows seamless integration with the existing code base.
+ * <br />
+ * The {@link MethodInterceptor} is aware of methods on {@code MongoCollection} that my return new instances of itself
+ * like (eg. TODO) and decorate them
+ * if not already proxied.
+ *
+ * @param <D> Type of the actual Mongo Database.
+ * @param <C> Type of the actual Mongo Collection.
+ * @author Christoph Strobl
+ * @author Mark Paluch
+ * @since 2.1
+ */
+public class SessionAwareMethodInterceptor<D, C> implements MethodInterceptor {
+
+  private static final MethodCache METHOD_CACHE = new MethodCache();
+
+  private final ReactiveCouchbaseResourceHolder session;
+  private final ReactiveCouchbaseResourceHolderOperator collectionDecorator;
+  private final ReactiveCouchbaseResourceHolderOperator databaseDecorator;
+  private final Object target;
+  private final Class<?> targetType;
+  private final Class<?> collectionType;
+  private final Class<?> databaseType;
+  private final Class<? extends ReactiveCouchbaseResourceHolder> sessionType;
+
+  /**
+   * Create a new SessionAwareMethodInterceptor for given target.
+   *
+   * @param session the {@link CoreTransactionAttemptContext} to be used on invocation.
+   * @param target the original target object.
+   * @param databaseType the MongoDB database type
+   * @param databaseDecorator a {@link ReactiveCouchbaseResourceHolderOperator} used to create the proxy for an imperative / reactive
+   *          {@code MongoDatabase}.
+   * @param collectionType the MongoDB collection type.
+   * @param collectionDecorator a {@link ReactiveCouchbaseResourceHolderOperator} used to create the proxy for an imperative / reactive
+   *          {@code MongoCollection}.
+   * @param <T> target object type.
+   */
+  public <T> SessionAwareMethodInterceptor(ReactiveCouchbaseResourceHolder session, T target, Class<? extends ReactiveCouchbaseResourceHolder> sessionType,
+                                           Class<D> databaseType, ReactiveCouchbaseResourceHolderOperator<D> databaseDecorator, Class<C> collectionType,
+                                           ReactiveCouchbaseResourceHolderOperator<C> collectionDecorator) {
+
+    Assert.notNull(session, "CoreTransactionAttemptContext must not be null!");
+    Assert.notNull(target, "Target must not be null!");
+    Assert.notNull(sessionType, "SessionType must not be null!");
+    Assert.notNull(databaseType, "Database type must not be null!");
+    Assert.notNull(databaseDecorator, "Database CoreTransactionAttemptContextOperator must not be null!");
+    Assert.notNull(collectionType, "Collection type must not be null!");
+    Assert.notNull(collectionDecorator, "Collection CoreTransactionAttemptContextOperator must not be null!");
+
+    this.session = session;
+    this.target = target;
+    this.databaseType = ClassUtils.getUserClass(databaseType);
+    this.collectionType = ClassUtils.getUserClass(collectionType);
+    this.collectionDecorator = collectionDecorator;
+    this.databaseDecorator = databaseDecorator;
+
+    this.targetType = ClassUtils.isAssignable(databaseType, target.getClass()) ? databaseType : collectionType;
+    this.sessionType = sessionType;
+  }
+
+  /*
+   * (non-Javadoc)
+   * @see org.aopalliance.intercept.MethodInterceptor(org.aopalliance.intercept.MethodInvocation)
+   */
+  @Nullable
+  @Override
+  public Object invoke(MethodInvocation methodInvocation) throws Throwable {
+
+    if (requiresDecoration(methodInvocation.getMethod())) {
+
+      Object target = methodInvocation.proceed();
+      if (target instanceof Proxy) {
+        return target;
+      }
+
+      return decorate(target);
+    }
+
+    if (!requiresSession(methodInvocation.getMethod())) {
+      return methodInvocation.proceed();
+    }
+
+    Optional<Method> targetMethod = METHOD_CACHE.lookup(methodInvocation.getMethod(), targetType, sessionType);
+
+    return !targetMethod.isPresent() ? methodInvocation.proceed()
+            : ReflectionUtils.invokeMethod(targetMethod.get(), target,
+            prependSessionToArguments(session, methodInvocation));
+  }
+
+  private boolean requiresDecoration(Method method) {
+
+    return ClassUtils.isAssignable(databaseType, method.getReturnType())
+            || ClassUtils.isAssignable(collectionType, method.getReturnType());
+  }
+
+  @SuppressWarnings("unchecked")
+  protected Object decorate(Object target) {
+
+    return ClassUtils.isAssignable(databaseType, target.getClass()) ? databaseDecorator.apply(session, target)
+            : collectionDecorator.apply(session, target);
+  }
+
+  private static boolean requiresSession(Method method) {
+
+    if (method.getParameterCount() == 0
+            || !ClassUtils.isAssignable(CoreTransactionAttemptContext.class, method.getParameterTypes()[0])) {
+      return true;
+    }
+
+    return false;
+  }
+
+  private static Object[] prependSessionToArguments(ReactiveCouchbaseResourceHolder session, MethodInvocation invocation) {
+
+    Object[] args = new Object[invocation.getArguments().length + 1];
+
+    args[0] = session;
+    System.arraycopy(invocation.getArguments(), 0, args, 1, invocation.getArguments().length);
+
+    return args;
+  }
+
+  /**
+   * Simple {@link Method} to {@link Method} caching facility for {@link CoreTransactionAttemptContext} overloaded targets.
+   *
+   * @since 2.1
+   * @author Christoph Strobl
+   */
+  static class MethodCache {
+
+    private final ConcurrentReferenceHashMap<MethodClassKey, Optional<Method>> cache = new ConcurrentReferenceHashMap<>();
+
+    /**
+     * Lookup the target {@link Method}.
+     *
+     * @param method
+     * @param targetClass
+     * @return
+     */
+    Optional<Method> lookup(Method method, Class<?> targetClass, Class<? extends ReactiveCouchbaseResourceHolder> sessionType) {
+
+      return cache.computeIfAbsent(new MethodClassKey(method, targetClass),
+              val -> Optional.ofNullable(findTargetWithSession(method, targetClass, sessionType)));
+    }
+
+    @Nullable
+    private Method findTargetWithSession(Method sourceMethod, Class<?> targetType,
+                                         Class<? extends ReactiveCouchbaseResourceHolder> sessionType) {
+
+      Class<?>[] argTypes = sourceMethod.getParameterTypes();
+      Class<?>[] args = new Class<?>[argTypes.length + 1];
+      args[0] = sessionType;
+      System.arraycopy(argTypes, 0, args, 1, argTypes.length);
+
+      return ReflectionUtils.findMethod(targetType, sourceMethod.getName(), args);
+    }
+
+    /**
+     * Check whether the cache contains an entry for {@link Method} and {@link Class}.
+     *
+     * @param method
+     * @param targetClass
+     * @return
+     */
+    boolean contains(Method method, Class<?> targetClass) {
+      return cache.containsKey(new MethodClassKey(method, targetClass));
+    }
+  }
+
+  /**
+   * Represents an operation upon two operands of the same type, producing a result of the same type as the operands
+   * accepting {@link CoreTransactionAttemptContext}. This is a specialization of {@link BiFunction} for the case where the operands and
+   * the result are all of the same type.
+   *
+   * @param <T> the type of the operands and result of the operator
+   */
+  public interface ReactiveCouchbaseResourceHolderOperator<T> extends BiFunction<ReactiveCouchbaseResourceHolder, T, T> {}
+}
diff --git a/src/main/java/org/springframework/data/couchbase/transaction/SessionSynchronization.java b/src/main/java/org/springframework/data/couchbase/transaction/SessionSynchronization.java
new file mode 100644
index 00000000..d62633ba
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/transaction/SessionSynchronization.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2018-2021 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.couchbase.transaction;
+
+/**
+ * TODO MSR not used
+ * {@link SessionSynchronization} is used along with {@link org.springframework.data.couchbase.core.CouchbaseTemplate} to
+ * define in which type of transactions to participate if any.
+ *
+ * @author Michael Reiche
+ */
+public enum SessionSynchronization {
+
+	/**
+	 * Synchronize with any transaction even with empty transactions and initiate a MongoDB transaction when doing so by
+	 * registering a MongoDB specific {@link org.springframework.transaction.support.ResourceHolderSynchronization}.
+	 */
+	ALWAYS,
+
+	/**
+	 * Synchronize with native MongoDB transactions initiated via {@link ReactiveCouchbaseTransactionManager}.
+	 */
+	ON_ACTUAL_TRANSACTION,
+	NEVER;
+
+}
diff --git a/src/main/java/org/springframework/data/couchbase/transaction/TransactionsWrapper.java b/src/main/java/org/springframework/data/couchbase/transaction/TransactionsWrapper.java
new file mode 100644
index 00000000..68243b73
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/transaction/TransactionsWrapper.java
@@ -0,0 +1,106 @@
+package org.springframework.data.couchbase.transaction;
+
+import static org.springframework.data.couchbase.transaction.CouchbaseTransactionManager.debugString;
+import static org.springframework.data.couchbase.transaction.CouchbaseTransactionManager.newResourceHolder;
+
+import reactor.util.annotation.Nullable;
+
+import java.util.function.Consumer;
+
+import org.springframework.data.couchbase.CouchbaseClientFactory;
+import org.springframework.transaction.support.TransactionSynchronizationManager;
+
+import com.couchbase.client.core.error.transaction.internal.CoreTransactionFailedException;
+import com.couchbase.client.core.transaction.CoreTransactionAttemptContext;
+import com.couchbase.client.core.transaction.CoreTransactionResult;
+import com.couchbase.client.core.transaction.log.CoreTransactionLogger;
+import com.couchbase.client.java.transactions.AttemptContextReactiveAccessor;
+import com.couchbase.client.java.transactions.TransactionAttemptContext;
+import com.couchbase.client.java.transactions.TransactionResult;
+import com.couchbase.client.java.transactions.Transactions;
+import com.couchbase.client.java.transactions.config.TransactionOptions;
+import com.couchbase.client.java.transactions.error.TransactionFailedException;
+
+// todo gp needed now Transactions has gone?
+public class TransactionsWrapper /* wraps Transactions */ {
+	CouchbaseClientFactory couchbaseClientFactory;
+
+	public TransactionsWrapper(CouchbaseClientFactory couchbaseClientFactory) {
+		this.couchbaseClientFactory = couchbaseClientFactory;
+	}
+
+
+	/**
+	 * Runs supplied transactional logic until success or failure.
+	 * <p>
+	 * The supplied transactional logic will be run if necessary multiple times, until either:
+	 * <ul>
+	 * <li>The transaction successfully commits</li>
+	 * <li>The transactional logic requests an explicit rollback</li>
+	 * <li>The transaction timesout.</li>
+	 * <li>An exception is thrown, either inside the transaction library or by the supplied transaction logic, that cannot
+	 * be handled.
+	 * </ul>
+	 * <p>
+	 * The transaction logic {@link Consumer} is provided an {@link TransactionAttemptContext}, which contains methods
+	 * allowing it to read, mutate, insert and delete documents, as well as commit or rollback the transaction.
+	 * <p>
+	 * If the transaction logic performs a commit or rollback it must be the last operation performed. Else a
+	 * {@link com.couchbase.client.java.transactions.error.TransactionFailedException} will be thrown. Similarly, there
+	 * cannot be a commit followed by a rollback, or vice versa - this will also raise a
+	 * {@link CoreTransactionFailedException}.
+	 * <p>
+	 * If the transaction logic does not perform an explicit commit or rollback, then a commit will be performed anyway.
+	 *
+	 * @param transactionLogic the application's transaction logic
+	 * @param options the configuration to use for this transaction
+	 * @return there is no need to check the returned {@link CoreTransactionResult}, as success is implied by the lack of
+	 *         a thrown exception. It contains information useful only for debugging and logging.
+	 * @throws TransactionFailedException or a derived exception if the transaction fails to commit for any reason,
+	 *           possibly after multiple retries. The exception contains further details of the error
+	 */
+
+	public TransactionResult run(Consumer<TransactionAttemptContext> transactionLogic,
+			@Nullable TransactionOptions options) {
+		Consumer<TransactionAttemptContext> newTransactionLogic = (ctx) -> {
+			try {
+				CoreTransactionLogger logger = AttemptContextReactiveAccessor.getLogger(ctx);
+				CoreTransactionAttemptContext atr = AttemptContextReactiveAccessor.getCore(ctx);
+
+				// from CouchbaseTransactionManager
+				ReactiveCouchbaseResourceHolder resourceHolder = newResourceHolder(couchbaseClientFactory,
+						/*definition*/ new CouchbaseTransactionDefinition(), TransactionOptions.transactionOptions(), atr);
+				// couchbaseTransactionObject.setResourceHolder(resourceHolder);
+
+				logger
+						.debug(String.format("About to start transaction for session %s.", debugString(resourceHolder.getCore())));
+
+				logger.debug(String.format("Started transaction for session %s.", debugString(resourceHolder.getCore())));
+
+				TransactionSynchronizationManager.setActualTransactionActive(true);
+				resourceHolder.setSynchronizedWithTransaction(true);
+				TransactionSynchronizationManager.unbindResourceIfPossible(couchbaseClientFactory.getCluster());
+				logger.debug("CouchbaseTransactionManager: " + this);
+				logger.debug("bindResource: " + couchbaseClientFactory.getCluster() + " value: " + resourceHolder);
+				TransactionSynchronizationManager.bindResource(couchbaseClientFactory.getCluster(), resourceHolder);
+
+				transactionLogic.accept(ctx);
+			} finally {
+				TransactionSynchronizationManager.unbindResource(couchbaseClientFactory.getCluster());
+			}
+		};
+
+		return AttemptContextReactiveAccessor.run(couchbaseClientFactory.getCluster().transactions(), newTransactionLogic,
+				options == null ? null : options.build());
+	}
+
+	/**
+	 * Runs supplied transactional logic until success or failure. A convenience overload for {@link Transactions#run}
+	 * that provides a default <code>PerTransactionConfig</code>
+	 */
+
+	public TransactionResult run(Consumer<TransactionAttemptContext> transactionLogic) {
+		return run(transactionLogic, null);
+	}
+
+}
diff --git a/src/main/java/org/springframework/data/couchbase/transaction/interceptor/CouchbaseTransactionInterceptor.java b/src/main/java/org/springframework/data/couchbase/transaction/interceptor/CouchbaseTransactionInterceptor.java
new file mode 100644
index 00000000..66b1c00e
--- /dev/null
+++ b/src/main/java/org/springframework/data/couchbase/transaction/interceptor/CouchbaseTransactionInterceptor.java
@@ -0,0 +1,418 @@
+/*
+ * Copyright 2002-2020 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.couchbase.transaction.interceptor;
+
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import java.lang.reflect.Method;
+import java.util.Properties;
+import java.util.concurrent.ConcurrentMap;
+
+import org.aopalliance.intercept.MethodInterceptor;
+import org.aopalliance.intercept.MethodInvocation;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.springframework.aop.support.AopUtils;
+import org.springframework.beans.factory.BeanFactory;
+import org.springframework.core.ReactiveAdapterRegistry;
+import org.springframework.lang.Nullable;
+import org.springframework.transaction.PlatformTransactionManager;
+import org.springframework.transaction.ReactiveTransactionManager;
+import org.springframework.transaction.TransactionManager;
+import org.springframework.transaction.TransactionStatus;
+import org.springframework.transaction.TransactionSystemException;
+import org.springframework.transaction.interceptor.DefaultTransactionAttribute;
+import org.springframework.transaction.interceptor.TransactionAspectSupport;
+import org.springframework.transaction.interceptor.TransactionAttribute;
+import org.springframework.transaction.interceptor.TransactionAttributeSource;
+import org.springframework.transaction.interceptor.TransactionInterceptor;
+import org.springframework.transaction.interceptor.TransactionProxyFactoryBean;
+import org.springframework.transaction.support.CallbackPreferringPlatformTransactionManager;
+import org.springframework.util.ClassUtils;
+import org.springframework.util.ConcurrentReferenceHashMap;
+
+/**
+ * AOP Alliance MethodInterceptor for declarative transaction
+ * management using the common Spring transaction infrastructure
+ * ({@link org.springframework.transaction.PlatformTransactionManager}/
+ * {@link org.springframework.transaction.ReactiveTransactionManager}).
+ *
+ * <p>Derives from the {@link TransactionAspectSupport} class which
+ * contains the integration with Spring's underlying transaction API.
+ * TransactionInterceptor simply calls the relevant superclass methods
+ * such as {@link #invokeWithinTransaction} in the correct order.
+ *
+ * <p>TransactionInterceptors are thread-safe.
+ *
+ * @author Rod Johnson
+ * @author Juergen Hoeller
+ * @author Sebastien Deleuze
+ * @see TransactionProxyFactoryBean
+ * @see org.springframework.aop.framework.ProxyFactoryBean
+ * @see org.springframework.aop.framework.ProxyFactory
+ */
+@SuppressWarnings("serial")
+public class CouchbaseTransactionInterceptor extends TransactionInterceptor implements MethodInterceptor, Serializable {
+
+// NOTE: This class must not implement Serializable because it serves as base
+  // class for AspectJ aspects (which are not allowed to implement Serializable)!
+
+  /**
+   * Vavr library present on the classpath?
+   */
+  private static final boolean vavrPresent = ClassUtils.isPresent(
+      "io.vavr.control.Try", TransactionAspectSupport.class.getClassLoader());
+
+  /**
+   * Reactive Streams API present on the classpath?
+   */
+  private static final boolean reactiveStreamsPresent =
+      ClassUtils.isPresent("org.reactivestreams.Publisher", TransactionAspectSupport.class.getClassLoader());
+
+  protected final Log logger = LogFactory.getLog(getClass());
+
+  @Nullable
+  private final ReactiveAdapterRegistry reactiveAdapterRegistry;
+
+  private final ConcurrentMap<Object, TransactionManager> transactionManagerCache =
+      new ConcurrentReferenceHashMap<>(4);
+
+  /**
+   * Create a new TransactionInterceptor.
+   * <p>Transaction manager and transaction attributes still need to be set.
+   * @see #setTransactionManager
+   * @see #setTransactionAttributes(java.util.Properties)
+   * @see #setTransactionAttributeSource(TransactionAttributeSource)
+   */
+  public CouchbaseTransactionInterceptor() {
+    if (reactiveStreamsPresent) {
+      this.reactiveAdapterRegistry = ReactiveAdapterRegistry.getSharedInstance();
+    }
+    else {
+      this.reactiveAdapterRegistry = null;
+    }
+  }
+
+  /**
+   * Create a new TransactionInterceptor.
+   * @param ptm the default transaction manager to perform the actual transaction management
+   * @param tas the attribute source to be used to find transaction attributes
+   * @since 5.2.5
+   * @see #setTransactionManager
+   * @see #setTransactionAttributeSource
+   */
+  public CouchbaseTransactionInterceptor(TransactionManager ptm, TransactionAttributeSource tas) {
+    this();
+    setTransactionManager(ptm);
+    setTransactionAttributeSource(tas);
+  }
+
+  /**
+   * Create a new TransactionInterceptor.
+   * @param ptm the default transaction manager to perform the actual transaction management
+   * @param tas the attribute source to be used to find transaction attributes
+   * @see #setTransactionManager
+   * @see #setTransactionAttributeSource
+   * @deprecated as of 5.2.5, in favor of
+   * {@link #CouchbaseTransactionInterceptor(TransactionManager, TransactionAttributeSource)}
+   */
+  @Deprecated
+  public CouchbaseTransactionInterceptor(PlatformTransactionManager ptm, TransactionAttributeSource tas) {
+    this();
+    setTransactionManager(ptm);
+    setTransactionAttributeSource(tas);
+  }
+
+  /**
+   * Create a new TransactionInterceptor.
+   * @param ptm the default transaction manager to perform the actual transaction management
+   * @param attributes the transaction attributes in properties format
+   * @see #setTransactionManager
+   * @see #setTransactionAttributes(java.util.Properties)
+   * @deprecated as of 5.2.5, in favor of {@link #setTransactionAttributes(Properties)}
+   */
+  @Deprecated
+  public CouchbaseTransactionInterceptor(PlatformTransactionManager ptm, Properties attributes) {
+    this();
+    setTransactionManager(ptm);
+    setTransactionAttributes(attributes);
+  }
+
+
+  @Override
+  @Nullable
+  public Object invoke(MethodInvocation invocation) throws Throwable {
+    // Work out the target class: may be {@code null}.
+    // The TransactionAttributeSource should be passed the target class
+    // as well as the method, which may be from an interface.
+    Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);
+
+    // Adapt to TransactionAspectSupport's invokeWithinTransaction...
+    return invokeWithinTransaction(invocation.getMethod(), targetClass, new CoroutinesInvocationCallback() {
+      @Override
+      @Nullable
+      public Object proceedWithInvocation() throws Throwable {
+        return invocation.proceed();
+      }
+      @Override
+      public Object getTarget() {
+        return invocation.getThis();
+      }
+      @Override
+      public Object[] getArguments() {
+        return invocation.getArguments();
+      }
+    });
+  }
+
+  /**
+   * General delegate for around-advice-based subclasses, delegating to several other template
+   * methods on this class. Able to handle {@link CallbackPreferringPlatformTransactionManager}
+   * as well as regular {@link PlatformTransactionManager} implementations and
+   * {@link ReactiveTransactionManager} implementations for reactive return types.
+   * @param method the Method being invoked
+   * @param targetClass the target class that we're invoking the method on
+   * @param invocation the callback to use for proceeding with the target invocation
+   * @return the return value of the method, if any
+   * @throws Throwable propagated from the target invocation
+   */
+  @Nullable
+  protected Object invokeWithinTransaction(Method method, @Nullable Class<?> targetClass,
+                                           final InvocationCallback invocation) throws Throwable {
+
+    // If the transaction attribute is null, the method is non-transactional.
+    TransactionAttributeSource tas = getTransactionAttributeSource();
+    final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null);
+    final TransactionManager tm = determineTransactionManager(txAttr);
+
+    if (this.reactiveAdapterRegistry != null && tm instanceof ReactiveTransactionManager) {
+        return super.invokeWithinTransaction(method, targetClass, invocation);
+    }
+
+    PlatformTransactionManager ptm = asPlatformTransactionManager(tm);
+    final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);
+
+    if (txAttr == null || !(ptm instanceof CallbackPreferringPlatformTransactionManager)) {
+      //return super.invokeWithinTransaction(method, targetClass, invocation);
+      // Standard transaction demarcation with getTransaction and commit/rollback calls.
+
+      Object retVal = null;
+      boolean success=false;
+      do {
+        TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);
+        try {
+          // This is an around advice: Invoke the next interceptor in the chain.
+          // This will normally result in a target object being invoked.
+          retVal = invocation.proceedWithInvocation();
+          success = true;
+        } catch (Throwable ex) {
+          // target invocation exception
+          completeTransactionAfterThrowing(txInfo,
+              ex);
+          //throw ex;
+        } finally {
+          cleanupTransactionInfo(txInfo);
+        }
+        if (retVal != null && vavrPresent && VavrDelegate.isVavrTry(retVal)) {
+          // Set rollback-only in case of Vavr failure matching our rollback rules...
+          TransactionStatus status = txInfo.getTransactionStatus();
+          if (status != null && txAttr != null) {
+            retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);
+          }
+        }
+
+        if( retVal != null) {
+          // this could go directly after succeed = true except for the cleanupTransactionInfo(txInfo) and the vavrPresent
+          commitTransactionAfterReturning(txInfo);
+        }
+      } while (!success);
+
+      return retVal;
+    }
+
+    else {
+
+      Object result;
+      final ThrowableHolder throwableHolder = new ThrowableHolder();
+
+      // It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.
+      try {
+        result = ((CallbackPreferringPlatformTransactionManager) ptm).execute(txAttr, status -> {
+          TransactionInfo txInfo = prepareTransactionInfo(ptm, txAttr, joinpointIdentification, status);
+          try {
+            Object retVal = invocation.proceedWithInvocation();
+            if (retVal != null && vavrPresent && VavrDelegate.isVavrTry(retVal)) {
+              // Set rollback-only in case of Vavr failure matching our rollback rules...
+              retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);
+            }
+            return retVal;
+          }
+          catch (Throwable ex) {
+            if (txAttr.rollbackOn(ex)) {
+              // A RuntimeException: will lead to a rollback.
+              if (ex instanceof RuntimeException) {
+                throw (RuntimeException) ex;
+              }
+              else {
+                throw new ThrowableHolderException(ex);
+              }
+            }
+            else {
+              // A normal return value: will lead to a commit.
+              throwableHolder.throwable = ex;
+              return null;
+            }
+          }
+          finally {
+            cleanupTransactionInfo(txInfo);
+          }
+        });
+      }
+      catch (ThrowableHolderException ex) {
+        throw ex.getCause();
+      }
+      catch (TransactionSystemException ex2) {
+        if (throwableHolder.throwable != null) {
+          logger.error("Application exception overridden by commit exception", throwableHolder.throwable);
+          ex2.initApplicationException(throwableHolder.throwable);
+        }
+        throw ex2;
+      }
+      catch (Throwable ex2) {
+        if (throwableHolder.throwable != null) {
+          logger.error("Application exception overridden by commit exception", throwableHolder.throwable);
+        }
+        throw ex2;
+      }
+
+      // Check result state: It might indicate a Throwable to rethrow.
+      if (throwableHolder.throwable != null) {
+        throw throwableHolder.throwable;
+      }
+      return result;
+    }
+  }
+
+  // from TransactionAspectSupport
+  @Nullable
+  private PlatformTransactionManager asPlatformTransactionManager(@Nullable Object transactionManager) {
+    if (transactionManager == null || transactionManager instanceof PlatformTransactionManager) {
+      return (PlatformTransactionManager) transactionManager;
+    }
+    else {
+      throw new IllegalStateException(
+          "Specified transaction manager is not a PlatformTransactionManager: " + transactionManager);
+    }
+  }
+
+  // from TransactionAspectSupport
+  private String methodIdentification(Method method, @Nullable Class<?> targetClass,
+                                      @Nullable TransactionAttribute txAttr) {
+
+    String methodIdentification = methodIdentification(method, targetClass);
+    if (methodIdentification == null) {
+      if (txAttr instanceof DefaultTransactionAttribute) {
+        methodIdentification = ((DefaultTransactionAttribute) txAttr).getDescriptor();
+      }
+      if (methodIdentification == null) {
+        methodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass);
+      }
+    }
+    return methodIdentification;
+  }
+
+  // from TransactionAspectSupport
+  /**
+   * Internal holder class for a Throwable, used as a RuntimeException to be
+   * thrown from a TransactionCallback (and subsequently unwrapped again).
+   */
+  @SuppressWarnings("serial")
+  private static class ThrowableHolderException extends RuntimeException {
+
+    public ThrowableHolderException(Throwable throwable) {
+      super(throwable);
+    }
+
+    @Override
+    public String toString() {
+      return getCause().toString();
+    }
+  }
+
+  // from TransactionAspectSupport
+  /**
+   * Internal holder class for a Throwable in a callback transaction model.
+   */
+  private static class ThrowableHolder {
+
+    @Nullable
+    public Throwable throwable;
+  }
+
+  // From TransactionAspectSupport
+  /**
+   * Inner class to avoid a hard dependency on the Vavr library at runtime.
+   */
+  private static class VavrDelegate {
+
+    public static boolean isVavrTry(Object retVal) {
+      return false; // (retVal instanceof Try);
+    }
+
+    public static Object evaluateTryFailure(Object retVal, TransactionAttribute txAttr, TransactionStatus status) {
+      throw new RuntimeException("no Vavr support");
+      /*
+      return ((Try<?>) retVal).onFailure(ex -> {
+        if (txAttr.rollbackOn(ex)) {
+          status.setRollbackOnly();
+        }
+      });
+       */
+    }
+  }
+
+  //---------------------------------------------------------------------
+  // Serialization support
+  //---------------------------------------------------------------------
+
+  private void writeObject(ObjectOutputStream oos) throws IOException {
+    // Rely on default serialization, although this class itself doesn't carry state anyway...
+    oos.defaultWriteObject();
+
+    // Deserialize superclass fields.
+    oos.writeObject(getTransactionManagerBeanName());
+    oos.writeObject(getTransactionManager());
+    oos.writeObject(getTransactionAttributeSource());
+    oos.writeObject(getBeanFactory());
+  }
+
+  private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
+    // Rely on default serialization, although this class itself doesn't carry state anyway...
+    ois.defaultReadObject();
+
+    // Serialize all relevant superclass fields.
+    // Superclass can't implement Serializable because it also serves as base class
+    // for AspectJ aspects (which are not allowed to implement Serializable)!
+    setTransactionManagerBeanName((String) ois.readObject());
+    setTransactionManager((PlatformTransactionManager) ois.readObject());
+    setTransactionAttributeSource((TransactionAttributeSource) ois.readObject());
+    setBeanFactory((BeanFactory) ois.readObject());
+  }
+
+}
diff --git a/src/main/resources/notice.txt b/src/main/resources/notice.txt
index f665ae09..0f339fe2 100644
--- a/src/main/resources/notice.txt
+++ b/src/main/resources/notice.txt
@@ -1,4 +1,4 @@
-Spring Data Couchbase 4.3 RC1 (2021.1.0)
+Spring Data Couchbase 4.4 M3 (2021.2.0)
 Copyright (c) [2013-2019] Couchbase / Pivotal Software, Inc.
 
 This product is licensed to you under the Apache License, Version 2.0 (the "License").
@@ -26,6 +26,10 @@ conditions of the subcomponent's license, as noted in the LICENSE file.
 
 
 
+
+
+
+
 
 
 
diff --git a/src/test/java/org/springframework/data/couchbase/cache/CacheUser.java b/src/test/java/org/springframework/data/couchbase/cache/CacheUser.java
new file mode 100644
index 00000000..3bcad08d
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/cache/CacheUser.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2022 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.couchbase.cache;
+
+import java.io.Serializable;
+
+/**
+ * This is a standalone class (vs. inner) to allow Serialization of all fields to work.
+ * If it was an inner class of CouchbaseCacheIntegrationTests, then it would have a
+ * this$0 field = CouchbaseCacheIntegrationTests and would not serialize.
+ *
+ * @author Michael Reiche
+ */
+class CacheUser implements Serializable {
+	// private static final long serialVersionUID = 8817717605659870262L;
+	String firstname;
+	String lastname;
+	String id;
+
+	public CacheUser(String id, String firstname, String lastname) {
+		this.id = id;
+		this.firstname = firstname;
+		this.lastname = lastname;
+	}
+
+	public String getId() {
+		return id;
+	}
+
+	// define equals for assertEquals()
+	public boolean equals(Object o) {
+		if (o == null) {
+			return false;
+		}
+		if (!(o instanceof CacheUser)) {
+			return false;
+		}
+
+		CacheUser other = (CacheUser) o;
+		if (id == null && other.id != null) {
+			return false;
+		}
+		if (firstname == null && other.firstname != null) {
+			return false;
+		}
+		if (lastname == null && other.lastname != null) {
+			return false;
+		}
+		return id.equals(other.id) && firstname.equals(other.firstname) && lastname.equals(other.lastname);
+	}
+
+	public String toString() {
+		StringBuffer sb = new StringBuffer();
+		sb.append("CacheUser: { id=" + id + ", firstname=" + firstname + ", lastname=" + lastname + "}");
+		return sb.toString();
+	}
+
+}
diff --git a/src/test/java/org/springframework/data/couchbase/cache/CouchbaseCacheCollectionIntegrationTests.java b/src/test/java/org/springframework/data/couchbase/cache/CouchbaseCacheCollectionIntegrationTests.java
new file mode 100644
index 00000000..a82c532f
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/cache/CouchbaseCacheCollectionIntegrationTests.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright 2022 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.data.couchbase.cache;
+
+import com.couchbase.client.java.query.QueryOptions;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.data.couchbase.core.CouchbaseTemplate;
+import org.springframework.data.couchbase.util.Capabilities;
+import org.springframework.data.couchbase.util.ClusterType;
+import org.springframework.data.couchbase.util.CollectionAwareIntegrationTests;
+import org.springframework.data.couchbase.util.IgnoreWhen;
+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
+
+import java.util.UUID;
+
+import static com.couchbase.client.java.query.QueryScanConsistency.REQUEST_PLUS;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNull;
+
+/**
+ * CouchbaseCache tests Theses tests rely on a cb server running.
+ *
+ * @author Michael Reiche
+ */
+@IgnoreWhen(clusterTypes = ClusterType.MOCKED, missesCapabilities = { Capabilities.COLLECTIONS })
+class CouchbaseCacheCollectionIntegrationTests extends CollectionAwareIntegrationTests {
+
+	volatile CouchbaseCache cache;
+
+	@BeforeEach
+	@Override
+	public void beforeEach() {
+		super.beforeEach();
+		cache = CouchbaseCacheManager.create(couchbaseTemplate.getCouchbaseClientFactory()).createCouchbaseCache("myCache",
+				CouchbaseCacheConfiguration.defaultCacheConfig().collection("my_collection"));
+		clear(cache);
+	}
+
+	private void clear(CouchbaseCache c) {
+		couchbaseTemplate.getCouchbaseClientFactory().getCluster().query("SELECT count(*) from `" + bucketName() + "`",
+				QueryOptions.queryOptions().scanConsistency(REQUEST_PLUS));
+		c.clear();
+		couchbaseTemplate.getCouchbaseClientFactory().getCluster().query("SELECT count(*) from `" + bucketName() + "`",
+				QueryOptions.queryOptions().scanConsistency(REQUEST_PLUS));
+	}
+
+	@Test
+	void cachePutGet() {
+		CacheUser user1 = new CacheUser(UUID.randomUUID().toString(), "first1", "last1");
+		CacheUser user2 = new CacheUser(UUID.randomUUID().toString(), "first2", "last2");
+		assertNull(cache.get(user1.getId())); // was not put -> cacheMiss
+		cache.put(user1.getId(), user1); // put user1
+		cache.put(user2.getId(), user2); // put user2
+		assertEquals(user1, cache.get(user1.getId()).get()); // get user1
+		assertEquals(user2, cache.get(user2.getId()).get()); // get user2
+	}
+
+	@Test
+	void cacheEvict() {
+		CacheUser user1 = new CacheUser(UUID.randomUUID().toString(), "first1", "last1");
+		CacheUser user2 = new CacheUser(UUID.randomUUID().toString(), "first2", "last2");
+		cache.put(user1.getId(), user1); // put user1
+		cache.put(user2.getId(), user2); // put user2
+		cache.evict(user1.getId()); // evict user1
+		assertEquals(user2, cache.get(user2.getId()).get()); // get user2 -> present
+	}
+
+	@Test
+	void cacheHitMiss() {
+		CacheUser user1 = new CacheUser(UUID.randomUUID().toString(), "first1", "last1");
+		CacheUser user2 = new CacheUser(UUID.randomUUID().toString(), "first2", "last2");
+		assertNull(cache.get(user2.getId())); // get user2 -> cacheMiss
+		cache.put(user1.getId(), null); // cache a null
+		assertNotNull(cache.get(user1.getId())); // cacheHit null
+		assertNull(cache.get(user1.getId()).get()); // fetch cached null
+	}
+
+	@Test
+	void cachePutIfAbsent() {
+		CacheUser user1 = new CacheUser(UUID.randomUUID().toString(), "first1", "last1");
+		CacheUser user2 = new CacheUser(UUID.randomUUID().toString(), "first2", "last2");
+		assertNull(cache.putIfAbsent(user1.getId(), user1)); // should put user1, return null
+		assertEquals(user1, cache.putIfAbsent(user1.getId(), user2).get()); // should not put user2, should return user1
+		assertEquals(user1, cache.get(user1.getId()).get()); // user1.getId() is still user1
+	}
+
+}
diff --git a/src/test/java/org/springframework/data/couchbase/cache/CouchbaseCacheIntegrationTests.java b/src/test/java/org/springframework/data/couchbase/cache/CouchbaseCacheIntegrationTests.java
new file mode 100644
index 00000000..648ef2a1
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/cache/CouchbaseCacheIntegrationTests.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright 2022 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.data.couchbase.cache;
+
+import static com.couchbase.client.java.query.QueryScanConsistency.REQUEST_PLUS;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNull;
+
+import java.util.List;
+import java.util.UUID;
+
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.data.couchbase.domain.Config;
+import org.springframework.data.couchbase.domain.User;
+import org.springframework.data.couchbase.domain.UserRepository;
+import org.springframework.data.couchbase.util.ClusterType;
+import org.springframework.data.couchbase.util.IgnoreWhen;
+import org.springframework.data.couchbase.util.JavaIntegrationTests;
+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
+
+import com.couchbase.client.java.query.QueryOptions;
+
+/**
+ * CouchbaseCache tests Theses tests rely on a cb server running.
+ *
+ * @author Michael Reiche
+ */
+@IgnoreWhen(clusterTypes = ClusterType.MOCKED)
+@SpringJUnitConfig(Config.class)
+class CouchbaseCacheIntegrationTests extends JavaIntegrationTests {
+
+	volatile CouchbaseCache cache;
+	@Autowired CouchbaseCacheManager cacheManager; // autowired not working
+	@Autowired UserRepository userRepository; // autowired not working
+
+	@BeforeEach
+	@Override
+	public void beforeEach() {
+		super.beforeEach();
+		cache = CouchbaseCacheManager.create(couchbaseTemplate.getCouchbaseClientFactory()).createCouchbaseCache("myCache",
+				CouchbaseCacheConfiguration.defaultCacheConfig());
+		clear(cache);
+		// ApplicationContext ac = new AnnotationConfigApplicationContext(Config.class);
+		// cacheManager = ac.getBean(CouchbaseCacheManager.class);
+		// userRepository = ac.getBean(UserRepository.class);
+	}
+
+	@AfterEach
+	@Override
+	public void afterEach() {
+		clear(cache);
+		super.afterEach();
+	}
+
+	private void clear(CouchbaseCache c) {
+		couchbaseTemplate.getCouchbaseClientFactory().getCluster().query("SELECT count(*) from `" + bucketName() + "`",
+				QueryOptions.queryOptions().scanConsistency(REQUEST_PLUS));
+		c.clear();
+		couchbaseTemplate.getCouchbaseClientFactory().getCluster().query("SELECT count(*) from `" + bucketName() + "`",
+				QueryOptions.queryOptions().scanConsistency(REQUEST_PLUS));
+	}
+
+	@Test
+	void cachePutGet() {
+		CacheUser user1 = new CacheUser(UUID.randomUUID().toString(), "first1", "last1");
+		CacheUser user2 = new CacheUser(UUID.randomUUID().toString(), "first2", "last2");
+		assertNull(cache.get(user1.getId())); // was not put -> cacheMiss
+		cache.put(user1.getId(), user1); // put user1
+		cache.put(user2.getId(), user2); // put user2
+		assertEquals(user1, cache.get(user1.getId()).get()); // get user1
+		assertEquals(user2, cache.get(user2.getId()).get()); // get user2
+	}
+
+	@Test
+	void cacheable() {
+		User user = new User("cache_92", "Dave", "Wilson");
+		cacheManager.getCache("mySpringCache").clear();
+		userRepository.save(user);
+		long t0 = System.currentTimeMillis();
+		List<User> users = userRepository.getByFirstname(user.getFirstname());
+		assert (System.currentTimeMillis() - t0 > 1000 * 5);
+		t0 = System.currentTimeMillis();
+		users = userRepository.getByFirstname(user.getFirstname());
+		assert (System.currentTimeMillis() - t0 < 100);
+	}
+
+	@Test
+	void cacheEvict() {
+		CacheUser user1 = new CacheUser(UUID.randomUUID().toString(), "first1", "last1");
+		CacheUser user2 = new CacheUser(UUID.randomUUID().toString(), "first2", "last2");
+		cache.put(user1.getId(), user1); // put user1
+		cache.put(user2.getId(), user2); // put user2
+		cache.evict(user1.getId()); // evict user1
+		assertEquals(user2, cache.get(user2.getId()).get()); // get user2 -> present
+	}
+
+	@Test
+	void cacheHitMiss() {
+		CacheUser user1 = new CacheUser(UUID.randomUUID().toString(), "first1", "last1");
+		CacheUser user2 = new CacheUser(UUID.randomUUID().toString(), "first2", "last2");
+		assertNull(cache.get(user2.getId())); // get user2 -> cacheMiss
+		cache.put(user1.getId(), null); // cache a null
+		assertNotNull(cache.get(user1.getId())); // cacheHit null
+		assertNull(cache.get(user1.getId()).get()); // fetch cached null
+	}
+
+	@Test
+	void cachePutIfAbsent() {
+		CacheUser user1 = new CacheUser(UUID.randomUUID().toString(), "first1", "last1");
+		CacheUser user2 = new CacheUser(UUID.randomUUID().toString(), "first2", "last2");
+		assertNull(cache.putIfAbsent(user1.getId(), user1)); // should put user1, return null
+		assertEquals(user1, cache.putIfAbsent(user1.getId(), user2).get()); // should not put user2, should return user1
+		assertEquals(user1, cache.get(user1.getId()).get()); // user1.getId() is still user1
+	}
+
+	@Test // this test FAILS (local empty (i.e. fast) Couchbase installation)
+	public void clearFail() {
+		cache.put("KEY", "VALUE"); // no delay between put and clear, entry will not be
+		cache.clear(); // will not be indexed when clear() executes
+		assertNotNull(cache.get("KEY")); // will still find entry, clear failed to delete
+	}
+
+	@Test // this WORKS
+	public void clearWithDelayOk() throws InterruptedException {
+		cache.put("KEY", "VALUE");
+		Thread.sleep(50); // give main index time to update
+		cache.clear();
+		assertNull(cache.get("KEY"));
+	}
+
+	@Test
+	public void noOpt() {}
+
+}
diff --git a/src/test/java/org/springframework/data/couchbase/core/CouchbaseTemplateKeyValueIntegrationTests.java b/src/test/java/org/springframework/data/couchbase/core/CouchbaseTemplateKeyValueIntegrationTests.java
index 66bf472a..1adcd7ff 100644
--- a/src/test/java/org/springframework/data/couchbase/core/CouchbaseTemplateKeyValueIntegrationTests.java
+++ b/src/test/java/org/springframework/data/couchbase/core/CouchbaseTemplateKeyValueIntegrationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -27,7 +27,6 @@ import static org.junit.jupiter.api.Assertions.assertTrue;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.time.Duration;
-import java.time.Instant;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.HashSet;
@@ -36,10 +35,13 @@ import java.util.List;
 import java.util.Set;
 import java.util.UUID;
 
+import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.dao.DataIntegrityViolationException;
 import org.springframework.dao.DuplicateKeyException;
+import org.springframework.dao.OptimisticLockingFailureException;
 import org.springframework.data.couchbase.core.ExecutableFindByIdOperation.ExecutableFindById;
 import org.springframework.data.couchbase.core.ExecutableRemoveByIdOperation.ExecutableRemoveById;
 import org.springframework.data.couchbase.core.ExecutableReplaceByIdOperation.ExecutableReplaceById;
@@ -48,6 +50,7 @@ import org.springframework.data.couchbase.core.support.OneAndAllId;
 import org.springframework.data.couchbase.core.support.WithDurability;
 import org.springframework.data.couchbase.core.support.WithExpiry;
 import org.springframework.data.couchbase.domain.Address;
+import org.springframework.data.couchbase.domain.Config;
 import org.springframework.data.couchbase.domain.NaiveAuditorAware;
 import org.springframework.data.couchbase.domain.PersonValue;
 import org.springframework.data.couchbase.domain.Submission;
@@ -56,6 +59,7 @@ import org.springframework.data.couchbase.domain.UserAnnotated;
 import org.springframework.data.couchbase.domain.UserAnnotated2;
 import org.springframework.data.couchbase.domain.UserAnnotated3;
 import org.springframework.data.couchbase.domain.UserSubmission;
+import org.springframework.data.couchbase.transactions.CouchbaseReactiveTransactionNativeTests;
 import org.springframework.data.couchbase.util.ClusterType;
 import org.springframework.data.couchbase.util.IgnoreWhen;
 import org.springframework.data.couchbase.util.JavaIntegrationTests;
@@ -65,6 +69,7 @@ import com.couchbase.client.java.kv.PersistTo;
 import com.couchbase.client.java.kv.ReplicateTo;
 import com.couchbase.client.java.query.QueryOptions;
 import com.couchbase.client.java.query.QueryScanConsistency;
+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
 
 ;
 
@@ -75,12 +80,15 @@ import com.couchbase.client.java.query.QueryScanConsistency;
  * @author Michael Reiche
  */
 @IgnoreWhen(clusterTypes = ClusterType.MOCKED)
+@SpringJUnitConfig(Config.class)
 class CouchbaseTemplateKeyValueIntegrationTests extends JavaIntegrationTests {
 
+	@Autowired public CouchbaseTemplate couchbaseTemplate;
+	@Autowired public ReactiveCouchbaseTemplate reactiveCouchbaseTemplate;
+
 	@BeforeEach
 	@Override
 	public void beforeEach() {
-		super.beforeEach();
 		couchbaseTemplate.removeByQuery(User.class).all();
 		couchbaseTemplate.removeByQuery(UserAnnotated.class).all();
 		couchbaseTemplate.removeByQuery(UserAnnotated2.class).all();
@@ -138,7 +146,7 @@ class CouchbaseTemplateKeyValueIntegrationTests extends JavaIntegrationTests {
 
 		User badUser = new User(user.getId(), user.getFirstname(), user.getLastname());
 		badUser.setVersion(12345678);
-		assertThrows(DataIntegrityViolationException.class, () -> couchbaseTemplate.replaceById(User.class).one(badUser));
+		assertThrows(OptimisticLockingFailureException.class, () -> couchbaseTemplate.replaceById(User.class).one(badUser));
 
 		User found = couchbaseTemplate.findById(User.class).one(user.getId());
 		assertEquals(modified, found);
@@ -296,6 +304,9 @@ class CouchbaseTemplateKeyValueIntegrationTests extends JavaIntegrationTests {
 					errorList.add("\nfound should have been null as document should be expired " + user.getId());
 				}
 			}
+			if (found != null) {
+				couchbaseTemplate.removeById(user.getClass()).one(user.getId());
+			}
 		}
 
 		if (!errorList.isEmpty()) {
@@ -310,7 +321,7 @@ class CouchbaseTemplateKeyValueIntegrationTests extends JavaIntegrationTests {
 
 	@Test
 	void upsertAndReplaceById() {
-		User user = new User(UUID.randomUUID().toString(), "firstname", "lastname");
+		User user = new User(UUID.randomUUID().toString(), "firstname_upsertAndReplaceById", "lastname");
 		User modified = couchbaseTemplate.upsertById(User.class).one(user);
 		assertEquals(user, modified);
 
@@ -335,7 +346,6 @@ class CouchbaseTemplateKeyValueIntegrationTests extends JavaIntegrationTests {
 			assertEquals(user.getId(), removeResult.getId());
 			assertTrue(removeResult.getCas() != 0);
 			assertTrue(removeResult.getMutationToken().isPresent());
-
 			assertNull(couchbaseTemplate.findById(User.class).one(user.getId()));
 		}
 		{
@@ -346,7 +356,7 @@ class CouchbaseTemplateKeyValueIntegrationTests extends JavaIntegrationTests {
 			// careful now - user and modified are the same object. The object has the new cas (@Version version)
 			Long savedCas = modified.getVersion();
 			modified.setVersion(123);
-			assertThrows(DataIntegrityViolationException.class, () -> couchbaseTemplate.removeById()
+			assertThrows(OptimisticLockingFailureException.class, () -> couchbaseTemplate.removeById()
 					.withCas(reactiveCouchbaseTemplate.support().getCas(modified)).one(modified.getId()));
 			modified.setVersion(savedCas);
 			couchbaseTemplate.removeById().withCas(reactiveCouchbaseTemplate.support().getCas(modified))
@@ -360,6 +370,7 @@ class CouchbaseTemplateKeyValueIntegrationTests extends JavaIntegrationTests {
 		User inserted = couchbaseTemplate.insertById(User.class).one(user);
 		assertEquals(user, inserted);
 		assertThrows(DuplicateKeyException.class, () -> couchbaseTemplate.insertById(User.class).one(user));
+		couchbaseTemplate.removeById(User.class).one(user.getId());
 	}
 
 	@Test
@@ -384,6 +395,7 @@ class CouchbaseTemplateKeyValueIntegrationTests extends JavaIntegrationTests {
 		}
 		assertEquals(user, inserted);
 		assertThrows(DuplicateKeyException.class, () -> couchbaseTemplate.insertById(User.class).one(user));
+		couchbaseTemplate.removeById(User.class).one(user.getId());
 	}
 
 	@Test
@@ -395,12 +407,13 @@ class CouchbaseTemplateKeyValueIntegrationTests extends JavaIntegrationTests {
 		User inserted = couchbaseTemplate.insertById(User.class).one(user);
 		assertEquals(user, inserted);
 		assertTrue(couchbaseTemplate.existsById().one(id));
+		couchbaseTemplate.removeById(User.class).one(user.getId());
 	}
 
 	@Test
 	@IgnoreWhen(clusterTypes = ClusterType.MOCKED)
 	void saveAndFindImmutableById() {
-		PersonValue personValue = new PersonValue(UUID.randomUUID().toString(), 123, "f", "l");
+		PersonValue personValue = new PersonValue(UUID.randomUUID().toString(), 123, "408", "l");
 		PersonValue inserted = null;
 		PersonValue upserted = null;
 		PersonValue replaced = null;
@@ -431,7 +444,7 @@ class CouchbaseTemplateKeyValueIntegrationTests extends JavaIntegrationTests {
 		PersonValue foundReplaced = couchbaseTemplate.findById(PersonValue.class).one(replaced.getId());
 		assertNotNull(foundReplaced, "replaced personValue not found");
 		assertEquals(replaced, foundReplaced);
-
+		couchbaseTemplate.removeById(PersonValue.class).one(replaced.getId());
 	}
 
 	private void sleepSecs(int i) {
diff --git a/src/test/java/org/springframework/data/couchbase/core/CouchbaseTemplateQueryCollectionIntegrationTests.java b/src/test/java/org/springframework/data/couchbase/core/CouchbaseTemplateQueryCollectionIntegrationTests.java
index c84e09ea..d8ffd4e5 100644
--- a/src/test/java/org/springframework/data/couchbase/core/CouchbaseTemplateQueryCollectionIntegrationTests.java
+++ b/src/test/java/org/springframework/data/couchbase/core/CouchbaseTemplateQueryCollectionIntegrationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2021 the original author or authors
+ * Copyright 2021-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,6 +16,7 @@
 
 package org.springframework.data.couchbase.core;
 
+import static com.couchbase.client.java.query.QueryScanConsistency.REQUEST_PLUS;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertNull;
@@ -36,11 +37,13 @@ import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
+import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.dao.DataRetrievalFailureException;
 import org.springframework.data.couchbase.core.query.Query;
 import org.springframework.data.couchbase.core.query.QueryCriteria;
 import org.springframework.data.couchbase.domain.Address;
 import org.springframework.data.couchbase.domain.Airport;
+import org.springframework.data.couchbase.domain.CollectionsConfig;
 import org.springframework.data.couchbase.domain.Course;
 import org.springframework.data.couchbase.domain.NaiveAuditorAware;
 import org.springframework.data.couchbase.domain.Submission;
@@ -54,10 +57,12 @@ import org.springframework.data.couchbase.util.Capabilities;
 import org.springframework.data.couchbase.util.ClusterType;
 import org.springframework.data.couchbase.util.CollectionAwareIntegrationTests;
 import org.springframework.data.couchbase.util.IgnoreWhen;
+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
 
 import com.couchbase.client.core.error.AmbiguousTimeoutException;
 import com.couchbase.client.core.error.UnambiguousTimeoutException;
 import com.couchbase.client.core.io.CollectionIdentifier;
+import com.couchbase.client.core.msg.kv.DurabilityLevel;
 import com.couchbase.client.java.analytics.AnalyticsOptions;
 import com.couchbase.client.java.kv.ExistsOptions;
 import com.couchbase.client.java.kv.GetAnyReplicaOptions;
@@ -67,7 +72,6 @@ import com.couchbase.client.java.kv.RemoveOptions;
 import com.couchbase.client.java.kv.ReplaceOptions;
 import com.couchbase.client.java.kv.UpsertOptions;
 import com.couchbase.client.java.query.QueryOptions;
-import com.couchbase.client.java.query.QueryScanConsistency;
 
 /**
  * Query tests Theses tests rely on a cb server running This class tests collection support with
@@ -77,8 +81,12 @@ import com.couchbase.client.java.query.QueryScanConsistency;
  * @author Michael Reiche
  */
 @IgnoreWhen(missesCapabilities = { Capabilities.QUERY, Capabilities.COLLECTIONS }, clusterTypes = ClusterType.MOCKED)
+@SpringJUnitConfig(CollectionsConfig.class)
 class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIntegrationTests {
 
+	@Autowired public CouchbaseTemplate couchbaseTemplate;
+	@Autowired public ReactiveCouchbaseTemplate reactiveCouchbaseTemplate;
+
 	Airport vie = new Airport("airports::vie", "vie", "loww");
 
 	@BeforeAll
@@ -103,15 +111,16 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 		// first call the super method
 		super.beforeEach();
 		// then do processing for this class
-		couchbaseTemplate.removeByQuery(User.class).inCollection(collectionName).all();
-		couchbaseTemplate.findByQuery(User.class).withConsistency(QueryScanConsistency.REQUEST_PLUS)
-				.inCollection(collectionName).all();
-		couchbaseTemplate.removeByQuery(Airport.class).inScope(scopeName).inCollection(collectionName).all();
-		couchbaseTemplate.findByQuery(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).inScope(scopeName)
-				.inCollection(collectionName).all();
-		couchbaseTemplate.removeByQuery(Airport.class).inScope(otherScope).inCollection(otherCollection).all();
-		couchbaseTemplate.findByQuery(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).inScope(otherScope)
-				.inCollection(otherCollection).all();
+		couchbaseTemplate.removeByQuery(User.class).inCollection(collectionName).withConsistency(REQUEST_PLUS).all();
+		couchbaseTemplate.findByQuery(User.class).inCollection(collectionName).withConsistency(REQUEST_PLUS).all();
+		couchbaseTemplate.removeByQuery(Airport.class).inScope(scopeName).inCollection(collectionName)
+				.withConsistency(REQUEST_PLUS).all();
+		couchbaseTemplate.findByQuery(Airport.class).inScope(scopeName).inCollection(collectionName)
+				.withConsistency(REQUEST_PLUS).all();
+		couchbaseTemplate.removeByQuery(Airport.class).inScope(otherScope).inCollection(otherCollection)
+				.withConsistency(REQUEST_PLUS).all();
+		couchbaseTemplate.findByQuery(Airport.class).inScope(otherScope).inCollection(otherCollection)
+				.withConsistency(REQUEST_PLUS).all();
 	}
 
 	@AfterEach
@@ -120,8 +129,7 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 		// first do processing for this class
 		couchbaseTemplate.removeByQuery(User.class).inCollection(collectionName).all();
 		// query with REQUEST_PLUS to ensure that the remove has completed.
-		couchbaseTemplate.findByQuery(User.class).withConsistency(QueryScanConsistency.REQUEST_PLUS)
-				.inCollection(collectionName).all();
+		couchbaseTemplate.findByQuery(User.class).inCollection(collectionName).withConsistency(REQUEST_PLUS).all();
 		// then call the super method
 		super.afterEach();
 	}
@@ -134,8 +142,8 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 
 			couchbaseTemplate.upsertById(User.class).inCollection(collectionName).all(Arrays.asList(user1, user2));
 
-			final List<User> foundUsers = couchbaseTemplate.findByQuery(User.class)
-					.withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName).all();
+			final List<User> foundUsers = couchbaseTemplate.findByQuery(User.class).inCollection(collectionName)
+					.withConsistency(REQUEST_PLUS).all();
 
 			for (User u : foundUsers) {
 				if (!(u.equals(user1) || u.equals(user2))) {
@@ -177,8 +185,8 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 		couchbaseTemplate.upsertById(User.class).inCollection(collectionName).all(Arrays.asList(user1, user2, specialUser));
 
 		Query specialUsers = new Query(QueryCriteria.where("firstname").like("special"));
-		final List<User> foundUsers = couchbaseTemplate.findByQuery(User.class)
-				.withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName).matching(specialUsers).all();
+		final List<User> foundUsers = couchbaseTemplate.findByQuery(User.class).inCollection(collectionName)
+				.matching(specialUsers).withConsistency(REQUEST_PLUS).all();
 
 		assertEquals(1, foundUsers.size());
 	}
@@ -202,8 +210,8 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 		Query daveUsers = new Query(QueryCriteria.where("username").like("dave"));
 
 		final List<UserSubmissionProjected> foundUserSubmissions = couchbaseTemplate.findByQuery(UserSubmission.class)
-				.as(UserSubmissionProjected.class).withConsistency(QueryScanConsistency.REQUEST_PLUS)
-				.inCollection(collectionName).matching(daveUsers).all();
+				.inCollection(collectionName).as(UserSubmissionProjected.class).matching(daveUsers)
+				.withConsistency(REQUEST_PLUS).all();
 		assertEquals(1, foundUserSubmissions.size());
 		assertEquals(user.getUsername(), foundUserSubmissions.get(0).getUsername());
 		assertEquals(user.getId(), foundUserSubmissions.get(0).getId());
@@ -219,17 +227,17 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 		couchbaseTemplate.upsertById(User.class).inCollection(collectionName).all(Arrays.asList(user1, user2, specialUser));
 
 		Query specialUsers = new Query(QueryCriteria.where("firstname").like("special"));
-		final List<UserJustLastName> foundUsers = couchbaseTemplate.findByQuery(User.class).as(UserJustLastName.class)
-				.withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName).matching(specialUsers).all();
+		final List<UserJustLastName> foundUsers = couchbaseTemplate.findByQuery(User.class).inCollection(collectionName)
+				.as(UserJustLastName.class).matching(specialUsers).withConsistency(REQUEST_PLUS).all();
 		assertEquals(1, foundUsers.size());
 
 		final List<UserJustLastName> foundUsersReactive = reactiveCouchbaseTemplate.findByQuery(User.class)
-				.as(UserJustLastName.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName)
-				.matching(specialUsers).all().collectList().block();
+				.inCollection(collectionName).as(UserJustLastName.class).matching(specialUsers).withConsistency(REQUEST_PLUS)
+				.all().collectList().block();
 		assertEquals(1, foundUsersReactive.size());
 
-		couchbaseTemplate.removeByQuery(UserSubmission.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).all();
-		couchbaseTemplate.removeByQuery(UserSubmission.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).all();
+		couchbaseTemplate.removeByQuery(UserSubmission.class).withConsistency(REQUEST_PLUS).all();
+		couchbaseTemplate.removeByQuery(UserSubmission.class).withConsistency(REQUEST_PLUS).all();
 
 	}
 
@@ -244,8 +252,8 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 		assertTrue(couchbaseTemplate.existsById().inScope(scopeName).inCollection(collectionName).one(user1.getId()));
 		assertTrue(couchbaseTemplate.existsById().inScope(scopeName).inCollection(collectionName).one(user2.getId()));
 
-		List<RemoveResult> result = couchbaseTemplate.removeByQuery(User.class)
-				.withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName).all();
+		List<RemoveResult> result = couchbaseTemplate.removeByQuery(User.class).inCollection(collectionName)
+				.withConsistency(REQUEST_PLUS).all();
 		assertEquals(2, result.size(), "should have deleted user1 and user2");
 
 		assertNull(
@@ -269,8 +277,8 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 
 		Query nonSpecialUsers = new Query(QueryCriteria.where("firstname").notLike("special"));
 
-		couchbaseTemplate.removeByQuery(User.class).withConsistency(QueryScanConsistency.REQUEST_PLUS)
-				.inCollection(collectionName).matching(nonSpecialUsers).all();
+		couchbaseTemplate.removeByQuery(User.class).inCollection(collectionName).matching(nonSpecialUsers)
+				.withConsistency(REQUEST_PLUS).all();
 
 		assertNull(couchbaseTemplate.findById(User.class).inCollection(collectionName).one(user1.getId()));
 		assertNull(couchbaseTemplate.findById(User.class).inCollection(collectionName).one(user2.getId()));
@@ -293,18 +301,18 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 			// as the fluent api for Distinct is tricky
 
 			// distinct icao
-			List<Airport> airports1 = couchbaseTemplate.findByQuery(Airport.class).distinct(new String[] { "icao" })
-					.as(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName).all();
+			List<Airport> airports1 = couchbaseTemplate.findByQuery(Airport.class).inCollection(collectionName)
+					.distinct(new String[] { "icao" }).as(Airport.class).withConsistency(REQUEST_PLUS).all();
 			assertEquals(2, airports1.size());
 
 			// distinct all-fields-in-Airport.class
-			List<Airport> airports2 = couchbaseTemplate.findByQuery(Airport.class).distinct(new String[] {}).as(Airport.class)
-					.withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName).all();
+			List<Airport> airports2 = couchbaseTemplate.findByQuery(Airport.class).inCollection(collectionName)
+					.distinct(new String[] {}).as(Airport.class).withConsistency(REQUEST_PLUS).all();
 			assertEquals(7, airports2.size());
 
 			// count( distinct { iata, icao } )
-			long count1 = couchbaseTemplate.findByQuery(Airport.class).distinct(new String[] { "iata", "icao" })
-					.as(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName).count();
+			long count1 = couchbaseTemplate.findByQuery(Airport.class).inCollection(collectionName)
+					.distinct(new String[] { "iata", "icao" }).as(Airport.class).withConsistency(REQUEST_PLUS).count();
 			assertEquals(7, count1);
 
 			// count( distinct (all fields in icaoClass)
@@ -312,8 +320,8 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 				String iata;
 				String icao;
 			}).getClass();
-			long count2 = couchbaseTemplate.findByQuery(Airport.class).distinct(new String[] {}).as(icaoClass)
-					.withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName).count();
+			long count2 = couchbaseTemplate.findByQuery(Airport.class).inCollection(collectionName).distinct(new String[] {})
+					.as(icaoClass).withConsistency(REQUEST_PLUS).count();
 			assertEquals(7, count2);
 
 		} finally {
@@ -337,22 +345,20 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 			// as the fluent api for Distinct is tricky
 
 			// distinct icao
-			List<Airport> airports1 = reactiveCouchbaseTemplate.findByQuery(Airport.class).distinct(new String[] { "icao" })
-					.as(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName).all()
-					.collectList().block();
+			List<Airport> airports1 = reactiveCouchbaseTemplate.findByQuery(Airport.class).inCollection(collectionName)
+					.distinct(new String[] { "icao" }).as(Airport.class).withConsistency(REQUEST_PLUS).all().collectList()
+					.block();
 			assertEquals(2, airports1.size());
 
 			// distinct all-fields-in-Airport.class
-			List<Airport> airports2 = reactiveCouchbaseTemplate.findByQuery(Airport.class).distinct(new String[] {})
-					.as(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName).all()
-					.collectList().block();
+			List<Airport> airports2 = reactiveCouchbaseTemplate.findByQuery(Airport.class).inCollection(collectionName)
+					.distinct(new String[] {}).as(Airport.class).withConsistency(REQUEST_PLUS).all().collectList().block();
 			assertEquals(7, airports2.size());
 
 			// count( distinct icao )
 			// not currently possible to have multiple fields in COUNT(DISTINCT field1, field2, ... ) due to MB43475
-			Long count1 = reactiveCouchbaseTemplate.findByQuery(Airport.class).distinct(new String[] { "icao" })
-					.as(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName).count()
-					.block();
+			Long count1 = reactiveCouchbaseTemplate.findByQuery(Airport.class).inCollection(collectionName)
+					.distinct(new String[] { "icao" }).as(Airport.class).withConsistency(REQUEST_PLUS).count().block();
 			assertEquals(2, count1);
 
 			// count( distinct (all fields in icaoClass) // which only has one field
@@ -360,9 +366,9 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 			Class icaoClass = (new Object() {
 				String icao;
 			}).getClass();
-			long count2 = (long) reactiveCouchbaseTemplate.findByQuery(Airport.class).distinct(new String[] {}).as(icaoClass)
-					.withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName).count().block();
-			assertEquals(2, count2);
+			long count2 = (long) reactiveCouchbaseTemplate.findByQuery(Airport.class).inCollection(collectionName)
+					.distinct(new String[] {}).as(icaoClass).withConsistency(REQUEST_PLUS).count().block();
+			assertEquals(7, count2);
 
 		} finally {
 			reactiveCouchbaseTemplate.removeById().inCollection(collectionName)
@@ -389,7 +395,7 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 		GetOptions options = GetOptions.getOptions().timeout(Duration.ofSeconds(10));
 		ExistsOptions existsOptions = ExistsOptions.existsOptions().timeout(Duration.ofSeconds(10));
 		Airport saved = couchbaseTemplate.insertById(Airport.class).inScope(scopeName).inCollection(collectionName)
-				.one(vie);
+				.one(vie.withIcao("398"));
 		try {
 			Boolean exists = couchbaseTemplate.existsById().inScope(scopeName).inCollection(collectionName)
 					.withOptions(existsOptions).one(saved.getId());
@@ -404,7 +410,7 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 	public void findByAnalytics() { // 2
 		AnalyticsOptions options = AnalyticsOptions.analyticsOptions().timeout(Duration.ofSeconds(10));
 		Airport saved = couchbaseTemplate.insertById(Airport.class).inScope(scopeName).inCollection(collectionName)
-				.one(vie);
+				.one(vie.withIcao("413"));
 		try {
 			List<Airport> found = couchbaseTemplate.findByAnalytics(Airport.class).inScope(scopeName)
 					.inCollection(collectionName).withOptions(options).all();
@@ -418,7 +424,7 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 	public void findById() { // 3
 		GetOptions options = GetOptions.getOptions().timeout(Duration.ofSeconds(10));
 		Airport saved = couchbaseTemplate.insertById(Airport.class).inScope(scopeName).inCollection(collectionName)
-				.one(vie);
+				.one(vie.withIcao("427"));
 		try {
 			Airport found = couchbaseTemplate.findById(Airport.class).inScope(scopeName).inCollection(collectionName)
 					.withOptions(options).one(saved.getId());
@@ -432,11 +438,10 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 	public void findByQuery() { // 4
 		QueryOptions options = QueryOptions.queryOptions().timeout(Duration.ofSeconds(10));
 		Airport saved = couchbaseTemplate.insertById(Airport.class).inScope(scopeName).inCollection(collectionName)
-				.one(vie);
+				.one(vie.withIcao("441"));
 		try {
-			List<Airport> found = couchbaseTemplate.findByQuery(Airport.class)
-					.withConsistency(QueryScanConsistency.REQUEST_PLUS).inScope(scopeName).inCollection(collectionName)
-					.withOptions(options).all();
+			List<Airport> found = couchbaseTemplate.findByQuery(Airport.class).inScope(scopeName).inCollection(collectionName)
+					.withConsistency(REQUEST_PLUS).withOptions(options).all();
 			assertEquals(saved.getId(), found.get(0).getId());
 		} finally {
 			couchbaseTemplate.removeById().inScope(scopeName).inCollection(collectionName).one(saved.getId());
@@ -447,7 +452,7 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 	public void findFromReplicasById() { // 5
 		GetAnyReplicaOptions options = GetAnyReplicaOptions.getAnyReplicaOptions().timeout(Duration.ofSeconds(10));
 		Airport saved = couchbaseTemplate.insertById(Airport.class).inScope(scopeName).inCollection(collectionName)
-				.one(vie);
+				.one(vie.withIcao("456"));
 		try {
 			Airport found = couchbaseTemplate.findFromReplicasById(Airport.class).inScope(scopeName)
 					.inCollection(collectionName).withOptions(options).any(saved.getId());
@@ -476,7 +481,7 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 	public void removeById() { // 7
 		RemoveOptions options = RemoveOptions.removeOptions().timeout(Duration.ofSeconds(10));
 		Airport saved = couchbaseTemplate.insertById(Airport.class).inScope(scopeName).inCollection(collectionName)
-				.one(vie);
+				.one(vie.withIcao("485"));
 		RemoveResult removeResult = couchbaseTemplate.removeById().inScope(scopeName).inCollection(collectionName)
 				.withOptions(options).one(saved.getId());
 		assertEquals(saved.getId(), removeResult.getId());
@@ -486,10 +491,10 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 	public void removeByQuery() { // 8
 		QueryOptions options = QueryOptions.queryOptions().timeout(Duration.ofSeconds(10));
 		Airport saved = couchbaseTemplate.insertById(Airport.class).inScope(scopeName).inCollection(collectionName)
-				.one(vie);
-		List<RemoveResult> removeResults = couchbaseTemplate.removeByQuery(Airport.class)
-				.withConsistency(QueryScanConsistency.REQUEST_PLUS).inScope(scopeName).inCollection(collectionName)
-				.withOptions(options).matching(Query.query(QueryCriteria.where("iata").is(vie.getIata()))).all();
+				.one(vie.withIcao("495"));
+		List<RemoveResult> removeResults = couchbaseTemplate.removeByQuery(Airport.class).inScope(scopeName)
+				.inCollection(collectionName).matching(Query.query(QueryCriteria.where("iata").is(vie.getIata())))
+				.withConsistency(REQUEST_PLUS).withOptions(options).all();
 		assertEquals(saved.getId(), removeResults.get(0).getId());
 	}
 
@@ -499,7 +504,7 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 		ReplaceOptions options = ReplaceOptions.replaceOptions().timeout(Duration.ofSeconds(10));
 		GetOptions getOptions = GetOptions.getOptions().timeout(Duration.ofSeconds(10));
 		Airport saved = couchbaseTemplate.insertById(Airport.class).inScope(scopeName).inCollection(collectionName)
-				.withOptions(insertOptions).one(vie);
+				.withOptions(insertOptions).one(vie.withIcao("508"));
 		Airport replaced = couchbaseTemplate.replaceById(Airport.class).inScope(scopeName).inCollection(collectionName)
 				.withOptions(options).one(vie.withIcao("newIcao"));
 		try {
@@ -517,7 +522,7 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 		GetOptions getOptions = GetOptions.getOptions().timeout(Duration.ofSeconds(10));
 
 		Airport saved = couchbaseTemplate.upsertById(Airport.class).inScope(scopeName).inCollection(collectionName)
-				.withOptions(options).one(vie);
+				.withOptions(options).one(vie.withIcao("526"));
 		try {
 			Airport found = couchbaseTemplate.findById(Airport.class).inScope(scopeName).inCollection(collectionName)
 					.withOptions(getOptions).one(saved.getId());
@@ -532,13 +537,14 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 		GetOptions options = GetOptions.getOptions().timeout(Duration.ofSeconds(10));
 		ExistsOptions existsOptions = ExistsOptions.existsOptions().timeout(Duration.ofSeconds(10));
 		Airport saved = couchbaseTemplate.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection)
-				.one(vie);
+				.one(vie.withIcao("lowg"));
+
 		try {
 			Boolean exists = couchbaseTemplate.existsById().inScope(otherScope).inCollection(otherCollection)
-					.withOptions(existsOptions).one(saved.getId());
-			assertTrue(exists, "Airport should exist: " + saved.getId());
+					.withOptions(existsOptions).one(vie.getId());
+			assertTrue(exists, "Airport should exist: " + vie.getId());
 		} finally {
-			couchbaseTemplate.removeById().inScope(otherScope).inCollection(otherCollection).one(saved.getId());
+			couchbaseTemplate.removeById().inScope(otherScope).inCollection(otherCollection).one(vie.getId());
 		}
 	}
 
@@ -547,7 +553,7 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 	public void findByAnalyticsOther() { // 2
 		AnalyticsOptions options = AnalyticsOptions.analyticsOptions().timeout(Duration.ofSeconds(10));
 		Airport saved = couchbaseTemplate.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection)
-				.one(vie);
+				.one(vie.withIcao("566"));
 		try {
 			List<Airport> found = couchbaseTemplate.findByAnalytics(Airport.class).inScope(otherScope)
 					.inCollection(otherCollection).withOptions(options).all();
@@ -561,7 +567,7 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 	public void findByIdOther() { // 3
 		GetOptions options = GetOptions.getOptions().timeout(Duration.ofSeconds(10));
 		Airport saved = couchbaseTemplate.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection)
-				.one(vie);
+				.one(vie.withIcao("580"));
 		try {
 			Airport found = couchbaseTemplate.findById(Airport.class).inScope(otherScope).inCollection(otherCollection)
 					.withOptions(options).one(saved.getId());
@@ -575,11 +581,10 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 	public void findByQueryOther() { // 4
 		QueryOptions options = QueryOptions.queryOptions().timeout(Duration.ofSeconds(10));
 		Airport saved = couchbaseTemplate.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection)
-				.one(vie);
+				.one(vie.withIcao("594"));
 		try {
-			List<Airport> found = couchbaseTemplate.findByQuery(Airport.class)
-					.withConsistency(QueryScanConsistency.REQUEST_PLUS).inScope(otherScope).inCollection(otherCollection)
-					.withOptions(options).all();
+			List<Airport> found = couchbaseTemplate.findByQuery(Airport.class).inScope(otherScope)
+					.inCollection(otherCollection).withConsistency(REQUEST_PLUS).withOptions(options).all();
 			assertEquals(saved.getId(), found.get(0).getId());
 		} finally {
 			couchbaseTemplate.removeById().inScope(otherScope).inCollection(otherCollection).one(saved.getId());
@@ -590,7 +595,7 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 	public void findFromReplicasByIdOther() { // 5
 		GetAnyReplicaOptions options = GetAnyReplicaOptions.getAnyReplicaOptions().timeout(Duration.ofSeconds(10));
 		Airport saved = couchbaseTemplate.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection)
-				.one(vie);
+				.one(vie.withIcao("609"));
 		try {
 			Airport found = couchbaseTemplate.findFromReplicasById(Airport.class).inScope(otherScope)
 					.inCollection(otherCollection).withOptions(options).any(saved.getId());
@@ -619,7 +624,7 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 	public void removeByIdOther() { // 7
 		RemoveOptions options = RemoveOptions.removeOptions().timeout(Duration.ofSeconds(10));
 		Airport saved = couchbaseTemplate.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection)
-				.one(vie);
+				.one(vie.withIcao("638"));
 		RemoveResult removeResult = couchbaseTemplate.removeById().inScope(otherScope).inCollection(otherCollection)
 				.withOptions(options).one(saved.getId());
 		assertEquals(saved.getId(), removeResult.getId());
@@ -629,10 +634,10 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 	public void removeByQueryOther() { // 8
 		QueryOptions options = QueryOptions.queryOptions().timeout(Duration.ofSeconds(10));
 		Airport saved = couchbaseTemplate.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection)
-				.one(vie);
-		List<RemoveResult> removeResults = couchbaseTemplate.removeByQuery(Airport.class)
-				.withConsistency(QueryScanConsistency.REQUEST_PLUS).inScope(otherScope).inCollection(otherCollection)
-				.withOptions(options).matching(Query.query(QueryCriteria.where("iata").is(vie.getIata()))).all();
+				.one(vie.withIcao("648"));
+		List<RemoveResult> removeResults = couchbaseTemplate.removeByQuery(Airport.class).inScope(otherScope)
+				.inCollection(otherCollection).matching(Query.query(QueryCriteria.where("iata").is(vie.getIata())))
+				.withConsistency(REQUEST_PLUS).withOptions(options).all();
 		assertEquals(saved.getId(), removeResults.get(0).getId());
 	}
 
@@ -642,7 +647,7 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 		ReplaceOptions options = ReplaceOptions.replaceOptions().timeout(Duration.ofSeconds(10));
 		GetOptions getOptions = GetOptions.getOptions().timeout(Duration.ofSeconds(10));
 		Airport saved = couchbaseTemplate.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection)
-				.withOptions(insertOptions).one(vie);
+				.withOptions(insertOptions).one(vie.withIcao("661"));
 		Airport replaced = couchbaseTemplate.replaceById(Airport.class).inScope(otherScope).inCollection(otherCollection)
 				.withOptions(options).one(vie.withIcao("newIcao"));
 		try {
@@ -660,7 +665,7 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 		GetOptions getOptions = GetOptions.getOptions().timeout(Duration.ofSeconds(10));
 
 		Airport saved = couchbaseTemplate.upsertById(Airport.class).inScope(otherScope).inCollection(otherCollection)
-				.withOptions(options).one(vie);
+				.withOptions(options).one(vie.withIcao("679"));
 		try {
 			Airport found = couchbaseTemplate.findById(Airport.class).inScope(otherScope).inCollection(otherCollection)
 					.withOptions(getOptions).one(saved.getId());
@@ -695,16 +700,15 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 	@Test
 	public void findByQueryOptions() { // 4
 		QueryOptions options = QueryOptions.queryOptions().timeout(Duration.ofNanos(10));
-		assertThrows(AmbiguousTimeoutException.class,
-				() -> couchbaseTemplate.findByQuery(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS)
-						.inScope(otherScope).inCollection(otherCollection).withOptions(options).all());
+		assertThrows(AmbiguousTimeoutException.class, () -> couchbaseTemplate.findByQuery(Airport.class).inScope(otherScope)
+				.inCollection(otherCollection).withConsistency(REQUEST_PLUS).withOptions(options).all());
 	}
 
 	@Test
 	public void findFromReplicasByIdOptions() { // 5
 		GetAnyReplicaOptions options = GetAnyReplicaOptions.getAnyReplicaOptions().timeout(Duration.ofNanos(1000));
 		Airport saved = couchbaseTemplate.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection)
-				.one(vie);
+				.one(vie.withIcao("723"));
 		try {
 			Airport found = couchbaseTemplate.findFromReplicasById(Airport.class).inScope(otherScope)
 					.inCollection(otherCollection).withOptions(options).any(saved.getId());
@@ -724,7 +728,7 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 	@Test
 	public void removeByIdOptions() { // 7 - options
 		Airport saved = couchbaseTemplate.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection)
-				.one(vie);
+				.one(vie.withIcao("743"));
 		RemoveOptions options = RemoveOptions.removeOptions().timeout(Duration.ofNanos(10));
 		assertThrows(AmbiguousTimeoutException.class, () -> couchbaseTemplate.removeById().inScope(otherScope)
 				.inCollection(otherCollection).withOptions(options).one(vie.getId()));
@@ -735,9 +739,9 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 	public void removeByQueryOptions() { // 8 - options
 		QueryOptions options = QueryOptions.queryOptions().timeout(Duration.ofNanos(10));
 		assertThrows(AmbiguousTimeoutException.class,
-				() -> couchbaseTemplate.removeByQuery(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS)
-						.inScope(otherScope).inCollection(otherCollection).withOptions(options)
-						.matching(Query.query(QueryCriteria.where("iata").is(vie.getIata()))).all());
+				() -> couchbaseTemplate.removeByQuery(Airport.class).inScope(otherScope).inCollection(otherCollection)
+						.matching(Query.query(QueryCriteria.where("iata").is(vie.getIata()))).withConsistency(REQUEST_PLUS)
+						.withOptions(options).all());
 	}
 
 	@Test
@@ -751,7 +755,7 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 	public void upsertByIdOptions() { // 10 - options
 		UpsertOptions options = UpsertOptions.upsertOptions().timeout(Duration.ofNanos(10));
 		assertThrows(AmbiguousTimeoutException.class, () -> couchbaseTemplate.upsertById(Airport.class).inScope(otherScope)
-				.inCollection(otherCollection).withOptions(options).one(vie));
+				.inCollection(otherCollection).withOptions(options).one(vie.withIcao("770")));
 	}
 
 	@Test
@@ -761,9 +765,8 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 		try {
 			UserCol saved = couchbaseTemplate.insertById(UserCol.class).inScope(scopeName).inCollection(collectionName)
 					.one(user);
-			List<UserCol> found = couchbaseTemplate.findByQuery(UserCol.class)
-					.withConsistency(QueryScanConsistency.REQUEST_PLUS).inScope(scopeName).inCollection(collectionName)
-					.matching(query).all();
+			List<UserCol> found = couchbaseTemplate.findByQuery(UserCol.class).inScope(scopeName).inCollection(collectionName)
+					.matching(query).withConsistency(REQUEST_PLUS).all();
 			assertEquals(saved, found.get(0), "should have found what was saved");
 			List<UserCol> notfound = couchbaseTemplate.findByQuery(UserCol.class).inScope(CollectionIdentifier.DEFAULT_SCOPE)
 					.inCollection(CollectionIdentifier.DEFAULT_COLLECTION).matching(query).all();
@@ -785,9 +788,8 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 		try {
 			UserCol saved = couchbaseTemplate.insertById(UserCol.class).inScope(scopeName).inCollection(collectionName)
 					.one(user);
-			List<UserCol> found = couchbaseTemplate.findByQuery(UserCol.class)
-					.withConsistency(QueryScanConsistency.REQUEST_PLUS).inScope(scopeName).inCollection(collectionName)
-					.matching(query).all();
+			List<UserCol> found = couchbaseTemplate.findByQuery(UserCol.class).inScope(scopeName).inCollection(collectionName)
+					.matching(query).withConsistency(REQUEST_PLUS).all();
 			assertEquals(saved, found.get(0), "should have found what was saved");
 			List<UserCol> notfound = couchbaseTemplate.findByQuery(UserCol.class).inScope(CollectionIdentifier.DEFAULT_SCOPE)
 					.inCollection(CollectionIdentifier.DEFAULT_COLLECTION).matching(query).all();
@@ -801,4 +803,38 @@ class CouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIn
 			} catch (DataRetrievalFailureException drfe) {}
 		}
 	}
+
+	@Test
+	void testFluentApi() {
+		User user1 = new User(UUID.randomUUID().toString(), "user1", "user1");
+		DurabilityLevel dl = DurabilityLevel.NONE;
+		User result;
+		RemoveResult rr;
+		result = couchbaseTemplate.insertById(User.class).inScope(scopeName).inCollection(collectionName).withDurability(dl)
+				.one(user1);
+		assertEquals(user1, result);
+		result = couchbaseTemplate.upsertById(User.class).inScope(scopeName).inCollection(collectionName).withDurability(dl)
+				.one(user1);
+		assertEquals(user1, result);
+		result = couchbaseTemplate.replaceById(User.class).inScope(scopeName).inCollection(collectionName)
+				.withDurability(dl).one(user1);
+		assertEquals(user1, result);
+		rr = couchbaseTemplate.removeById(User.class).inScope(scopeName).inCollection(collectionName).withDurability(dl)
+				.one(user1.getId());
+		assertEquals(rr.getId(), user1.getId());
+		assertEquals(user1, result);
+		result = reactiveCouchbaseTemplate.insertById(User.class).inScope(scopeName).inCollection(collectionName)
+				.withDurability(dl).one(user1).block();
+		assertEquals(user1, result);
+		result = reactiveCouchbaseTemplate.upsertById(User.class).inScope(scopeName).inCollection(collectionName)
+				.withDurability(dl).one(user1).block();
+		assertEquals(user1, result);
+		result = reactiveCouchbaseTemplate.replaceById(User.class).inScope(scopeName).inCollection(collectionName)
+				.withDurability(dl).one(user1).block();
+		assertEquals(user1, result);
+		rr = reactiveCouchbaseTemplate.removeById(User.class).inScope(scopeName).inCollection(collectionName)
+				.withDurability(dl).one(user1.getId()).block();
+		assertEquals(rr.getId(), user1.getId());
+	}
+
 }
diff --git a/src/test/java/org/springframework/data/couchbase/core/CouchbaseTemplateQueryIntegrationTests.java b/src/test/java/org/springframework/data/couchbase/core/CouchbaseTemplateQueryIntegrationTests.java
index f7987c6a..691f0dc8 100644
--- a/src/test/java/org/springframework/data/couchbase/core/CouchbaseTemplateQueryIntegrationTests.java
+++ b/src/test/java/org/springframework/data/couchbase/core/CouchbaseTemplateQueryIntegrationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,6 +16,7 @@
 
 package org.springframework.data.couchbase.core;
 
+import static com.couchbase.client.java.query.QueryScanConsistency.REQUEST_PLUS;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertNull;
@@ -26,16 +27,19 @@ import java.time.Instant;
 import java.time.temporal.TemporalAccessor;
 import java.util.Arrays;
 import java.util.List;
+import java.util.Locale;
 import java.util.UUID;
 import java.util.stream.Collectors;
 
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.data.couchbase.core.query.Query;
 import org.springframework.data.couchbase.core.query.QueryCriteria;
 import org.springframework.data.couchbase.domain.Address;
 import org.springframework.data.couchbase.domain.Airport;
 import org.springframework.data.couchbase.domain.AssessmentDO;
+import org.springframework.data.couchbase.domain.Config;
 import org.springframework.data.couchbase.domain.Course;
 import org.springframework.data.couchbase.domain.NaiveAuditorAware;
 import org.springframework.data.couchbase.domain.Submission;
@@ -48,8 +52,10 @@ import org.springframework.data.couchbase.util.Capabilities;
 import org.springframework.data.couchbase.util.ClusterType;
 import org.springframework.data.couchbase.util.IgnoreWhen;
 import org.springframework.data.couchbase.util.JavaIntegrationTests;
-
-import com.couchbase.client.java.query.QueryScanConsistency;
+import org.springframework.data.domain.PageRequest;
+import org.springframework.data.domain.Pageable;
+import org.springframework.data.domain.Sort;
+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
 
 /**
  * Query tests Theses tests rely on a cb server running
@@ -60,8 +66,13 @@ import com.couchbase.client.java.query.QueryScanConsistency;
  * @author Mauro Monti
  */
 @IgnoreWhen(missesCapabilities = Capabilities.QUERY, clusterTypes = ClusterType.MOCKED)
+@SpringJUnitConfig(Config.class)
 class CouchbaseTemplateQueryIntegrationTests extends JavaIntegrationTests {
 
+	@Autowired
+	public CouchbaseTemplate couchbaseTemplate;
+	@Autowired public ReactiveCouchbaseTemplate reactiveCouchbaseTemplate;
+
 	@BeforeEach
 	@Override
 	public void beforeEach() {
@@ -73,7 +84,7 @@ class CouchbaseTemplateQueryIntegrationTests extends JavaIntegrationTests {
 		// ensure each test starts with clean state
 
 		couchbaseTemplate.removeByQuery(User.class).all();
-		couchbaseTemplate.findByQuery(User.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).all();
+		couchbaseTemplate.findByQuery(User.class).withConsistency(REQUEST_PLUS).all();
 	}
 
 	@Test
@@ -84,8 +95,7 @@ class CouchbaseTemplateQueryIntegrationTests extends JavaIntegrationTests {
 
 			couchbaseTemplate.upsertById(User.class).all(Arrays.asList(user1, user2));
 
-			final List<User> foundUsers = couchbaseTemplate.findByQuery(User.class)
-					.withConsistency(QueryScanConsistency.REQUEST_PLUS).all();
+			final List<User> foundUsers = couchbaseTemplate.findByQuery(User.class).withConsistency(REQUEST_PLUS).all();
 
 			for (User u : foundUsers) {
 				if (!(u.equals(user1) || u.equals(user2))) {
@@ -108,7 +118,7 @@ class CouchbaseTemplateQueryIntegrationTests extends JavaIntegrationTests {
 			couchbaseTemplate.findById(User.class).one(user1.getId());
 			reactiveCouchbaseTemplate.findById(User.class).one(user1.getId()).block();
 		} finally {
-			couchbaseTemplate.removeByQuery(User.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).all();
+			couchbaseTemplate.removeByQuery(User.class).withConsistency(REQUEST_PLUS).all();
 		}
 
 		User usery = couchbaseTemplate.findById(User.class).one("user1");
@@ -127,8 +137,8 @@ class CouchbaseTemplateQueryIntegrationTests extends JavaIntegrationTests {
 		couchbaseTemplate.upsertById(User.class).all(Arrays.asList(user1, user2, specialUser));
 
 		Query specialUsers = new Query(QueryCriteria.where(i("firstname")).like("special"));
-		final List<User> foundUsers = couchbaseTemplate.findByQuery(User.class)
-				.withConsistency(QueryScanConsistency.REQUEST_PLUS).matching(specialUsers).all();
+		final List<User> foundUsers = couchbaseTemplate.findByQuery(User.class).matching(specialUsers)
+				.withConsistency(REQUEST_PLUS).all();
 
 		assertEquals(1, foundUsers.size());
 	}
@@ -142,10 +152,11 @@ class CouchbaseTemplateQueryIntegrationTests extends JavaIntegrationTests {
 
 		Query specialUsers = new Query(QueryCriteria.where(i("id")).is(ado.getId()));
 		final List<AssessmentDO> foundUsers = couchbaseTemplate.findByQuery(AssessmentDO.class)
-				.withConsistency(QueryScanConsistency.REQUEST_PLUS).matching(specialUsers).all();
+				.matching(specialUsers).withConsistency(REQUEST_PLUS).all();
 		assertEquals("123", foundUsers.get(0).getId(), "id");
 		assertEquals("44444444", foundUsers.get(0).getDocumentId(), "documentId");
 		assertEquals(ado, foundUsers.get(0));
+		couchbaseTemplate.removeById(AssessmentDO.class).one(ado.getDocumentId());
 	}
 
 	@Test
@@ -169,7 +180,7 @@ class CouchbaseTemplateQueryIntegrationTests extends JavaIntegrationTests {
 		Query daveUsers = new Query(QueryCriteria.where("username").like("dave"));
 
 		final List<UserSubmissionProjected> foundUserSubmissions = couchbaseTemplate.findByQuery(UserSubmission.class)
-				.as(UserSubmissionProjected.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).matching(daveUsers).all();
+				.as(UserSubmissionProjected.class).matching(daveUsers).withConsistency(REQUEST_PLUS).all();
 		assertEquals(1, foundUserSubmissions.size());
 		assertEquals(user.getUsername(), foundUserSubmissions.get(0).getUsername());
 		assertEquals(user.getId(), foundUserSubmissions.get(0).getId());
@@ -186,14 +197,14 @@ class CouchbaseTemplateQueryIntegrationTests extends JavaIntegrationTests {
 
 		Query specialUsers = new Query(QueryCriteria.where("firstname").like("special"));
 		final List<UserJustLastName> foundUsers = couchbaseTemplate.findByQuery(User.class).as(UserJustLastName.class)
-				.withConsistency(QueryScanConsistency.REQUEST_PLUS).matching(specialUsers).all();
+				.matching(specialUsers).withConsistency(REQUEST_PLUS).all();
 		assertEquals(1, foundUsers.size());
 
 		final List<UserJustLastName> foundUsersReactive = reactiveCouchbaseTemplate.findByQuery(User.class)
-				.as(UserJustLastName.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).matching(specialUsers).all()
-				.collectList().block();
+				.as(UserJustLastName.class).matching(specialUsers).withConsistency(REQUEST_PLUS).all().collectList().block();
 		assertEquals(1, foundUsersReactive.size());
 
+		couchbaseTemplate.removeById(User.class).all(Arrays.asList(user1.getId(), user2.getId(), specialUser.getId()));
 	}
 
 	@Test
@@ -206,7 +217,7 @@ class CouchbaseTemplateQueryIntegrationTests extends JavaIntegrationTests {
 		assertTrue(couchbaseTemplate.existsById().one(user1.getId()));
 		assertTrue(couchbaseTemplate.existsById().one(user2.getId()));
 
-		couchbaseTemplate.removeByQuery(User.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).all();
+		couchbaseTemplate.removeByQuery(User.class).withConsistency(REQUEST_PLUS).all();
 
 		assertNull(couchbaseTemplate.findById(User.class).one(user1.getId()));
 		assertNull(couchbaseTemplate.findById(User.class).one(user2.getId()));
@@ -227,8 +238,7 @@ class CouchbaseTemplateQueryIntegrationTests extends JavaIntegrationTests {
 
 		Query nonSpecialUsers = new Query(QueryCriteria.where(i("firstname")).notLike("special"));
 
-		couchbaseTemplate.removeByQuery(User.class).withConsistency(QueryScanConsistency.REQUEST_PLUS)
-				.matching(nonSpecialUsers).all();
+		couchbaseTemplate.removeByQuery(User.class).matching(nonSpecialUsers).withConsistency(REQUEST_PLUS).all();
 
 		assertNull(couchbaseTemplate.findById(User.class).one(user1.getId()));
 		assertNull(couchbaseTemplate.findById(User.class).one(user2.getId()));
@@ -252,17 +262,17 @@ class CouchbaseTemplateQueryIntegrationTests extends JavaIntegrationTests {
 
 			// distinct icao
 			List<Airport> airports1 = couchbaseTemplate.findByQuery(Airport.class).distinct(new String[] { "icao" })
-					.as(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).all();
+					.as(Airport.class).withConsistency(REQUEST_PLUS).all();
 			assertEquals(2, airports1.size());
 
 			// distinct all-fields-in-Airport.class
 			List<Airport> airports2 = couchbaseTemplate.findByQuery(Airport.class).distinct(new String[] {}).as(Airport.class)
-					.withConsistency(QueryScanConsistency.REQUEST_PLUS).all();
+					.withConsistency(REQUEST_PLUS).all();
 			assertEquals(7, airports2.size());
 
 			// count( distinct { iata, icao } )
 			long count1 = couchbaseTemplate.findByQuery(Airport.class).distinct(new String[] { "iata", "icao" })
-					.as(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).count();
+					.as(Airport.class).withConsistency(REQUEST_PLUS).count();
 			assertEquals(7, count1);
 
 			// count( distinct (all fields in icaoClass)
@@ -271,7 +281,7 @@ class CouchbaseTemplateQueryIntegrationTests extends JavaIntegrationTests {
 				String icao;
 			}).getClass();
 			long count2 = couchbaseTemplate.findByQuery(Airport.class).distinct(new String[] {}).as(icaoClass)
-					.withConsistency(QueryScanConsistency.REQUEST_PLUS).count();
+					.withConsistency(REQUEST_PLUS).count();
 			assertEquals(7, count2);
 
 		} finally {
@@ -296,28 +306,24 @@ class CouchbaseTemplateQueryIntegrationTests extends JavaIntegrationTests {
 
 			// distinct icao
 			List<Airport> airports1 = reactiveCouchbaseTemplate.findByQuery(Airport.class).distinct(new String[] { "icao" })
-					.as(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).all().collectList().block();
+					.as(Airport.class).withConsistency(REQUEST_PLUS).all().collectList().block();
 			assertEquals(2, airports1.size());
 
 			// distinct all-fields-in-Airport.class
 			List<Airport> airports2 = reactiveCouchbaseTemplate.findByQuery(Airport.class).distinct(new String[] {})
-					.as(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).all().collectList().block();
+					.as(Airport.class).withConsistency(REQUEST_PLUS).all().collectList().block();
 			assertEquals(7, airports2.size());
 
 			// count( distinct icao )
 			// not currently possible to have multiple fields in COUNT(DISTINCT field1, field2, ... ) due to MB43475
 			long count1 = reactiveCouchbaseTemplate.findByQuery(Airport.class).distinct(new String[] { "icao" })
-					.as(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).count().block();
+					.as(Airport.class).withConsistency(REQUEST_PLUS).count().block();
 			assertEquals(2, count1);
 
-			// count( distinct (all fields in icaoClass) // which only has one field
-			// not currently possible to have multiple fields in COUNT(DISTINCT field1, field2, ... ) due to MB43475
-			Class icaoClass = (new Object() {
-				String icao;
-			}).getClass();
-			long count2 = (long) reactiveCouchbaseTemplate.findByQuery(Airport.class).distinct(new String[] {}).as(icaoClass)
-					.withConsistency(QueryScanConsistency.REQUEST_PLUS).count().block();
-			assertEquals(2, count2);
+			// count( distinct { icao, iata } )
+			Long count2 = reactiveCouchbaseTemplate.findByQuery(Airport.class).distinct(new String[] { "icao", "iata" })
+					.withConsistency(REQUEST_PLUS).count().block();
+			assertEquals(7, count2);
 
 		} finally {
 			reactiveCouchbaseTemplate.removeById()
@@ -326,4 +332,34 @@ class CouchbaseTemplateQueryIntegrationTests extends JavaIntegrationTests {
 		}
 	}
 
+	@Test
+	void sortedTemplate() {
+		couchbaseTemplate.removeByQuery(Airport.class).withConsistency(REQUEST_PLUS).all();
+		String[] iatas = { "JFK", "IAD", "SFO", "SJC", "SEA", "LAX", "PHX" };
+
+		try {
+			couchbaseTemplate.insertById(Airport.class)
+					.all(Arrays.stream(iatas).map((iata) -> new Airport("airports::" + iata, iata, iata.toLowerCase(Locale.ROOT)))
+							.collect(Collectors.toSet()));
+
+			org.springframework.data.couchbase.core.query.Query query = org.springframework.data.couchbase.core.query.Query
+					.query(QueryCriteria.where("iata").isNotNull());
+			Pageable pageableWithSort = PageRequest.of(0, 7, Sort.by("iata"));
+			query.with(pageableWithSort);
+			List<Airport> airports = couchbaseTemplate.findByQuery(Airport.class).matching(query).withConsistency(REQUEST_PLUS)
+					.all();
+
+			String[] sortedIatas = iatas.clone();
+			System.out.println("" + iatas.length + " " + sortedIatas.length);
+			Arrays.sort(sortedIatas);
+			for (int i = 0; i < pageableWithSort.getPageSize(); i++) {
+				System.out.println(airports.get(i).getIata());
+				assertEquals(sortedIatas[i], airports.get(i).getIata());
+			}
+		} finally {
+			couchbaseTemplate.removeById(Airport.class)
+					.all(Arrays.stream(iatas).map((iata) -> "airports::" + iata).collect(Collectors.toSet()));
+		}
+	}
+
 }
diff --git a/src/test/java/org/springframework/data/couchbase/core/CustomTypeKeyIntegrationTests.java b/src/test/java/org/springframework/data/couchbase/core/CustomTypeKeyIntegrationTests.java
index 40adb9c1..2ca6bb98 100644
--- a/src/test/java/org/springframework/data/couchbase/core/CustomTypeKeyIntegrationTests.java
+++ b/src/test/java/org/springframework/data/couchbase/core/CustomTypeKeyIntegrationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2020 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -37,6 +37,9 @@ import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
 
 import com.couchbase.client.java.kv.GetResult;
 
+/**
+ * @author Michael Reiche
+ */
 @SpringJUnitConfig(CustomTypeKeyIntegrationTests.Config.class)
 @IgnoreWhen(clusterTypes = ClusterType.MOCKED)
 public class CustomTypeKeyIntegrationTests extends ClusterAwareIntegrationTests {
@@ -59,9 +62,9 @@ public class CustomTypeKeyIntegrationTests extends ClusterAwareIntegrationTests
 		assertEquals(user, modified);
 
 		GetResult getResult = clientFactory.getCollection(null).get(user.getId());
-		assertEquals("org.springframework.data.couchbase.domain.User",
-				getResult.contentAsObject().getString(CUSTOM_TYPE_KEY));
+		assertEquals("abstractuser", getResult.contentAsObject().getString(CUSTOM_TYPE_KEY));
 		assertFalse(getResult.contentAsObject().containsKey(DefaultCouchbaseTypeMapper.DEFAULT_TYPE_KEY));
+		operations.removeById(User.class).one(user.getId());
 	}
 
 	@Configuration
diff --git a/src/test/java/org/springframework/data/couchbase/core/ReactiveCouchbaseTemplateKeyValueIntegrationTests.java b/src/test/java/org/springframework/data/couchbase/core/ReactiveCouchbaseTemplateKeyValueIntegrationTests.java
index 379e76fc..265ad44d 100644
--- a/src/test/java/org/springframework/data/couchbase/core/ReactiveCouchbaseTemplateKeyValueIntegrationTests.java
+++ b/src/test/java/org/springframework/data/couchbase/core/ReactiveCouchbaseTemplateKeyValueIntegrationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2021 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -37,8 +37,10 @@ import java.util.UUID;
 
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
+import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.dao.DataIntegrityViolationException;
 import org.springframework.dao.DuplicateKeyException;
+import org.springframework.dao.OptimisticLockingFailureException;
 import org.springframework.data.couchbase.core.ReactiveFindByIdOperation.ReactiveFindById;
 import org.springframework.data.couchbase.core.ReactiveRemoveByIdOperation.ReactiveRemoveById;
 import org.springframework.data.couchbase.core.ReactiveReplaceByIdOperation.ReactiveReplaceById;
@@ -46,6 +48,7 @@ import org.springframework.data.couchbase.core.support.OneAndAllEntityReactive;
 import org.springframework.data.couchbase.core.support.OneAndAllIdReactive;
 import org.springframework.data.couchbase.core.support.WithDurability;
 import org.springframework.data.couchbase.core.support.WithExpiry;
+import org.springframework.data.couchbase.domain.Config;
 import org.springframework.data.couchbase.domain.PersonValue;
 import org.springframework.data.couchbase.domain.ReactiveNaiveAuditorAware;
 import org.springframework.data.couchbase.domain.User;
@@ -59,6 +62,7 @@ import org.springframework.data.couchbase.util.JavaIntegrationTests;
 import com.couchbase.client.java.kv.PersistTo;
 import com.couchbase.client.java.kv.ReplicateTo;
 import com.couchbase.client.java.query.QueryScanConsistency;
+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
 
 /**
  * KV tests Theses tests rely on a cb server running.
@@ -67,8 +71,12 @@ import com.couchbase.client.java.query.QueryScanConsistency;
  * @author Michael Reiche
  */
 @IgnoreWhen(clusterTypes = ClusterType.MOCKED)
+@SpringJUnitConfig(Config.class)
 class ReactiveCouchbaseTemplateKeyValueIntegrationTests extends JavaIntegrationTests {
 
+	@Autowired public CouchbaseTemplate couchbaseTemplate;
+	@Autowired public ReactiveCouchbaseTemplate reactiveCouchbaseTemplate;
+
 	@BeforeEach
 	@Override
 	public void beforeEach() {
@@ -130,7 +138,7 @@ class ReactiveCouchbaseTemplateKeyValueIntegrationTests extends JavaIntegrationT
 
 		User badUser = new User(user.getId(), user.getFirstname(), user.getLastname());
 		badUser.setVersion(12345678);
-		assertThrows(DataIntegrityViolationException.class,
+		assertThrows(OptimisticLockingFailureException.class,
 				() -> reactiveCouchbaseTemplate.replaceById(User.class).one(badUser).block());
 
 		User found = reactiveCouchbaseTemplate.findById(User.class).one(user.getId()).block();
@@ -232,6 +240,9 @@ class ReactiveCouchbaseTemplateKeyValueIntegrationTests extends JavaIntegrationT
 					errorList.add("\nfound should have been null as document should be expired " + user.getId());
 				}
 			}
+			if (found != null) {
+				couchbaseTemplate.removeById(user.getClass()).one(user.getId());
+			}
 		}
 
 		if (!errorList.isEmpty()) {
@@ -282,7 +293,7 @@ class ReactiveCouchbaseTemplateKeyValueIntegrationTests extends JavaIntegrationT
 			// careful now - user and modified are the same object. The object has the new cas (@Version version)
 			Long savedCas = modified.getVersion();
 			modified.setVersion(123);
-			assertThrows(DataIntegrityViolationException.class, () -> reactiveCouchbaseTemplate.removeById()
+			assertThrows(OptimisticLockingFailureException.class, () -> reactiveCouchbaseTemplate.removeById()
 					.withCas(reactiveCouchbaseTemplate.support().getCas(modified)).one(modified.getId()).block());
 			modified.setVersion(savedCas);
 			reactiveCouchbaseTemplate.removeById().withCas(reactiveCouchbaseTemplate.support().getCas(modified))
@@ -323,7 +334,7 @@ class ReactiveCouchbaseTemplateKeyValueIntegrationTests extends JavaIntegrationT
 	@Test
 	@IgnoreWhen(clusterTypes = ClusterType.MOCKED)
 	void saveAndFindImmutableById() {
-		PersonValue personValue = new PersonValue(UUID.randomUUID().toString(), 123, "f", "l");
+		PersonValue personValue = new PersonValue(UUID.randomUUID().toString(), 123, "329", "l");
 		PersonValue inserted;
 		PersonValue upserted;
 		PersonValue replaced;
@@ -354,7 +365,7 @@ class ReactiveCouchbaseTemplateKeyValueIntegrationTests extends JavaIntegrationT
 		PersonValue foundReplaced = reactiveCouchbaseTemplate.findById(PersonValue.class).one(replaced.getId()).block();
 		assertNotNull(foundReplaced, "replaced personValue not found");
 		assertEquals(replaced, foundReplaced);
-
+		couchbaseTemplate.removeById(PersonValue.class).one(replaced.getId());
 	}
 
 	private void sleepSecs(int i) {
diff --git a/src/test/java/org/springframework/data/couchbase/core/mapping/MappingCouchbaseConverterTests.java b/src/test/java/org/springframework/data/couchbase/core/mapping/MappingCouchbaseConverterTests.java
index 49652573..d807c915 100644
--- a/src/test/java/org/springframework/data/couchbase/core/mapping/MappingCouchbaseConverterTests.java
+++ b/src/test/java/org/springframework/data/couchbase/core/mapping/MappingCouchbaseConverterTests.java
@@ -455,7 +455,7 @@ public class MappingCouchbaseConverterTests {
 		List<BigDecimal> listOfValues = new ArrayList<>();
 		listOfValues.add(value);
 		listOfValues.add(value2);
-		Map<String, BigDecimal> mapOfValues = new HashMap<>();
+		Map<String, BigDecimal> mapOfValues = new TreeMap<>();
 		mapOfValues.put("val1", value);
 		mapOfValues.put("val2", value2);
 
diff --git a/src/test/java/org/springframework/data/couchbase/core/query/QueryCriteriaTests.java b/src/test/java/org/springframework/data/couchbase/core/query/QueryCriteriaTests.java
index fe7edbeb..05f5b2db 100644
--- a/src/test/java/org/springframework/data/couchbase/core/query/QueryCriteriaTests.java
+++ b/src/test/java/org/springframework/data/couchbase/core/query/QueryCriteriaTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2021 the original author or authors.
+ * Copyright 2017-2022 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -24,12 +24,12 @@ import static org.springframework.data.couchbase.core.query.N1QLExpression.x;
 import static org.springframework.data.couchbase.core.query.QueryCriteria.where;
 import static org.springframework.data.couchbase.repository.query.support.N1qlUtils.escapedBucket;
 
+import java.util.Arrays;
+
 import org.junit.jupiter.api.Test;
 
 import com.couchbase.client.java.json.JsonArray;
 
-import java.util.Arrays;
-
 /**
  * @author Mauro Monti
  */
@@ -84,9 +84,10 @@ class QueryCriteriaTests {
 	@Test
 	void testNestedNotIn() {
 		QueryCriteria c = where(i("name")).is("Bubba").or(where(i("age")).gt(12).or(i("country")).is("Austria"))
-				.and(where(i("state")).notIn(new String[] { "Alabama", "Florida" }));
-		assertEquals("`name` = \"Bubba\" or (`age` > 12 or `country` = \"Austria\") and "
-				+ "(not( (`state` in ( [\"Alabama\",\"Florida\"] )) ))", c.export());
+				.and(where(i("state")).notIn((Object) new String[] { "Alabama", "Florida" }));
+		JsonArray parameters = JsonArray.create();
+		assertEquals("`name` = $1 or (`age` > $2 or `country` = $3) and (not( (`state` in $4) ))",
+				c.export(new int[1], parameters, null));
 	}
 
 	@Test
@@ -224,20 +225,21 @@ class QueryCriteriaTests {
 	@Test
 	void testIn() {
 		String[] args = new String[] { "gump", "davis" };
-		QueryCriteria c = where(i("name")).in((Object)args);
-		assertEquals("`name` in ( [\"gump\",\"davis\"] )", c.export());
+		QueryCriteria c = where(i("name")).in((Object) args); // the first arg is an array
+		assertEquals("`name` in [\"gump\",\"davis\"]", c.export());
 		JsonArray parameters = JsonArray.create();
-		assertEquals("`name` in ( $1 )", c.export(new int[1], parameters, null));
+		assertEquals("`name` in $1", c.export(new int[1], parameters, null));
 		assertEquals(arrayToString(args), parameters.get(0).toString());
 	}
 
 	@Test
 	void testNotIn() {
 		String[] args = new String[] { "gump", "davis" };
-		QueryCriteria c = where(i("name")).notIn((Object)args);
-		assertEquals("not( (`name` in ( [\"gump\",\"davis\"] )) )", c.export());
+		QueryCriteria c = where(i("name")).notIn((Object) args); // the first arg is an array
+		assertEquals("not( (`name` in [\"gump\",\"davis\"]) )", c.export());
+		// this tests creating parameters from the args.
 		JsonArray parameters = JsonArray.create();
-		assertEquals("not( (`name` in ( $1 )) )", c.export(new int[1], parameters, null));
+		assertEquals("not( (`name` in $1) )", c.export(new int[1], parameters, null));
 		assertEquals(arrayToString(args), parameters.get(0).toString());
 	}
 
@@ -261,7 +263,6 @@ class QueryCriteriaTests {
 		assertEquals(" USE KEYS []", expression.keys(Arrays.asList()).toString());
 	}
 
-
 	@Test // https://github.com/spring-projects/spring-data-couchbase/issues/1066
 	void testCriteriaCorrectlyEscapedWhenUsingMetaOnLHS() {
 		final String bucketName = "sample-bucket";
diff --git a/src/test/java/org/springframework/data/couchbase/core/query/ReactiveCouchbaseTemplateQueryCollectionIntegrationTests.java b/src/test/java/org/springframework/data/couchbase/core/query/ReactiveCouchbaseTemplateQueryCollectionIntegrationTests.java
index afc7f5c1..26dafb8a 100644
--- a/src/test/java/org/springframework/data/couchbase/core/query/ReactiveCouchbaseTemplateQueryCollectionIntegrationTests.java
+++ b/src/test/java/org/springframework/data/couchbase/core/query/ReactiveCouchbaseTemplateQueryCollectionIntegrationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2021 the original author or authors
+ * Copyright 2021-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,6 +16,7 @@
 
 package org.springframework.data.couchbase.core.query;
 
+import static com.couchbase.client.java.query.QueryScanConsistency.REQUEST_PLUS;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertNull;
@@ -36,10 +37,13 @@ import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.data.couchbase.core.CouchbaseTemplate;
 import org.springframework.data.couchbase.core.ReactiveCouchbaseTemplate;
 import org.springframework.data.couchbase.core.RemoveResult;
 import org.springframework.data.couchbase.domain.Address;
 import org.springframework.data.couchbase.domain.Airport;
+import org.springframework.data.couchbase.domain.CollectionsConfig;
 import org.springframework.data.couchbase.domain.Course;
 import org.springframework.data.couchbase.domain.NaiveAuditorAware;
 import org.springframework.data.couchbase.domain.Submission;
@@ -52,6 +56,7 @@ import org.springframework.data.couchbase.util.Capabilities;
 import org.springframework.data.couchbase.util.ClusterType;
 import org.springframework.data.couchbase.util.CollectionAwareIntegrationTests;
 import org.springframework.data.couchbase.util.IgnoreWhen;
+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
 
 import com.couchbase.client.core.error.AmbiguousTimeoutException;
 import com.couchbase.client.core.error.UnambiguousTimeoutException;
@@ -64,7 +69,6 @@ import com.couchbase.client.java.kv.RemoveOptions;
 import com.couchbase.client.java.kv.ReplaceOptions;
 import com.couchbase.client.java.kv.UpsertOptions;
 import com.couchbase.client.java.query.QueryOptions;
-import com.couchbase.client.java.query.QueryScanConsistency;
 
 /**
  * Query tests Theses tests rely on a cb server running This class tests collection support with
@@ -74,10 +78,15 @@ import com.couchbase.client.java.query.QueryScanConsistency;
  * @author Michael Reiche
  */
 @IgnoreWhen(missesCapabilities = { Capabilities.QUERY, Capabilities.COLLECTIONS }, clusterTypes = ClusterType.MOCKED)
+@SpringJUnitConfig(CollectionsConfig.class)
 class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends CollectionAwareIntegrationTests {
 
-	Airport vie = new Airport("airports::vie", "vie", "low7");
-	ReactiveCouchbaseTemplate template = reactiveCouchbaseTemplate;
+	@Autowired
+	public CouchbaseTemplate couchbaseTemplate;
+	@Autowired public ReactiveCouchbaseTemplate reactiveCouchbaseTemplate;
+
+	Airport vie = new Airport("airports::vie", "vie", "low80");
+	ReactiveCouchbaseTemplate template;
 
 	@BeforeAll
 	public static void beforeAll() {
@@ -101,15 +110,16 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 		// first call the super method
 		super.beforeEach();
 		// then do processing for this class
-		couchbaseTemplate.removeByQuery(User.class).inCollection(collectionName).all();
-		couchbaseTemplate.findByQuery(User.class).withConsistency(QueryScanConsistency.REQUEST_PLUS)
-				.inCollection(collectionName).all();
+		couchbaseTemplate.removeByQuery(User.class).inCollection(collectionName).withConsistency(REQUEST_PLUS).all();
+		couchbaseTemplate.findByQuery(User.class).inCollection(collectionName).withConsistency(REQUEST_PLUS).all();
 		couchbaseTemplate.removeByQuery(Airport.class).inScope(scopeName).inCollection(collectionName).all();
-		couchbaseTemplate.findByQuery(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).inScope(scopeName)
-				.inCollection(collectionName).all();
+		couchbaseTemplate.findByQuery(Airport.class).inScope(scopeName).inCollection(collectionName)
+				.withConsistency(REQUEST_PLUS).all();
 		couchbaseTemplate.removeByQuery(Airport.class).inScope(otherScope).inCollection(otherCollection).all();
-		couchbaseTemplate.findByQuery(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).inScope(otherScope)
-				.inCollection(otherCollection).all();
+		couchbaseTemplate.findByQuery(Airport.class).inScope(otherScope).inCollection(otherCollection)
+				.withConsistency(REQUEST_PLUS).all();
+
+		template = reactiveCouchbaseTemplate;
 	}
 
 	@AfterEach
@@ -118,8 +128,7 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 		// first do processing for this class
 		couchbaseTemplate.removeByQuery(User.class).inCollection(collectionName).all();
 		// query with REQUEST_PLUS to ensure that the remove has completed.
-		couchbaseTemplate.findByQuery(User.class).withConsistency(QueryScanConsistency.REQUEST_PLUS)
-				.inCollection(collectionName).all();
+		couchbaseTemplate.findByQuery(User.class).inCollection(collectionName).withConsistency(REQUEST_PLUS).all();
 		// then call the super method
 		super.afterEach();
 	}
@@ -132,8 +141,8 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 
 			couchbaseTemplate.upsertById(User.class).inCollection(collectionName).all(Arrays.asList(user1, user2));
 
-			final List<User> foundUsers = couchbaseTemplate.findByQuery(User.class)
-					.withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName).all();
+			final List<User> foundUsers = couchbaseTemplate.findByQuery(User.class).inCollection(collectionName)
+					.withConsistency(REQUEST_PLUS).all();
 
 			for (User u : foundUsers) {
 				if (!(u.equals(user1) || u.equals(user2))) {
@@ -175,8 +184,8 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 		couchbaseTemplate.upsertById(User.class).inCollection(collectionName).all(Arrays.asList(user1, user2, specialUser));
 
 		Query specialUsers = new Query(QueryCriteria.where("firstname").like("special"));
-		final List<User> foundUsers = couchbaseTemplate.findByQuery(User.class)
-				.withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName).matching(specialUsers).all();
+		final List<User> foundUsers = couchbaseTemplate.findByQuery(User.class).inCollection(collectionName)
+				.matching(specialUsers).withConsistency(REQUEST_PLUS).all();
 
 		assertEquals(1, foundUsers.size());
 	}
@@ -200,8 +209,8 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 		Query daveUsers = new Query(QueryCriteria.where("username").like("dave"));
 
 		final List<UserSubmissionProjected> foundUserSubmissions = couchbaseTemplate.findByQuery(UserSubmission.class)
-				.as(UserSubmissionProjected.class).withConsistency(QueryScanConsistency.REQUEST_PLUS)
-				.inCollection(collectionName).matching(daveUsers).all();
+				.inCollection(collectionName).as(UserSubmissionProjected.class).matching(daveUsers)
+				.withConsistency(REQUEST_PLUS).all();
 		assertEquals(1, foundUserSubmissions.size());
 		assertEquals(user.getUsername(), foundUserSubmissions.get(0).getUsername());
 		assertEquals(user.getId(), foundUserSubmissions.get(0).getId());
@@ -217,13 +226,13 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 		couchbaseTemplate.upsertById(User.class).inCollection(collectionName).all(Arrays.asList(user1, user2, specialUser));
 
 		Query specialUsers = new Query(QueryCriteria.where("firstname").like("special"));
-		final List<UserJustLastName> foundUsers = couchbaseTemplate.findByQuery(User.class).as(UserJustLastName.class)
-				.withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName).matching(specialUsers).all();
+		final List<UserJustLastName> foundUsers = couchbaseTemplate.findByQuery(User.class).inCollection(collectionName)
+				.as(UserJustLastName.class).matching(specialUsers).withConsistency(REQUEST_PLUS).all();
 		assertEquals(1, foundUsers.size());
 
 		final List<UserJustLastName> foundUsersReactive = reactiveCouchbaseTemplate.findByQuery(User.class)
-				.as(UserJustLastName.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName)
-				.matching(specialUsers).all().collectList().block();
+				.inCollection(collectionName).as(UserJustLastName.class).matching(specialUsers).withConsistency(REQUEST_PLUS)
+				.all().collectList().block();
 		assertEquals(1, foundUsersReactive.size());
 
 	}
@@ -239,8 +248,8 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 		assertTrue(couchbaseTemplate.existsById().inScope(scopeName).inCollection(collectionName).one(user1.getId()));
 		assertTrue(couchbaseTemplate.existsById().inScope(scopeName).inCollection(collectionName).one(user2.getId()));
 
-		List<RemoveResult> result = couchbaseTemplate.removeByQuery(User.class)
-				.withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName).all();
+		List<RemoveResult> result = couchbaseTemplate.removeByQuery(User.class).inCollection(collectionName)
+				.withConsistency(REQUEST_PLUS).all();
 		assertEquals(2, result.size(), "should have deleted user1 and user2");
 
 		assertNull(
@@ -264,8 +273,8 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 
 		Query nonSpecialUsers = new Query(QueryCriteria.where("firstname").notLike("special"));
 
-		couchbaseTemplate.removeByQuery(User.class).withConsistency(QueryScanConsistency.REQUEST_PLUS)
-				.inCollection(collectionName).matching(nonSpecialUsers).all();
+		couchbaseTemplate.removeByQuery(User.class).inCollection(collectionName).matching(nonSpecialUsers)
+				.withConsistency(REQUEST_PLUS).all();
 
 		assertNull(couchbaseTemplate.findById(User.class).inCollection(collectionName).one(user1.getId()));
 		assertNull(couchbaseTemplate.findById(User.class).inCollection(collectionName).one(user2.getId()));
@@ -288,18 +297,18 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 			// as the fluent api for Distinct is tricky
 
 			// distinct icao
-			List<Airport> airports1 = couchbaseTemplate.findByQuery(Airport.class).distinct(new String[] { "icao" })
-					.as(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName).all();
+			List<Airport> airports1 = couchbaseTemplate.findByQuery(Airport.class).inCollection(collectionName)
+					.distinct(new String[] { "icao" }).as(Airport.class).withConsistency(REQUEST_PLUS).all();
 			assertEquals(2, airports1.size());
 
 			// distinct all-fields-in-Airport.class
-			List<Airport> airports2 = couchbaseTemplate.findByQuery(Airport.class).distinct(new String[] {}).as(Airport.class)
-					.withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName).all();
+			List<Airport> airports2 = couchbaseTemplate.findByQuery(Airport.class).inCollection(collectionName)
+					.distinct(new String[] {}).as(Airport.class).withConsistency(REQUEST_PLUS).all();
 			assertEquals(7, airports2.size());
 
 			// count( distinct { iata, icao } )
-			long count1 = couchbaseTemplate.findByQuery(Airport.class).distinct(new String[] { "iata", "icao" })
-					.as(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName).count();
+			long count1 = couchbaseTemplate.findByQuery(Airport.class).inCollection(collectionName)
+					.distinct(new String[] { "iata", "icao" }).as(Airport.class).withConsistency(REQUEST_PLUS).count();
 			assertEquals(7, count1);
 
 			// count( distinct (all fields in icaoClass)
@@ -307,8 +316,8 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 				String iata;
 				String icao;
 			}).getClass();
-			long count2 = couchbaseTemplate.findByQuery(Airport.class).distinct(new String[] {}).as(icaoClass)
-					.withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName).count();
+			long count2 = couchbaseTemplate.findByQuery(Airport.class).inCollection(collectionName).distinct(new String[] {})
+					.as(icaoClass).withConsistency(REQUEST_PLUS).count();
 			assertEquals(7, count2);
 
 		} finally {
@@ -332,32 +341,26 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 			// as the fluent api for Distinct is tricky
 
 			// distinct icao
-			List<Airport> airports1 = reactiveCouchbaseTemplate.findByQuery(Airport.class).distinct(new String[] { "icao" })
-					.as(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName).all()
-					.collectList().block();
+			List<Airport> airports1 = reactiveCouchbaseTemplate.findByQuery(Airport.class).inCollection(collectionName)
+					.distinct(new String[] { "icao" }).as(Airport.class).withConsistency(REQUEST_PLUS).all().collectList()
+					.block();
 			assertEquals(2, airports1.size());
 
 			// distinct all-fields-in-Airport.class
-			List<Airport> airports2 = reactiveCouchbaseTemplate.findByQuery(Airport.class).distinct(new String[] {})
-					.as(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName).all()
-					.collectList().block();
+			List<Airport> airports2 = reactiveCouchbaseTemplate.findByQuery(Airport.class).inCollection(collectionName)
+					.distinct(new String[] {}).as(Airport.class).withConsistency(REQUEST_PLUS).all().collectList().block();
 			assertEquals(7, airports2.size());
 
 			// count( distinct icao )
 			// not currently possible to have multiple fields in COUNT(DISTINCT field1, field2, ... ) due to MB43475
-			Long count1 = reactiveCouchbaseTemplate.findByQuery(Airport.class).distinct(new String[] { "icao" })
-					.as(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName).count()
-					.block();
+			Long count1 = reactiveCouchbaseTemplate.findByQuery(Airport.class).inCollection(collectionName)
+					.distinct(new String[] { "icao" }).as(Airport.class).withConsistency(REQUEST_PLUS).count().block();
 			assertEquals(2, count1);
 
-			// count( distinct (all fields in icaoClass) // which only has one field
-			// not currently possible to have multiple fields in COUNT(DISTINCT field1, field2, ... ) due to MB43475
-			Class icaoClass = (new Object() {
-				String icao;
-			}).getClass();
-			long count2 = (long) reactiveCouchbaseTemplate.findByQuery(Airport.class).distinct(new String[] {}).as(icaoClass)
-					.withConsistency(QueryScanConsistency.REQUEST_PLUS).inCollection(collectionName).count().block();
-			assertEquals(2, count2);
+			// count( distinct { iata, icao } )
+			Long count2 = reactiveCouchbaseTemplate.findByQuery(Airport.class).inCollection(collectionName).distinct(new String[] { "iata", "icao" })
+					.withConsistency(REQUEST_PLUS).count().block();
+			assertEquals(7, count2);
 
 		} finally {
 			reactiveCouchbaseTemplate.removeById().inCollection(collectionName)
@@ -383,7 +386,8 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 	public void existsById() { // 1
 		GetOptions options = GetOptions.getOptions().timeout(Duration.ofSeconds(10));
 		ExistsOptions existsOptions = ExistsOptions.existsOptions().timeout(Duration.ofSeconds(10));
-		Airport saved = template.insertById(Airport.class).inScope(scopeName).inCollection(collectionName).one(vie.withIcao("low7")).block();
+		Airport saved = template.insertById(Airport.class).inScope(scopeName).inCollection(collectionName)
+				.one(vie.withIcao("low7")).block();
 		try {
 			Boolean exists = template.existsById().inScope(scopeName).inCollection(collectionName).withOptions(existsOptions)
 					.one(saved.getId()).block();
@@ -397,7 +401,8 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 	@Disabled // needs analytics data set
 	public void findByAnalytics() { // 2
 		AnalyticsOptions options = AnalyticsOptions.analyticsOptions().timeout(Duration.ofSeconds(10));
-		Airport saved = template.insertById(Airport.class).inScope(scopeName).inCollection(collectionName).one(vie.withIcao("low8")).block();
+		Airport saved = template.insertById(Airport.class).inScope(scopeName).inCollection(collectionName)
+				.one(vie.withIcao("low8")).block();
 		try {
 			List<Airport> found = template.findByAnalytics(Airport.class).inScope(scopeName).inCollection(collectionName)
 					.withOptions(options).all().collectList().block();
@@ -410,7 +415,8 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 	@Test
 	public void findById() { // 3
 		GetOptions options = GetOptions.getOptions().timeout(Duration.ofSeconds(10));
-		Airport saved = template.insertById(Airport.class).inScope(scopeName).inCollection(collectionName).one(vie.withIcao("low9")).block();
+		Airport saved = template.insertById(Airport.class).inScope(scopeName).inCollection(collectionName)
+				.one(vie.withIcao("low9")).block();
 		try {
 			Airport found = template.findById(Airport.class).inScope(scopeName).inCollection(collectionName)
 					.withOptions(options).one(saved.getId()).block();
@@ -423,10 +429,11 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 	@Test
 	public void findByQuery() { // 4
 		QueryOptions options = QueryOptions.queryOptions().timeout(Duration.ofSeconds(10));
-		Airport saved = template.insertById(Airport.class).inScope(scopeName).inCollection(collectionName).one(vie.withIcao("lowa")).block();
+		Airport saved = template.insertById(Airport.class).inScope(scopeName).inCollection(collectionName)
+				.one(vie.withIcao("lowa")).block();
 		try {
-			List<Airport> found = template.findByQuery(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS)
-					.inScope(scopeName).inCollection(collectionName).withOptions(options).all().collectList().block();
+			List<Airport> found = template.findByQuery(Airport.class).inScope(scopeName).inCollection(collectionName)
+					.withConsistency(REQUEST_PLUS).withOptions(options).all().collectList().block();
 			assertEquals(saved.getId(), found.get(0).getId());
 		} finally {
 			template.removeById().inScope(scopeName).inCollection(collectionName).one(saved.getId()).block();
@@ -436,7 +443,8 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 	@Test
 	public void findFromReplicasById() { // 5
 		GetAnyReplicaOptions options = GetAnyReplicaOptions.getAnyReplicaOptions().timeout(Duration.ofSeconds(10));
-		Airport saved = template.insertById(Airport.class).inScope(scopeName).inCollection(collectionName).one(vie.withIcao("lowb")).block();
+		Airport saved = template.insertById(Airport.class).inScope(scopeName).inCollection(collectionName)
+				.one(vie.withIcao("lowb")).block();
 		try {
 			Airport found = template.findFromReplicasById(Airport.class).inScope(scopeName).inCollection(collectionName)
 					.withOptions(options).any(saved.getId()).block();
@@ -464,7 +472,8 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 	@Test
 	public void removeById() { // 7
 		RemoveOptions options = RemoveOptions.removeOptions().timeout(Duration.ofSeconds(10));
-		Airport saved = template.insertById(Airport.class).inScope(scopeName).inCollection(collectionName).one(vie.withIcao("lowd")).block();
+		Airport saved = template.insertById(Airport.class).inScope(scopeName).inCollection(collectionName)
+				.one(vie.withIcao("lowd")).block();
 		RemoveResult removeResult = template.removeById().inScope(scopeName).inCollection(collectionName)
 				.withOptions(options).one(saved.getId()).block();
 		assertEquals(saved.getId(), removeResult.getId());
@@ -473,11 +482,11 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 	@Test
 	public void removeByQuery() { // 8
 		QueryOptions options = QueryOptions.queryOptions().timeout(Duration.ofSeconds(10));
-		Airport saved = template.insertById(Airport.class).inScope(scopeName).inCollection(collectionName).one(vie.withIcao("lowe")).block();
-		List<RemoveResult> removeResults = template.removeByQuery(Airport.class)
-				.withConsistency(QueryScanConsistency.REQUEST_PLUS).inScope(scopeName).inCollection(collectionName)
-				.withOptions(options).matching(Query.query(QueryCriteria.where("iata").is(vie.getIata()))).all().collectList()
-				.block();
+		Airport saved = template.insertById(Airport.class).inScope(scopeName).inCollection(collectionName)
+				.one(vie.withIcao("lowe")).block();
+		List<RemoveResult> removeResults = template.removeByQuery(Airport.class).inScope(scopeName)
+				.inCollection(collectionName).matching(Query.query(QueryCriteria.where("iata").is(vie.getIata())))
+				.withConsistency(REQUEST_PLUS).withOptions(options).all().collectList().block();
 		assertEquals(saved.getId(), removeResults.get(0).getId());
 	}
 
@@ -519,8 +528,8 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 	public void existsByIdOther() { // 1
 		GetOptions options = GetOptions.getOptions().timeout(Duration.ofSeconds(10));
 		ExistsOptions existsOptions = ExistsOptions.existsOptions().timeout(Duration.ofSeconds(10));
-		Airport saved = template.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection).one(vie.withIcao("lowg"))
-				.block();
+		Airport saved = template.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection)
+				.one(vie.withIcao("lowg")).block();
 		try {
 			Boolean exists = template.existsById().inScope(otherScope).inCollection(otherCollection)
 					.withOptions(existsOptions).one(saved.getId()).block();
@@ -534,8 +543,8 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 	@Disabled // needs analytics data set
 	public void findByAnalyticsOther() { // 2
 		AnalyticsOptions options = AnalyticsOptions.analyticsOptions().timeout(Duration.ofSeconds(10));
-		Airport saved = template.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection).one(vie.withIcao("lowh"))
-				.block();
+		Airport saved = template.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection)
+				.one(vie.withIcao("lowh")).block();
 		try {
 			List<Airport> found = template.findByAnalytics(Airport.class).inScope(otherScope).inCollection(otherCollection)
 					.withOptions(options).all().collectList().block();
@@ -548,8 +557,8 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 	@Test
 	public void findByIdOther() { // 3
 		GetOptions options = GetOptions.getOptions().timeout(Duration.ofSeconds(10));
-		Airport saved = template.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection).one(vie.withIcao("lowi"))
-				.block();
+		Airport saved = template.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection)
+				.one(vie.withIcao("lowi")).block();
 		try {
 			Airport found = template.findById(Airport.class).inScope(otherScope).inCollection(otherCollection)
 					.withOptions(options).one(saved.getId()).block();
@@ -562,11 +571,11 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 	@Test
 	public void findByQueryOther() { // 4
 		QueryOptions options = QueryOptions.queryOptions().timeout(Duration.ofSeconds(10));
-		Airport saved = template.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection).one(vie.withIcao("lowj"))
-				.block();
+		Airport saved = template.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection)
+				.one(vie.withIcao("lowj")).block();
 		try {
-			List<Airport> found = template.findByQuery(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS)
-					.inScope(otherScope).inCollection(otherCollection).withOptions(options).all().collectList().block();
+			List<Airport> found = template.findByQuery(Airport.class).inScope(otherScope).inCollection(otherCollection)
+					.withConsistency(REQUEST_PLUS).withOptions(options).all().collectList().block();
 			assertEquals(saved.getId(), found.get(0).getId());
 		} finally {
 			template.removeById().inScope(otherScope).inCollection(otherCollection).one(saved.getId()).block();
@@ -576,8 +585,8 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 	@Test
 	public void findFromReplicasByIdOther() { // 5
 		GetAnyReplicaOptions options = GetAnyReplicaOptions.getAnyReplicaOptions().timeout(Duration.ofSeconds(10));
-		Airport saved = template.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection).one(vie.withIcao("lowk"))
-				.block();
+		Airport saved = template.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection)
+				.one(vie.withIcao("lowk")).block();
 		try {
 			Airport found = template.findFromReplicasById(Airport.class).inScope(otherScope).inCollection(otherCollection)
 					.withOptions(options).any(saved.getId()).block();
@@ -605,8 +614,8 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 	@Test
 	public void removeByIdOther() { // 7
 		RemoveOptions options = RemoveOptions.removeOptions().timeout(Duration.ofSeconds(10));
-		Airport saved = template.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection).one(vie.withIcao("lowm"))
-				.block();
+		Airport saved = template.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection)
+				.one(vie.withIcao("lowm")).block();
 		RemoveResult removeResult = template.removeById().inScope(otherScope).inCollection(otherCollection)
 				.withOptions(options).one(saved.getId()).block();
 		assertEquals(saved.getId(), removeResult.getId());
@@ -615,12 +624,11 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 	@Test
 	public void removeByQueryOther() { // 8
 		QueryOptions options = QueryOptions.queryOptions().timeout(Duration.ofSeconds(10));
-		Airport saved = template.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection).one(vie.withIcao("lown"))
-				.block();
-		List<RemoveResult> removeResults = template.removeByQuery(Airport.class)
-				.withConsistency(QueryScanConsistency.REQUEST_PLUS).inScope(otherScope).inCollection(otherCollection)
-				.withOptions(options).matching(Query.query(QueryCriteria.where("iata").is(vie.getIata()))).all().collectList()
-				.block();
+		Airport saved = template.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection)
+				.one(vie.withIcao("lown")).block();
+		List<RemoveResult> removeResults = template.removeByQuery(Airport.class).inScope(otherScope)
+				.inCollection(otherCollection).matching(Query.query(QueryCriteria.where("iata").is(vie.getIata())))
+				.withConsistency(REQUEST_PLUS).withOptions(options).all().collectList().block();
 		assertEquals(saved.getId(), removeResults.get(0).getId());
 	}
 
@@ -683,16 +691,15 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 	@Test
 	public void findByQueryOptions() { // 4
 		QueryOptions options = QueryOptions.queryOptions().timeout(Duration.ofNanos(10));
-		assertThrows(AmbiguousTimeoutException.class,
-				() -> template.findByQuery(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).inScope(otherScope)
-						.inCollection(otherCollection).withOptions(options).all().collectList().block());
+		assertThrows(AmbiguousTimeoutException.class, () -> template.findByQuery(Airport.class).inScope(otherScope)
+				.inCollection(otherCollection).withConsistency(REQUEST_PLUS).withOptions(options).all().collectList().block());
 	}
 
 	@Test
 	public void findFromReplicasByIdOptions() { // 5
 		GetAnyReplicaOptions options = GetAnyReplicaOptions.getAnyReplicaOptions().timeout(Duration.ofNanos(1000));
-		Airport saved = template.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection).one(vie)
-				.block();
+		Airport saved = template.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection)
+				.one(vie.withIcao("low712")).block();
 		try {
 			Airport found = template.findFromReplicasById(Airport.class).inScope(otherScope).inCollection(otherCollection)
 					.withOptions(options).any(saved.getId()).block();
@@ -711,8 +718,8 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 
 	@Test
 	public void removeByIdOptions() { // 7 - options
-		Airport saved = template.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection).one(vie)
-				.block();
+		Airport saved = template.insertById(Airport.class).inScope(otherScope).inCollection(otherCollection)
+				.one(vie.withIcao("732")).block();
 		RemoveOptions options = RemoveOptions.removeOptions().timeout(Duration.ofNanos(10));
 		assertThrows(AmbiguousTimeoutException.class, () -> template.removeById().inScope(otherScope)
 				.inCollection(otherCollection).withOptions(options).one(vie.getId()).block());
@@ -723,9 +730,9 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 	public void removeByQueryOptions() { // 8 - options
 		QueryOptions options = QueryOptions.queryOptions().timeout(Duration.ofNanos(10));
 		assertThrows(AmbiguousTimeoutException.class,
-				() -> template.removeByQuery(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS)
-						.inScope(otherScope).inCollection(otherCollection).withOptions(options)
-						.matching(Query.query(QueryCriteria.where("iata").is(vie.getIata()))).all().collectList().block());
+				() -> template.removeByQuery(Airport.class).inScope(otherScope).inCollection(otherCollection)
+						.matching(Query.query(QueryCriteria.where("iata").is(vie.getIata()))).withConsistency(REQUEST_PLUS)
+						.withOptions(options).all().collectList().block());
 	}
 
 	@Test
@@ -739,7 +746,7 @@ class ReactiveCouchbaseTemplateQueryCollectionIntegrationTests extends Collectio
 	public void upsertByIdOptions() { // 10 - options
 		UpsertOptions options = UpsertOptions.upsertOptions().timeout(Duration.ofNanos(10));
 		assertThrows(AmbiguousTimeoutException.class, () -> template.upsertById(Airport.class).inScope(otherScope)
-				.inCollection(otherCollection).withOptions(options).one(vie).block());
+				.inCollection(otherCollection).withOptions(options).one(vie.withIcao("760")).block());
 	}
 
 }
diff --git a/src/test/java/org/springframework/data/couchbase/domain/AbstractUser.java b/src/test/java/org/springframework/data/couchbase/domain/AbstractUser.java
new file mode 100644
index 00000000..94e41aa8
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/domain/AbstractUser.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2012-2022 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.data.couchbase.domain;
+
+import org.springframework.data.annotation.Id;
+import org.springframework.data.annotation.TypeAlias;
+import org.springframework.data.couchbase.core.mapping.Field;
+
+/**
+ * User entity for tests
+ *
+ * @author Michael Reiche
+ */
+@TypeAlias(AbstractingTypeMapper.Type.ABSTRACTUSER)
+public abstract class AbstractUser extends ComparableEntity {
+	@Id protected String id;
+	protected String firstname;
+	protected String lastname;
+	@Field(AbstractingTypeMapper.SUBTYPE) protected String subtype;
+
+	public String getId() {
+		return id;
+	}
+
+	public String getFirstname() {
+		return firstname;
+	}
+}
diff --git a/src/test/java/org/springframework/data/couchbase/domain/AbstractUserRepository.java b/src/test/java/org/springframework/data/couchbase/domain/AbstractUserRepository.java
new file mode 100644
index 00000000..1fa94d7e
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/domain/AbstractUserRepository.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2012-2022 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.data.couchbase.domain;
+
+import java.util.List;
+import java.util.stream.Stream;
+
+import org.springframework.data.couchbase.repository.CouchbaseRepository;
+import org.springframework.data.couchbase.repository.Query;
+import org.springframework.data.couchbase.repository.ScanConsistency;
+import org.springframework.data.repository.query.Param;
+import org.springframework.stereotype.Repository;
+
+import com.couchbase.client.java.json.JsonArray;
+import com.couchbase.client.java.query.QueryScanConsistency;
+
+/**
+ * AbstractUser Repository for tests
+ * 
+ * @author Michael Reiche
+ */
+@Repository
+@ScanConsistency(query = QueryScanConsistency.REQUEST_PLUS)
+public interface AbstractUserRepository extends CouchbaseRepository<AbstractUser, String> {
+
+	@Query("#{#n1ql.selectEntity} where (meta().id = $1)")
+	AbstractUser myFindById(String id);
+
+	List<AbstractUser> findByFirstname(String firstname);
+
+	Stream<User> findByLastname(String lastname);
+
+	List<User> findByFirstnameIn(String... firstnames);
+
+	List<User> findByFirstnameIn(JsonArray firstnames);
+
+	List<User> findByFirstnameAndLastname(String firstname, String lastname);
+
+	@Query("#{#n1ql.selectEntity} where #{#n1ql.filter} and firstname = $1 and lastname = $2")
+	List<User> getByFirstnameAndLastname(String firstname, String lastname);
+
+	@Query("#{#n1ql.selectEntity} where #{#n1ql.filter} and (firstname = $first or lastname = $last)")
+	List<User> getByFirstnameOrLastname(@Param("first") String firstname, @Param("last") String lastname);
+
+	List<User> findByIdIsNotNullAndFirstnameEquals(String firstname);
+
+	List<User> findByVersionEqualsAndFirstnameEquals(Long version, String firstname);
+
+}
diff --git a/src/test/java/org/springframework/data/couchbase/domain/AbstractingMappingCouchbaseConverter.java b/src/test/java/org/springframework/data/couchbase/domain/AbstractingMappingCouchbaseConverter.java
new file mode 100644
index 00000000..bde87cf2
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/domain/AbstractingMappingCouchbaseConverter.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2022 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.couchbase.domain;
+
+import org.springframework.data.couchbase.core.convert.MappingCouchbaseConverter;
+import org.springframework.data.couchbase.core.mapping.CouchbasePersistentEntity;
+import org.springframework.data.couchbase.core.mapping.CouchbasePersistentProperty;
+import org.springframework.data.mapping.context.MappingContext;
+
+/**
+ * MappingConverter that uses AbstractTypeMapper
+ *
+ * @author Michael Reiche
+ */
+public class AbstractingMappingCouchbaseConverter extends MappingCouchbaseConverter {
+
+	/**
+	 * this constructer creates a TypeBasedCouchbaseTypeMapper with the specified typeKey while MappingCouchbaseConverter
+	 * uses a DefaultCouchbaseTypeMapper typeMapper = new DefaultCouchbaseTypeMapper(typeKey != null ? typeKey :
+	 * TYPEKEY_DEFAULT);
+	 *
+	 * @param mappingContext
+	 * @param typeKey - the typeKey to be used (normally "_class")
+	 */
+	public AbstractingMappingCouchbaseConverter(
+			final MappingContext<? extends CouchbasePersistentEntity<?>, CouchbasePersistentProperty> mappingContext,
+			final String typeKey) {
+		super(mappingContext, typeKey);
+		this.typeMapper = new AbstractingTypeMapper(typeKey);
+	}
+
+}
diff --git a/src/test/java/org/springframework/data/couchbase/domain/AbstractingTypeMapper.java b/src/test/java/org/springframework/data/couchbase/domain/AbstractingTypeMapper.java
new file mode 100644
index 00000000..ea931449
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/domain/AbstractingTypeMapper.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright 2022 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.data.couchbase.domain;
+
+import java.util.Collections;
+
+import org.springframework.data.convert.DefaultTypeMapper;
+import org.springframework.data.convert.TypeAliasAccessor;
+import org.springframework.data.couchbase.core.convert.CouchbaseTypeMapper;
+import org.springframework.data.couchbase.core.mapping.CouchbaseDocument;
+import org.springframework.data.mapping.Alias;
+import org.springframework.data.mapping.context.MappingContext;
+import org.springframework.data.util.TypeInformation;
+
+/**
+ * TypeMapper that leverages subtype 
+ *
+ * @author Michael Reiche
+ */
+public class AbstractingTypeMapper extends DefaultTypeMapper<CouchbaseDocument> implements CouchbaseTypeMapper {
+
+	public static final String SUBTYPE = "subtype";
+	private final String typeKey;
+
+	public static class Type {
+		public static final String ABSTRACTUSER = "abstractuser", USER = "user", OTHERUSER = "otheruser";
+	}
+
+	/**
+	 * Create a new type mapper with the type key.
+	 *
+	 * @param typeKey the typeKey to use.
+	 */
+	public AbstractingTypeMapper(final String typeKey) {
+		super(new CouchbaseDocumentTypeAliasAccessor(typeKey), (MappingContext) null, Collections
+				.singletonList(new org.springframework.data.couchbase.core.convert.TypeAwareTypeInformationMapper()));
+		this.typeKey = typeKey;
+	}
+
+	@Override
+	public String getTypeKey() {
+		return this.typeKey;
+	}
+
+	public static final class CouchbaseDocumentTypeAliasAccessor implements TypeAliasAccessor<CouchbaseDocument> {
+
+		private final String typeKey;
+
+		public CouchbaseDocumentTypeAliasAccessor(final String typeKey) {
+			this.typeKey = typeKey;
+		}
+
+		@Override
+		public Alias readAliasFrom(final CouchbaseDocument source) {
+			String alias = (String) source.get(typeKey);
+			if (Type.ABSTRACTUSER.equals(alias)) {
+				String subtype = (String) source.get(AbstractingTypeMapper.SUBTYPE);
+				if (Type.OTHERUSER.equals(subtype)) {
+					alias = OtherUser.class.getName();
+				} else if (Type.USER.equals(subtype)) {
+					alias = User.class.getName();
+				} else {
+					throw new RuntimeException(
+							"no mapping for type " + SUBTYPE + "=" + subtype + " in type " + alias + " source=" + source);
+				}
+			}
+			return Alias.ofNullable(alias);
+		}
+
+		@Override
+		public void writeTypeTo(final CouchbaseDocument sink, final Object alias) {
+			if (typeKey != null) {
+				sink.put(typeKey, alias);
+			}
+		}
+	}
+
+	@Override
+	public Alias getTypeAlias(TypeInformation<?> info) {
+		return getAliasFor(info);
+	}
+
+}
diff --git a/src/test/java/org/springframework/data/couchbase/domain/AddressAnnotated.java b/src/test/java/org/springframework/data/couchbase/domain/AddressAnnotated.java
new file mode 100644
index 00000000..5ce10d8c
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/domain/AddressAnnotated.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2020-2022 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.data.couchbase.domain;
+
+import org.springframework.data.couchbase.repository.Collection;
+import org.springframework.data.couchbase.repository.Scope;
+
+/**
+ * @author Michael Reiche
+ */
+@Scope("dummy_scope") // set to non-existing scope. To use, scope must be determined by other means
+// a different collection
+@Collection("my_collection2")
+public class AddressAnnotated extends Address {}
diff --git a/src/test/java/org/springframework/data/couchbase/domain/Airport.java b/src/test/java/org/springframework/data/couchbase/domain/Airport.java
index 04143626..885d180c 100644
--- a/src/test/java/org/springframework/data/couchbase/domain/Airport.java
+++ b/src/test/java/org/springframework/data/couchbase/domain/Airport.java
@@ -35,7 +35,7 @@ import javax.validation.constraints.Max;
 @Document
 @TypeAlias("airport")
 public class Airport extends ComparableEntity {
-	@Id String id;
+	@Id String key;
 
 	String iata;
 
@@ -47,16 +47,17 @@ public class Airport extends ComparableEntity {
 	@Expiration private long expiration;
 	@Max(2)
 	long size;
+	private long someNumber;
 
 	@PersistenceConstructor
-	public Airport(String id, String iata, String icao) {
-		this.id = id;
+	public Airport(String key, String iata, String icao) {
+		this.key = key;
 		this.iata = iata;
 		this.icao = icao;
 	}
 
 	public String getId() {
-		return id;
+		return key;
 	}
 
 	public String getIata() {
diff --git a/src/test/java/org/springframework/data/couchbase/domain/AirportRepository.java b/src/test/java/org/springframework/data/couchbase/domain/AirportRepository.java
index 327557bd..20438285 100644
--- a/src/test/java/org/springframework/data/couchbase/domain/AirportRepository.java
+++ b/src/test/java/org/springframework/data/couchbase/domain/AirportRepository.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2021 the original author or authors.
+ * Copyright 2017-2022 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -39,10 +39,12 @@ import org.springframework.data.couchbase.repository.ScanConsistency;
 import org.springframework.data.couchbase.repository.Scope;
 import org.springframework.data.domain.Page;
 import org.springframework.data.domain.Pageable;
+import org.springframework.data.domain.Slice;
 import org.springframework.data.repository.query.Param;
 import org.springframework.stereotype.Repository;
 
 import com.couchbase.client.java.analytics.AnalyticsScanConsistency;
+import com.couchbase.client.java.json.JsonArray;
 import com.couchbase.client.java.query.QueryScanConsistency;
 
 /**
@@ -60,6 +62,11 @@ import com.couchbase.client.java.query.QueryScanConsistency;
 // @ScanConsistency(query = QueryScanConsistency.REQUEST_PLUS)
 public interface AirportRepository extends CouchbaseRepository<Airport, String>, DynamicProxyable<AirportRepository> {
 
+	@ScanConsistency(query = QueryScanConsistency.REQUEST_PLUS)
+	List<Airport> findByIataInAndIcaoIn(java.util.Collection<String> size, java.util.Collection<String> color,
+			Pageable pageable);
+
+	// override an annotate with REQUEST_PLUS
 	@Override
 	@ScanConsistency(query = QueryScanConsistency.REQUEST_PLUS)
 	List<Airport> findAll();
@@ -77,6 +84,21 @@ public interface AirportRepository extends CouchbaseRepository<Airport, String>,
 	@ScanConsistency(query = QueryScanConsistency.REQUEST_PLUS)
 	Airport findByIata(Iata iata);
 
+	@ScanConsistency(query = QueryScanConsistency.REQUEST_PLUS)
+	Airport findByIataIn(java.util.Collection<Iata> iatas);
+
+	@ScanConsistency(query = QueryScanConsistency.REQUEST_PLUS)
+	Airport findByIataIn(Iata... iatas);
+
+	@ScanConsistency(query = QueryScanConsistency.REQUEST_PLUS)
+	Airport findByIataIn(JsonArray iatas);
+
+	@Query("Select \"\" AS __id, 0 AS __cas, substr(iata,0,1) as iata, count(*) as someNumber FROM #{#n1ql.bucket} WHERE #{#n1ql.filter} GROUP BY substr(iata,0,1)")
+	List<Airport> groupByIata();
+
+	@ScanConsistency(query = QueryScanConsistency.REQUEST_PLUS)
+	Airport findArchivedByIata(Iata iata);
+
 	// NOT_BOUNDED to test ScanConsistency
 	// @ScanConsistency(query = QueryScanConsistency.NOT_BOUNDED)
 	Airport iata(String iata);
@@ -89,11 +111,11 @@ public interface AirportRepository extends CouchbaseRepository<Airport, String>,
 	@ScanConsistency(query = QueryScanConsistency.REQUEST_PLUS)
 	List<RemoveResult> deleteByIata(String iata);
 
-	@Query("SELECT __cas, * from `#{#n1ql.bucket}` where iata = $1")
+	@Query("SELECT __cas, * from #{#n1ql.bucket} where iata = $1")
 	@ScanConsistency(query = QueryScanConsistency.REQUEST_PLUS)
 	List<Airport> getAllByIataNoID(String iata);
 
-	@Query("SELECT __id, * from `#{#n1ql.bucket}` where iata = $1")
+	@Query("SELECT __id, * from #{#n1ql.bucket} where iata = $1")
 	@ScanConsistency(query = QueryScanConsistency.REQUEST_PLUS)
 	List<Airport> getAllByIataNoCAS(String iata);
 
@@ -116,10 +138,10 @@ public interface AirportRepository extends CouchbaseRepository<Airport, String>,
 	Long countFancyExpression(@Param("projectIds") List<String> projectIds, @Param("planIds") List<String> planIds,
 			@Param("active") Boolean active);
 
-	@Query("SELECT 1 FROM `#{#n1ql.bucket}` WHERE anything = 'count(*)'") // looks like count query, but is not
+	@Query("SELECT 1 FROM #{#n1ql.bucket} WHERE anything = 'count(*)'") // looks like count query, but is not
 	Long countBad();
 
-	@Query("SELECT count(*) FROM `#{#n1ql.bucket}`")
+	@Query("SELECT count(*) FROM #{#n1ql.bucket}")
 	Long countGood();
 
 	@ScanConsistency(query = QueryScanConsistency.REQUEST_PLUS)
@@ -129,6 +151,18 @@ public interface AirportRepository extends CouchbaseRepository<Airport, String>,
 	@Query("#{#n1ql.selectEntity} WHERE #{#n1ql.filter} AND iata != $1")
 	Page<Airport> getAllByIataNot(String iata, Pageable pageable);
 
+	@ScanConsistency(query = QueryScanConsistency.REQUEST_PLUS)
+	@Query("SELECT iata, \"\" as __id, 0 as __cas from #{#n1ql.bucket} WHERE #{#n1ql.filter} order by meta().id")
+	List<String> getStrings();
+
+	@ScanConsistency(query = QueryScanConsistency.REQUEST_PLUS)
+	@Query("SELECT length(iata), \"\" as __id, 0 as __cas from #{#n1ql.bucket} WHERE #{#n1ql.filter} order by meta().id")
+	List<Long> getLongs();
+
+	@ScanConsistency(query = QueryScanConsistency.REQUEST_PLUS)
+	@Query("SELECT iata, icao, \"\" as __id, 0 as __cas from #{#n1ql.bucket} WHERE #{#n1ql.filter} order by meta().id")
+	List<String[]> getStringArrays();
+
 	@ScanConsistency(query = QueryScanConsistency.REQUEST_PLUS)
 	Optional<Airport> findByIdAndIata(String id, String iata);
 
@@ -144,10 +178,19 @@ public interface AirportRepository extends CouchbaseRepository<Airport, String>,
 	@ScanConsistency(query = QueryScanConsistency.REQUEST_PLUS)
 	Long countDistinctIcaoBy();
 
-	@Query("SELECT 1 FROM `#{#n1ql.bucket}` WHERE #{#n1ql.filter} " + " #{#projectIds != null ? 'AND blah IN $1' : ''} "
+	@Query("SELECT 1 FROM #{#n1ql.bucket} WHERE #{#n1ql.filter} " + " #{#projectIds != null ? 'AND blah IN $1' : ''} "
 			+ " #{#planIds != null ? 'AND blahblah IN $2' : ''} " + " #{#active != null ? 'AND false = $3' : ''} ")
 	Long countOne();
 
+	@ScanConsistency(query = QueryScanConsistency.REQUEST_PLUS)
+	Airport findByKey(String id);
+
+	@Query("#{#n1ql.selectEntity} WHERE #{#n1ql.filter} AND iata  between $1 and $2")
+	Slice<Airport> fetchSlice(String startIata, String iata, Pageable pageable);
+
+	@Query("#{#n1ql.selectEntity} WHERE #{#n1ql.filter} AND iata  between $1 and $2")
+	Page<Airport> fetchPage(String startIata, String iata, Pageable pageable);
+
 	@Retention(RetentionPolicy.RUNTIME)
 	@Target({ ElementType.METHOD, ElementType.TYPE })
 	// @Meta
diff --git a/src/test/java/org/springframework/data/couchbase/domain/CollectionsConfig.java b/src/test/java/org/springframework/data/couchbase/domain/CollectionsConfig.java
new file mode 100644
index 00000000..ae3588c9
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/domain/CollectionsConfig.java
@@ -0,0 +1,8 @@
+package org.springframework.data.couchbase.domain;
+
+public class CollectionsConfig extends Config {
+ @Override
+  public String getScopeName(){
+   return "my_scope";
+ }
+}
diff --git a/src/test/java/org/springframework/data/couchbase/domain/Config.java b/src/test/java/org/springframework/data/couchbase/domain/Config.java
index bfedc1b9..debe255f 100644
--- a/src/test/java/org/springframework/data/couchbase/domain/Config.java
+++ b/src/test/java/org/springframework/data/couchbase/domain/Config.java
@@ -17,12 +17,18 @@
 package org.springframework.data.couchbase.domain;
 
 import java.lang.reflect.InvocationTargetException;
+import java.util.HashMap;
+import java.util.Map;
 
+import org.springframework.cache.annotation.EnableCaching;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 import org.springframework.data.auditing.DateTimeProvider;
 import org.springframework.data.couchbase.CouchbaseClientFactory;
+import org.springframework.data.couchbase.ReactiveCouchbaseClientFactory;
 import org.springframework.data.couchbase.SimpleCouchbaseClientFactory;
+import org.springframework.data.couchbase.cache.CouchbaseCacheConfiguration;
+import org.springframework.data.couchbase.cache.CouchbaseCacheManager;
 import org.springframework.data.couchbase.config.AbstractCouchbaseConfiguration;
 import org.springframework.data.couchbase.core.CouchbaseTemplate;
 import org.springframework.data.couchbase.core.ReactiveCouchbaseTemplate;
@@ -53,9 +59,9 @@ import com.couchbase.client.java.json.JacksonTransformers;
 @EnableReactiveCouchbaseRepositories
 @EnableCouchbaseAuditing(dateTimeProviderRef = "dateTimeProviderRef")
 @EnableReactiveCouchbaseAuditing(dateTimeProviderRef = "dateTimeProviderRef")
-
+@EnableCaching
 public class Config extends AbstractCouchbaseConfiguration {
-	String bucketname = "travel-sample";
+	String bucketname = "test";
 	String username = "Administrator";
 	String password = "password";
 	String connectionString = "127.0.0.1";
@@ -154,18 +160,16 @@ public class Config extends AbstractCouchbaseConfiguration {
 
 	// do not use reactiveCouchbaseTemplate for the name of this method, otherwise the value of that bean
 	// will be used instead of the result of this call (the client factory arg is different)
-	public ReactiveCouchbaseTemplate myReactiveCouchbaseTemplate(CouchbaseClientFactory couchbaseClientFactory,
+	public ReactiveCouchbaseTemplate myReactiveCouchbaseTemplate(ReactiveCouchbaseClientFactory reactiveCouchbaseClientFactory,
 																 MappingCouchbaseConverter mappingCouchbaseConverter) {
-		return new ReactiveCouchbaseTemplate(couchbaseClientFactory, mappingCouchbaseConverter,
-				new JacksonTranslationService(), getDefaultConsistency());
+		return new ReactiveCouchbaseTemplate(reactiveCouchbaseClientFactory, mappingCouchbaseConverter, new JacksonTranslationService(), getDefaultConsistency());
 	}
 
 	// do not use couchbaseTemplate for the name of this method, otherwise the value of that been
 	// will be used instead of the result from this call (the client factory arg is different)
-	public CouchbaseTemplate myCouchbaseTemplate(CouchbaseClientFactory couchbaseClientFactory,
+	public CouchbaseTemplate myCouchbaseTemplate(CouchbaseClientFactory couchbaseClientFactory, ReactiveCouchbaseClientFactory reactiveCouchbaseClientFactory,
 												 MappingCouchbaseConverter mappingCouchbaseConverter) {
-		return new CouchbaseTemplate(couchbaseClientFactory, mappingCouchbaseConverter, new JacksonTranslationService(),
-				getDefaultConsistency());
+		return new CouchbaseTemplate(couchbaseClientFactory, reactiveCouchbaseClientFactory, mappingCouchbaseConverter, new JacksonTranslationService(), getDefaultConsistency());
 	}
 
 	// do not use couchbaseClientFactory for the name of this method, otherwise the value of that bean will
@@ -214,20 +218,26 @@ public class Config extends AbstractCouchbaseConfiguration {
 		return jacksonTranslationService;
 	}
 
+	@Bean
+	public CouchbaseCacheManager cacheManager(CouchbaseTemplate couchbaseTemplate) throws Exception {
+		CouchbaseCacheManager.CouchbaseCacheManagerBuilder builder = CouchbaseCacheManager.CouchbaseCacheManagerBuilder
+				.fromConnectionFactory(couchbaseTemplate.getCouchbaseClientFactory());
+		return builder.build();
+	}
+
 	@Override
 	public String typeKey() {
 		return "t"; // this will override '_class', is passed in to new CustomMappingCouchbaseConverter
 	}
 
-	static String scopeName = null;
-
 	@Override
 	protected String getScopeName() {
 		return scopeName;
 	}
 
-	public static void setScopeName(String scopeName) {
+	static public void setScopeName(String scopeName){
 		Config.scopeName = scopeName;
 	}
 
+	static private String scopeName = null;
 }
diff --git a/src/test/java/org/springframework/data/couchbase/domain/FluxTest.java b/src/test/java/org/springframework/data/couchbase/domain/FluxTest.java
index 634f4c9a..b16f2810 100644
--- a/src/test/java/org/springframework/data/couchbase/domain/FluxTest.java
+++ b/src/test/java/org/springframework/data/couchbase/domain/FluxTest.java
@@ -1,3 +1,18 @@
+/*
+ * Copyright 2021 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package org.springframework.data.couchbase.domain;
 
 import com.couchbase.client.java.query.QueryOptions;
@@ -5,6 +20,7 @@ import com.couchbase.client.java.query.QueryProfile;
 import com.couchbase.client.java.query.QueryResult;
 import com.couchbase.client.java.query.QueryScanConsistency;
 import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.AfterEach;
 import org.springframework.context.ApplicationContext;
 import org.springframework.context.annotation.AnnotationConfigApplicationContext;
 import org.springframework.data.couchbase.config.BeanNames;
@@ -27,29 +43,52 @@ import java.util.Random;
 import java.util.UUID;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.junit.jupiter.api.AfterAll;
 import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.ApplicationContext;
+import org.springframework.context.annotation.AnnotationConfigApplicationContext;
 import org.springframework.context.annotation.Configuration;
 import org.springframework.data.couchbase.config.AbstractCouchbaseConfiguration;
+import org.springframework.data.couchbase.config.BeanNames;
+import org.springframework.data.couchbase.core.CouchbaseTemplate;
+import org.springframework.data.couchbase.core.ReactiveCouchbaseTemplate;
+import org.springframework.data.couchbase.core.RemoveResult;
 import org.springframework.data.couchbase.repository.config.EnableReactiveCouchbaseRepositories;
+import org.springframework.data.couchbase.util.Capabilities;
+import org.springframework.data.couchbase.util.ClusterType;
+import org.springframework.data.couchbase.util.IgnoreWhen;
 import org.springframework.data.couchbase.util.JavaIntegrationTests;
+import org.springframework.data.util.Pair;
 import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
 
 import com.couchbase.client.java.Collection;
 import com.couchbase.client.java.ReactiveCollection;
 import com.couchbase.client.java.json.JsonObject;
 import com.couchbase.client.java.kv.GetResult;
+import com.couchbase.client.java.query.QueryOptions;
+import com.couchbase.client.java.query.QueryProfile;
+import com.couchbase.client.java.query.QueryResult;
+import com.couchbase.client.java.query.QueryScanConsistency;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 
+/**
+ * @author Michael Reiche
+ */
 @SpringJUnitConfig(FluxTest.Config.class)
 @IgnoreWhen(clusterTypes = ClusterType.MOCKED)
 public class FluxTest extends JavaIntegrationTests {
 
-	@BeforeAll
-	public static void beforeEverything() {
+	@Autowired public CouchbaseTemplate couchbaseTemplate;
+	@Autowired public ReactiveCouchbaseTemplate reactiveCouchbaseTemplate;
+
+	@BeforeEach
+	@Override
+	public void beforeEach() {
+
 		/**
 		 * The couchbaseTemplate inherited from JavaIntegrationTests uses org.springframework.data.couchbase.domain.Config
 		 * It has typeName = 't' (instead of _class). Don't use it.
@@ -63,18 +102,17 @@ public class FluxTest extends JavaIntegrationTests {
 			couchbaseTemplate.getCouchbaseClientFactory().getBucket().defaultCollection().upsert(k,
 					JsonObject.create().put("x", k));
 		}
+		super.beforeEach();
 	}
 
-	@AfterAll
-	public static void afterEverthing() {
+	@AfterEach
+	public void afterEach() {
 		couchbaseTemplate.removeByQuery(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).all();
 		couchbaseTemplate.findByQuery(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).all();
+		super.afterEach();
+		for (String k : keyList) {
+			couchbaseTemplate.getCouchbaseClientFactory().getBucket().defaultCollection().remove(k);
 		}
-
-	@BeforeEach
-	@Override
-	public void beforeEach() {
-		super.beforeEach();
 	}
 
 	static List<String> keyList = Arrays.asList("a", "b", "c", "d", "e");
diff --git a/src/test/java/org/springframework/data/couchbase/domain/OtherUser.java b/src/test/java/org/springframework/data/couchbase/domain/OtherUser.java
new file mode 100644
index 00000000..4829ed45
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/domain/OtherUser.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2022 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.data.couchbase.domain;
+
+import org.springframework.data.annotation.PersistenceConstructor;
+import org.springframework.data.annotation.TypeAlias;
+import org.springframework.data.couchbase.core.mapping.Document;
+
+/**
+ * OtherUser entity for tests. Both User and OtherUser extend AbstractUser
+ *
+ * @author Michael Reiche
+ */
+
+@Document
+@TypeAlias(AbstractingTypeMapper.Type.ABSTRACTUSER)
+public class OtherUser extends AbstractUser {
+
+	@PersistenceConstructor
+	public OtherUser(final String id, final String firstname, final String lastname) {
+		this.id = id;
+		this.firstname = firstname;
+		this.lastname = lastname;
+		this.subtype = AbstractingTypeMapper.Type.OTHERUSER;
+	}
+
+}
diff --git a/src/test/java/org/springframework/data/couchbase/domain/Person.java b/src/test/java/org/springframework/data/couchbase/domain/Person.java
index eb2a4dd7..376cdc7e 100644
--- a/src/test/java/org/springframework/data/couchbase/domain/Person.java
+++ b/src/test/java/org/springframework/data/couchbase/domain/Person.java
@@ -22,13 +22,17 @@ import org.springframework.data.annotation.CreatedBy;
 import org.springframework.data.annotation.CreatedDate;
 import org.springframework.data.annotation.LastModifiedBy;
 import org.springframework.data.annotation.LastModifiedDate;
+import org.springframework.data.annotation.Transient;
 import org.springframework.data.annotation.Version;
 import org.springframework.data.couchbase.core.mapping.Document;
 import org.springframework.data.couchbase.core.mapping.Field;
+import org.springframework.data.couchbase.repository.TransactionResult;
+import org.springframework.data.couchbase.repository.support.TransactionResultHolder;
+import org.springframework.data.domain.Persistable;
 import org.springframework.lang.Nullable;
 
 @Document
-public class Person extends AbstractEntity {
+public class Person extends AbstractEntity implements Persistable<Object> {
 	Optional<String> firstname;
 	@Nullable Optional<String> lastname;
 
@@ -47,6 +51,11 @@ public class Person extends AbstractEntity {
 
 	private Address address;
 
+	// Required for use in transactions
+	@TransactionResult private Integer txResultHolder;
+	@Transient private boolean isNew;
+
+
 	public Person() {}
 
 	public Person(String firstname, String lastname) {
@@ -54,6 +63,7 @@ public class Person extends AbstractEntity {
 		setFirstname(firstname);
 		setLastname(lastname);
 		setMiddlename("Nick");
+		isNew(true);
 	}
 
 	public Person(int id, String firstname, String lastname) {
@@ -61,19 +71,24 @@ public class Person extends AbstractEntity {
 		setId(new UUID(id, id));
 	}
 
+	public Person(UUID id, String firstname, String lastname) {
+		this(firstname, lastname);
+		setId(id);
+	}
+
 	static String optional(String name, Optional<String> obj) {
 		if (obj != null) {
 			if (obj.isPresent()) {
-				return ("  " + name + ": '" + obj.get() + "'\n");
+				return ("  " + name + ": '" + obj.get() + "'");
 			} else {
-				return "  " + name + ": null\n";
+				return "  " + name + ": null";
 			}
 		}
 		return "";
 	}
 
-	public Optional<String> getFirstname() {
-		return firstname;
+	public String getFirstname() {
+		return firstname.get();
 	}
 
 	public void setFirstname(String firstname) {
@@ -84,8 +99,8 @@ public class Person extends AbstractEntity {
 		this.firstname = firstname;
 	}
 
-	public Optional<String> getLastname() {
-		return lastname;
+	public String getLastname() {
+		return lastname.get();
 	}
 
 	public void setLastname(String lastname) {
@@ -131,7 +146,7 @@ public class Person extends AbstractEntity {
 		sb.append(optional(", firstname", firstname));
 		sb.append(optional(", lastname", lastname));
 		if (middlename != null)
-			sb.append(", middlename : " + middlename);
+			sb.append(", middlename : '" + middlename + "'");
 		sb.append(", version : " + version);
 		if (creator != null) {
 			sb.append(", creator : " + creator);
@@ -148,8 +163,43 @@ public class Person extends AbstractEntity {
 		if (getAddress() != null) {
 			sb.append(", address : " + getAddress().toString());
 		}
-		sb.append("}");
+		sb.append("\n}");
 		return sb.toString();
 	}
 
+	public Person withFirstName(String firstName) {
+		Person p = new Person(this.getId(), firstName, this.getLastname());
+		p.version = version;
+		p.txResultHolder = this.txResultHolder;
+		return p;
+	}
+
+	public Person withVersion(Long version) {
+		//Person p = new Person(this.getId(), this.getFirstname(), this.getLastname());
+		this.version = version;
+		return this;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj) {
+			return true;
+		}
+		if (!super.equals(obj)) {
+			return false;
+		}
+
+		Person that = (Person) obj;
+		return this.getId().equals(that.getId()) && this.getFirstname().equals(that.getFirstname())
+				&& this.getLastname().equals(that.getLastname()) && this.getMiddlename().equals(that.getMiddlename());
+	}
+
+	@Override
+	public boolean isNew() {
+		return isNew;
+	}
+
+	public void isNew(boolean isNew){
+		this.isNew = isNew;
+	}
 }
diff --git a/src/test/java/org/springframework/data/couchbase/domain/PersonRepository.java b/src/test/java/org/springframework/data/couchbase/domain/PersonRepository.java
index 2c9985d7..b6f23ebe 100644
--- a/src/test/java/org/springframework/data/couchbase/domain/PersonRepository.java
+++ b/src/test/java/org/springframework/data/couchbase/domain/PersonRepository.java
@@ -18,9 +18,10 @@ package org.springframework.data.couchbase.domain;
 import java.util.List;
 import java.util.UUID;
 
+import org.springframework.data.couchbase.repository.CouchbaseRepository;
+import org.springframework.data.couchbase.repository.DynamicProxyable;
 import org.springframework.data.couchbase.repository.Query;
 import org.springframework.data.couchbase.repository.ScanConsistency;
-import org.springframework.data.repository.CrudRepository;
 import org.springframework.data.repository.query.Param;
 
 import com.couchbase.client.java.query.QueryScanConsistency;
@@ -28,7 +29,7 @@ import com.couchbase.client.java.query.QueryScanConsistency;
 /**
  * @author Michael Reiche
  */
-public interface PersonRepository extends CrudRepository<Person, String> {
+public interface PersonRepository extends CouchbaseRepository<Person, String>, DynamicProxyable<PersonRepository> {
 
 	/*
 	 * These methods are exercised in HomeController of the test spring-boot DemoApplication
@@ -95,7 +96,7 @@ public interface PersonRepository extends CrudRepository<Person, String> {
 
 	boolean existsById(UUID var1);
 
-	Iterable<Person> findAll();
+	List<Person> findAll();
 
 	long count();
 
diff --git a/src/test/java/org/springframework/data/couchbase/domain/PersonWithoutVersion.java b/src/test/java/org/springframework/data/couchbase/domain/PersonWithoutVersion.java
new file mode 100644
index 00000000..4aa46ed8
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/domain/PersonWithoutVersion.java
@@ -0,0 +1,190 @@
+/*
+ * Copyright 2012-2021 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.couchbase.domain;
+
+import org.springframework.data.annotation.CreatedBy;
+import org.springframework.data.annotation.CreatedDate;
+import org.springframework.data.annotation.LastModifiedBy;
+import org.springframework.data.annotation.LastModifiedDate;
+import org.springframework.data.annotation.Transient;
+import org.springframework.data.annotation.Version;
+import org.springframework.data.couchbase.core.mapping.Document;
+import org.springframework.data.couchbase.core.mapping.Field;
+import org.springframework.data.couchbase.repository.TransactionResult;
+import org.springframework.data.domain.Persistable;
+import org.springframework.lang.Nullable;
+
+import java.util.Optional;
+import java.util.UUID;
+
+// todo gpx: lame to C&P the entire Person, but struggling to get a simpler entity working
+@Document
+public class PersonWithoutVersion extends AbstractEntity implements Persistable<Object> {
+	Optional<String> firstname;
+	@Nullable Optional<String> lastname;
+
+	@CreatedBy private String creator;
+
+	@LastModifiedBy private String lastModifiedBy;
+
+	@LastModifiedDate private long lastModification;
+
+	@CreatedDate private long creationDate;
+
+	@Nullable @Field("nickname") private String middlename;
+	@Nullable @Field(name = "prefix") private String salutation;
+
+	private Address address;
+
+	// Required for use in transactions
+	@TransactionResult private Integer txResultHolder;
+	@Transient private boolean isNew;
+
+
+	public PersonWithoutVersion() {}
+
+	public PersonWithoutVersion(String firstname, String lastname) {
+		this();
+		setFirstname(firstname);
+		setLastname(lastname);
+		setMiddlename("Nick");
+		isNew(true);
+	}
+
+	public PersonWithoutVersion(int id, String firstname, String lastname) {
+		this(firstname, lastname);
+		setId(new UUID(id, id));
+	}
+
+	public PersonWithoutVersion(UUID id, String firstname, String lastname) {
+		this(firstname, lastname);
+		setId(id);
+	}
+
+	static String optional(String name, Optional<String> obj) {
+		if (obj != null) {
+			if (obj.isPresent()) {
+				return ("  " + name + ": '" + obj.get() + "'");
+			} else {
+				return "  " + name + ": null";
+			}
+		}
+		return "";
+	}
+
+	public String getFirstname() {
+		return firstname.get();
+	}
+
+	public void setFirstname(String firstname) {
+		this.firstname = firstname == null ? null : (Optional.ofNullable(firstname.equals("") ? null : firstname));
+	}
+
+	public void setFirstname(Optional<String> firstname) {
+		this.firstname = firstname;
+	}
+
+	public String getLastname() {
+		return lastname.get();
+	}
+
+	public void setLastname(String lastname) {
+		this.lastname = lastname == null ? null : (Optional.ofNullable(lastname.equals("") ? null : lastname));
+	}
+
+	public void setLastname(Optional lastname) {
+		this.lastname = lastname;
+	}
+
+	public String getMiddlename() {
+		return middlename;
+	}
+
+	public String getSalutation() {
+		return salutation;
+	}
+
+	public void setMiddlename(String middlename) {
+		this.middlename = middlename;
+	}
+
+	public void setSalutation(String salutation) {
+		this.salutation = salutation;
+	}
+
+	public Address getAddress() {
+		return address;
+	}
+
+	public void setAddress(Address address) {
+		this.address = address;
+	}
+
+	public String toString() {
+		StringBuilder sb = new StringBuilder();
+		sb.append("Person : {\n");
+		sb.append("  id : " + getId());
+		sb.append(optional(", firstname", firstname));
+		sb.append(optional(", lastname", lastname));
+		if (middlename != null)
+			sb.append(", middlename : '" + middlename + "'");
+		if (creator != null) {
+			sb.append(", creator : " + creator);
+		}
+		if (creationDate != 0) {
+			sb.append(", creationDate : " + creationDate);
+		}
+		if (lastModifiedBy != null) {
+			sb.append(", lastModifiedBy : " + lastModifiedBy);
+		}
+		if (lastModification != 0) {
+			sb.append(", lastModification : " + lastModification);
+		}
+		if (getAddress() != null) {
+			sb.append(", address : " + getAddress().toString());
+		}
+		sb.append("\n}");
+		return sb.toString();
+	}
+
+	public PersonWithoutVersion withFirstName(String firstName) {
+		PersonWithoutVersion p = new PersonWithoutVersion(this.getId(), firstName, this.getLastname());
+		p.txResultHolder = this.txResultHolder;
+		return p;
+	}
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj) {
+			return true;
+		}
+		if (!super.equals(obj)) {
+			return false;
+		}
+
+		PersonWithoutVersion that = (PersonWithoutVersion) obj;
+		return this.getId().equals(that.getId()) && this.getFirstname().equals(that.getFirstname())
+				&& this.getLastname().equals(that.getLastname()) && this.getMiddlename().equals(that.getMiddlename());
+	}
+
+	@Override
+	public boolean isNew() {
+		return isNew;
+	}
+
+	public void isNew(boolean isNew){
+		this.isNew = isNew;
+	}
+}
diff --git a/src/test/java/org/springframework/data/couchbase/domain/ReactiveAirlineRepository.java b/src/test/java/org/springframework/data/couchbase/domain/ReactiveAirlineRepository.java
new file mode 100644
index 00000000..55acd182
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/domain/ReactiveAirlineRepository.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2012-2020 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.data.couchbase.domain;
+
+import org.springframework.data.couchbase.repository.Query;
+import org.springframework.data.repository.query.Param;
+import reactor.core.publisher.Flux;
+
+import org.springframework.data.repository.reactive.ReactiveSortingRepository;
+import org.springframework.stereotype.Repository;
+
+import java.util.List;
+
+/**
+ * @author Michael Reiche
+ */
+@Repository
+public interface ReactiveAirlineRepository extends ReactiveSortingRepository<Airline, String> {
+
+	@Query("#{#n1ql.selectEntity} where #{#n1ql.filter} and (name = $1)")
+	List<User> getByName(@Param("airline_name")String airlineName);
+
+}
diff --git a/src/test/java/org/springframework/data/couchbase/domain/ReactiveAirportRepository.java b/src/test/java/org/springframework/data/couchbase/domain/ReactiveAirportRepository.java
index 59426ec2..a5851e8e 100644
--- a/src/test/java/org/springframework/data/couchbase/domain/ReactiveAirportRepository.java
+++ b/src/test/java/org/springframework/data/couchbase/domain/ReactiveAirportRepository.java
@@ -16,6 +16,8 @@
 
 package org.springframework.data.couchbase.domain;
 
+import lombok.val;
+import org.springframework.data.couchbase.core.query.WithConsistency;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 
@@ -44,6 +46,11 @@ import com.couchbase.client.java.query.QueryScanConsistency;
 public interface ReactiveAirportRepository
 		extends ReactiveCouchbaseRepository<Airport, String>, DynamicProxyable<ReactiveAirportRepository> {
 
+
+	@Query("SELECT META(#{#n1ql.bucket}).id AS __id, META(#{#n1ql.bucket}).cas AS __cas, meta().id as id FROM #{#n1ql.bucket} WHERE #{#n1ql.filter} #{[1]}")
+	@ScanConsistency(query=QueryScanConsistency.REQUEST_PLUS)
+	Flux<String> findIdByDynamicN1ql(String docType, String queryStatement);
+
 	@Override
 	@ScanConsistency(query = QueryScanConsistency.REQUEST_PLUS)
 	Flux<Airport> findAll();
diff --git a/src/test/java/org/springframework/data/couchbase/domain/ReactivePersonRepository.java b/src/test/java/org/springframework/data/couchbase/domain/ReactivePersonRepository.java
new file mode 100644
index 00000000..e2866651
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/domain/ReactivePersonRepository.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2012-2021 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.couchbase.domain;
+
+import org.springframework.data.couchbase.repository.DynamicProxyable;
+import org.springframework.data.couchbase.repository.ReactiveCouchbaseRepository;
+
+/**
+ * @author Michael Reiche
+ */
+public interface ReactivePersonRepository
+		extends ReactiveCouchbaseRepository<Person, String>, DynamicProxyable<ReactivePersonRepository> {
+
+}
diff --git a/src/test/java/org/springframework/data/couchbase/domain/User.java b/src/test/java/org/springframework/data/couchbase/domain/User.java
index d005e7a9..5a841edb 100644
--- a/src/test/java/org/springframework/data/couchbase/domain/User.java
+++ b/src/test/java/org/springframework/data/couchbase/domain/User.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2020 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,15 +16,16 @@
 
 package org.springframework.data.couchbase.domain;
 
+import java.io.Serializable;
 import java.util.Objects;
 
 import org.springframework.data.annotation.CreatedBy;
 import org.springframework.data.annotation.CreatedDate;
-import org.springframework.data.annotation.Id;
 import org.springframework.data.annotation.LastModifiedBy;
 import org.springframework.data.annotation.LastModifiedDate;
 import org.springframework.data.annotation.PersistenceConstructor;
 import org.springframework.data.annotation.Transient;
+import org.springframework.data.annotation.TypeAlias;
 import org.springframework.data.annotation.Version;
 import org.springframework.data.couchbase.core.mapping.Document;
 
@@ -36,32 +37,23 @@ import org.springframework.data.couchbase.core.mapping.Document;
  */
 
 @Document
-public class User extends ComparableEntity {
-
-	@Version long version;
-	@Id private String id;
-	private String firstname;
-	private String lastname;
-	@Transient private String transientInfo;
-	@CreatedBy private String createdBy;
-	@CreatedDate private long createdDate;
-	@LastModifiedBy private String lastModifiedBy;
-	@LastModifiedDate private long lastModifiedDate;
+@TypeAlias(AbstractingTypeMapper.Type.ABSTRACTUSER)
+public class User extends AbstractUser implements Serializable {
 
 	@PersistenceConstructor
 	public User(final String id, final String firstname, final String lastname) {
 		this.id = id;
 		this.firstname = firstname;
 		this.lastname = lastname;
+		this.subtype = AbstractingTypeMapper.Type.USER;
 	}
 
-	public String getId() {
-		return id;
-	}
-
-	public String getFirstname() {
-		return firstname;
-	}
+	@Version protected long version;
+	@Transient protected String transientInfo;
+	@CreatedBy protected String createdBy;
+	@CreatedDate protected long createdDate;
+	@LastModifiedBy protected String lastModifiedBy;
+	@LastModifiedDate protected long lastModifiedDate;
 
 	public String getLastname() {
 		return lastname;
@@ -101,7 +93,7 @@ public class User extends ComparableEntity {
 
 	@Override
 	public int hashCode() {
-		return Objects.hash(id, firstname, lastname);
+		return Objects.hash(getId(), firstname, lastname);
 	}
 
 	public String getTransientInfo() {
@@ -111,4 +103,5 @@ public class User extends ComparableEntity {
 	public void setTransientInfo(String something) {
 		transientInfo = something;
 	}
+
 }
diff --git a/src/test/java/org/springframework/data/couchbase/domain/UserColRepository.java b/src/test/java/org/springframework/data/couchbase/domain/UserColRepository.java
index 412a5755..794186f0 100644
--- a/src/test/java/org/springframework/data/couchbase/domain/UserColRepository.java
+++ b/src/test/java/org/springframework/data/couchbase/domain/UserColRepository.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2020 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -44,6 +44,9 @@ public interface UserColRepository extends CouchbaseRepository<UserCol, String>,
 
 	List<UserCol> findByFirstname(String firstname);
 
+	@ScanConsistency(query = QueryScanConsistency.REQUEST_PLUS)
+	UserCol getById(String id);
+
 	List<UserCol> findByFirstnameIn(String... firstnames);
 
 	List<UserCol> findByFirstnameIn(JsonArray firstnames);
diff --git a/src/test/java/org/springframework/data/couchbase/domain/UserRepository.java b/src/test/java/org/springframework/data/couchbase/domain/UserRepository.java
index 229ae00c..31b5eab3 100644
--- a/src/test/java/org/springframework/data/couchbase/domain/UserRepository.java
+++ b/src/test/java/org/springframework/data/couchbase/domain/UserRepository.java
@@ -19,7 +19,7 @@ package org.springframework.data.couchbase.domain;
 import java.util.List;
 import java.util.stream.Stream;
 
-import com.couchbase.client.java.query.QueryScanConsistency;
+import org.springframework.cache.annotation.Cacheable;
 import org.springframework.data.couchbase.repository.CouchbaseRepository;
 import org.springframework.data.couchbase.repository.Query;
 import org.springframework.data.couchbase.repository.ScanConsistency;
@@ -27,6 +27,7 @@ import org.springframework.data.repository.query.Param;
 import org.springframework.stereotype.Repository;
 
 import com.couchbase.client.java.json.JsonArray;
+import com.couchbase.client.java.query.QueryScanConsistency;
 
 /**
  * User Repository for tests
@@ -57,4 +58,13 @@ public interface UserRepository extends CouchbaseRepository<User, String> {
 	List<User> findByIdIsNotNullAndFirstnameEquals(String firstname);
 
 	List<User> findByVersionEqualsAndFirstnameEquals(Long version, String firstname);
+
+	// simulate a slow operation
+	@Cacheable("mySpringCache")
+	default List<User> getByFirstname(String firstname) {
+		try {
+			Thread.sleep(1000 * 5);
+		} catch (InterruptedException ie) {}
+		return findByFirstname(firstname);
+	}
 }
diff --git a/src/test/java/org/springframework/data/couchbase/domain/UserSubmissionAnnotated.java b/src/test/java/org/springframework/data/couchbase/domain/UserSubmissionAnnotated.java
new file mode 100644
index 00000000..d58c5568
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/domain/UserSubmissionAnnotated.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2020-2022 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.data.couchbase.domain;
+
+import lombok.Data;
+import org.springframework.data.annotation.TypeAlias;
+import org.springframework.data.couchbase.core.mapping.Document;
+import org.springframework.data.couchbase.core.mapping.Field;
+import org.springframework.data.couchbase.core.query.FetchType;
+import org.springframework.data.couchbase.core.query.N1qlJoin;
+import org.springframework.data.couchbase.repository.Collection;
+import org.springframework.data.couchbase.repository.Scope;
+
+import java.util.List;
+
+/**
+ * UserSubmissionAnnotated entity for tests
+ *
+ * @author Michael Reiche
+ */
+@Data
+@Document
+@TypeAlias("user")
+@Scope("my_scope")
+@Collection("my_collection")
+public class UserSubmissionAnnotated extends ComparableEntity {
+  private String id;
+  private String username;
+  private String email;
+  private String password;
+  private List<String> roles;
+  @N1qlJoin(on = "meta(lks).id=rks.parentId", fetchType = FetchType.IMMEDIATE) List<AddressAnnotated> otherAddresses;
+  private Address address;
+  private int credits;
+  private List<Submission> submissions;
+  private List<Course> courses;
+
+  public void setSubmissions(List<Submission> submissions) {
+    this.submissions = submissions;
+  }
+
+  public void setCourses(List<Course> courses) {
+    this.courses = courses;
+  }
+
+}
diff --git a/src/test/java/org/springframework/data/couchbase/domain/UserSubmissionAnnotatedRepository.java b/src/test/java/org/springframework/data/couchbase/domain/UserSubmissionAnnotatedRepository.java
new file mode 100644
index 00000000..551aad1a
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/domain/UserSubmissionAnnotatedRepository.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2022 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.data.couchbase.domain;
+
+import java.util.List;
+
+import org.springframework.data.couchbase.repository.ScanConsistency;
+import org.springframework.data.repository.PagingAndSortingRepository;
+import org.springframework.stereotype.Repository;
+
+import com.couchbase.client.java.query.QueryScanConsistency;
+
+/**
+ * UserSubmissionAnnotatedRepository for tests
+ *
+ * @author Michael Reiche
+ */
+@Repository
+public interface UserSubmissionAnnotatedRepository extends PagingAndSortingRepository<UserSubmissionAnnotated, String> {
+
+  @ScanConsistency(query = QueryScanConsistency.REQUEST_PLUS)
+  List<UserSubmissionAnnotated> findByUsername(String username);
+}
diff --git a/src/test/java/org/springframework/data/couchbase/domain/UserSubmissionUnannotated.java b/src/test/java/org/springframework/data/couchbase/domain/UserSubmissionUnannotated.java
new file mode 100644
index 00000000..361f8cd2
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/domain/UserSubmissionUnannotated.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2020-2022 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.data.couchbase.domain;
+
+import lombok.Data;
+
+import java.util.List;
+
+import org.springframework.data.annotation.TypeAlias;
+import org.springframework.data.couchbase.core.mapping.Document;
+import org.springframework.data.couchbase.core.query.FetchType;
+import org.springframework.data.couchbase.core.query.N1qlJoin;
+import org.springframework.data.couchbase.repository.Collection;
+
+/**
+ * UserSubmissionAnnotated entity for tests
+ *
+ * @author Michael Reiche
+ */
+@Data
+@Document
+// there is no @Scope annotation on this entity
+@Collection("my_collection")
+@TypeAlias("user")
+public class UserSubmissionUnannotated extends ComparableEntity {
+	private String id;
+	private String username;
+	private String email;
+	private String password;
+	private List<String> roles;
+	@N1qlJoin(on = "meta(lks).id=rks.parentId", fetchType = FetchType.IMMEDIATE) List<AddressAnnotated> otherAddresses;
+	private Address address;
+	private int credits;
+	private List<Submission> submissions;
+	private List<Course> courses;
+
+	public void setSubmissions(List<Submission> submissions) {
+		this.submissions = submissions;
+	}
+
+	public void setCourses(List<Course> courses) {
+		this.courses = courses;
+	}
+
+}
diff --git a/src/test/java/org/springframework/data/couchbase/domain/UserSubmissionUnannotatedRepository.java b/src/test/java/org/springframework/data/couchbase/domain/UserSubmissionUnannotatedRepository.java
new file mode 100644
index 00000000..46b370e9
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/domain/UserSubmissionUnannotatedRepository.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2020-2022 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.data.couchbase.domain;
+
+import java.util.List;
+
+import org.springframework.data.couchbase.repository.ScanConsistency;
+import org.springframework.data.repository.PagingAndSortingRepository;
+import org.springframework.stereotype.Repository;
+
+import com.couchbase.client.java.query.QueryScanConsistency;
+
+/**
+ * UserSubmissionAnnotatedRepository for tests
+ *
+ * @author Michael Reiche
+ */
+@Repository
+public interface UserSubmissionUnannotatedRepository
+		extends PagingAndSortingRepository<UserSubmissionUnannotated, String> {
+
+	@ScanConsistency(query = QueryScanConsistency.REQUEST_PLUS)
+	List<UserSubmissionUnannotated> findByUsername(String username);
+}
diff --git a/src/test/java/org/springframework/data/couchbase/repository/CouchbaseAbstractRepositoryIntegrationTests.java b/src/test/java/org/springframework/data/couchbase/repository/CouchbaseAbstractRepositoryIntegrationTests.java
new file mode 100644
index 00000000..e1e4c764
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/repository/CouchbaseAbstractRepositoryIntegrationTests.java
@@ -0,0 +1,151 @@
+/*
+ * Copyright 2017-2022 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.data.couchbase.repository;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+import java.util.List;
+import java.util.Optional;
+import java.util.UUID;
+
+import org.junit.jupiter.api.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.data.couchbase.config.AbstractCouchbaseConfiguration;
+import org.springframework.data.couchbase.core.convert.CouchbaseCustomConversions;
+import org.springframework.data.couchbase.core.convert.MappingCouchbaseConverter;
+import org.springframework.data.couchbase.core.mapping.CouchbaseMappingContext;
+import org.springframework.data.couchbase.domain.AbstractUser;
+import org.springframework.data.couchbase.domain.AbstractUserRepository;
+import org.springframework.data.couchbase.domain.AbstractingMappingCouchbaseConverter;
+import org.springframework.data.couchbase.domain.OtherUser;
+import org.springframework.data.couchbase.domain.User;
+import org.springframework.data.couchbase.repository.config.EnableCouchbaseRepositories;
+import org.springframework.data.couchbase.util.ClusterAwareIntegrationTests;
+import org.springframework.data.couchbase.util.ClusterType;
+import org.springframework.data.couchbase.util.IgnoreWhen;
+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
+
+/**
+ * Abstract Repository tests
+ *
+ * @author Michael Reiche
+ */
+@SpringJUnitConfig(CouchbaseAbstractRepositoryIntegrationTests.Config.class)
+@IgnoreWhen(clusterTypes = ClusterType.MOCKED)
+public class CouchbaseAbstractRepositoryIntegrationTests extends ClusterAwareIntegrationTests {
+
+	@Autowired AbstractUserRepository abstractUserRepository;
+
+	@Test
+	void saveAndFindAbstract() {
+		// User extends AbstractUser
+		// OtherUser extends Abstractuser
+
+		{
+			User concreteUser = null;
+			{
+				concreteUser = new User(UUID.randomUUID().toString(), "userFirstname", "userLastname");
+				assertEquals(User.class, concreteUser.getClass());
+				concreteUser = abstractUserRepository.save(concreteUser); // this will now have version set
+				// Queries on repositories for abstract entities must be @Query and not include
+				// #{#n1ql.filter} (i.e. _class = <classname> ) as the classname will not match any document
+				AbstractUser found = abstractUserRepository.myFindById(concreteUser.getId());
+				assertEquals(concreteUser, found);
+				assertEquals(concreteUser.getClass(), found.getClass());
+			}
+			{
+				Optional<AbstractUser> found = abstractUserRepository.findById(concreteUser.getId());
+				assertEquals(concreteUser, found.get());
+			}
+			{
+				List<AbstractUser> found = abstractUserRepository.findByFirstname(concreteUser.getFirstname());
+				assertEquals(1, found.size(), "should have found one user");
+				assertEquals(concreteUser, found.get(0));
+			}
+			abstractUserRepository.delete(concreteUser);
+		}
+		{
+			AbstractUser abstractUser = new OtherUser(UUID.randomUUID().toString(), "userFirstname", "userLastname");
+			assertEquals(OtherUser.class, abstractUser.getClass());
+			abstractUserRepository.save(abstractUser);
+			{
+				// not going to find this one as using the type _class = AbstractUser ???
+				AbstractUser found = abstractUserRepository.myFindById(abstractUser.getId());
+				assertEquals(abstractUser, found);
+				assertEquals(abstractUser.getClass(), found.getClass());
+			}
+			{
+				Optional<AbstractUser> found = abstractUserRepository.findById(abstractUser.getId());
+				assertEquals(abstractUser, found.get());
+			}
+			{
+				List<AbstractUser> found = abstractUserRepository.findByFirstname(abstractUser.getFirstname());
+				assertEquals(1, found.size(), "should have found one user");
+				assertEquals(abstractUser, found.get(0));
+			}
+			abstractUserRepository.delete(abstractUser);
+		}
+
+	}
+
+	@Configuration
+	@EnableCouchbaseRepositories("org.springframework.data.couchbase")
+	static class Config extends AbstractCouchbaseConfiguration {
+
+		@Override
+		public String getConnectionString() {
+			return connectionString();
+		}
+
+		@Override
+		public String getUserName() {
+			return config().adminUsername();
+		}
+
+		@Override
+		public String getPassword() {
+			return config().adminPassword();
+		}
+
+		@Override
+		public String getBucketName() {
+			return bucketName();
+		}
+
+		/**
+		 * This uses a CustomMappingCouchbaseConverter instead of MappingCouchbaseConverter, which in turn uses
+		 * AbstractTypeMapper which has special mapping for AbstractUser
+		 */
+		@Override
+		@Bean(name = "mappingCouchbaseConverter")
+		public MappingCouchbaseConverter mappingCouchbaseConverter(CouchbaseMappingContext couchbaseMappingContext,
+				CouchbaseCustomConversions couchbaseCustomConversions /* there is a customConversions() method bean  */) {
+			// MappingCouchbaseConverter relies on a SimpleInformationMapper
+			// that has an getAliasFor(info) that just returns getType().getName().
+			// Our CustomMappingCouchbaseConverter uses a TypeBasedCouchbaseTypeMapper that will
+			// use the DocumentType annotation
+			MappingCouchbaseConverter converter = new AbstractingMappingCouchbaseConverter(couchbaseMappingContext,
+					typeKey());
+			converter.setCustomConversions(couchbaseCustomConversions);
+			return converter;
+		}
+
+	}
+
+}
diff --git a/src/test/java/org/springframework/data/couchbase/repository/CouchbaseRepositoryKeyValueIntegrationTests.java b/src/test/java/org/springframework/data/couchbase/repository/CouchbaseRepositoryKeyValueIntegrationTests.java
index 41612eed..b946d0ab 100644
--- a/src/test/java/org/springframework/data/couchbase/repository/CouchbaseRepositoryKeyValueIntegrationTests.java
+++ b/src/test/java/org/springframework/data/couchbase/repository/CouchbaseRepositoryKeyValueIntegrationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2020 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,22 +16,35 @@
 
 package org.springframework.data.couchbase.repository;
 
-import static org.junit.jupiter.api.Assertions.*;
+
+
+import static com.couchbase.client.java.query.QueryScanConsistency.REQUEST_PLUS;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNotEquals;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Optional;
 import java.util.UUID;
 
-import com.couchbase.client.java.kv.GetResult;
+import com.couchbase.client.core.deps.io.netty.handler.ssl.util.InsecureTrustManagerFactory;
+import com.couchbase.client.core.env.SecurityConfig;
+import com.couchbase.client.java.env.ClusterEnvironment;
+import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.context.annotation.Configuration;
+import org.springframework.dao.DuplicateKeyException;
+import org.springframework.dao.OptimisticLockingFailureException;
 import org.springframework.data.couchbase.config.AbstractCouchbaseConfiguration;
 import org.springframework.data.couchbase.core.CouchbaseTemplate;
+import org.springframework.data.couchbase.domain.Airline;
+import org.springframework.data.couchbase.domain.AirlineRepository;
 import org.springframework.data.couchbase.domain.Course;
 import org.springframework.data.couchbase.domain.Library;
 import org.springframework.data.couchbase.domain.LibraryRepository;
@@ -50,6 +63,8 @@ import org.springframework.data.couchbase.util.ClusterType;
 import org.springframework.data.couchbase.util.IgnoreWhen;
 import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
 
+import com.couchbase.client.java.kv.GetResult;
+
 /**
  * Repository KV tests
  *
@@ -64,9 +79,17 @@ public class CouchbaseRepositoryKeyValueIntegrationTests extends ClusterAwareInt
 	@Autowired LibraryRepository libraryRepository;
 	@Autowired SubscriptionTokenRepository subscriptionTokenRepository;
 	@Autowired UserSubmissionRepository userSubmissionRepository;
+	@Autowired AirlineRepository airlineRepository;
 	@Autowired PersonValueRepository personValueRepository;
 	@Autowired CouchbaseTemplate couchbaseTemplate;
 
+	@BeforeEach
+	public void beforeEach() {
+		super.beforeEach();
+		couchbaseTemplate.removeByQuery(SubscriptionToken.class).withConsistency(REQUEST_PLUS).all();
+		couchbaseTemplate.findByQuery(SubscriptionToken.class).withConsistency(REQUEST_PLUS).all();
+	}
+
 	@Test
 	void subscriptionToken() {
 		SubscriptionToken st = new SubscriptionToken("id", 0, "type", "Dave Smith", "app123", "dev123", 0);
@@ -76,12 +99,36 @@ public class CouchbaseRepositoryKeyValueIntegrationTests extends ClusterAwareInt
 		GetResult jdkResult = couchbaseTemplate.getCouchbaseClientFactory().getDefaultCollection().get(st.getId());
 		assertNotEquals(0, st.getVersion());
 		assertEquals(jdkResult.cas(), st.getVersion());
+		subscriptionTokenRepository.delete(st);
 	}
 
 	@Test
 	@IgnoreWhen(clusterTypes = ClusterType.MOCKED)
-	void saveAndFindById() {
+	void saveReplaceUpsertInsert() {
+		// the User class has a version.
 		User user = new User(UUID.randomUUID().toString(), "f", "l");
+		// save the document - we don't care how on this call
+		userRepository.save(user);
+		// Now set the version to 0, it should attempt an insert and fail.
+		long saveVersion = user.getVersion();
+		user.setVersion(0);
+		assertThrows(DuplicateKeyException.class, () -> userRepository.save(user));
+		user.setVersion(saveVersion + 1);
+		assertThrows(OptimisticLockingFailureException.class, () -> userRepository.save(user));
+		userRepository.delete(user);
+
+		// Airline does not have a version
+		Airline airline = new Airline(UUID.randomUUID().toString(), "MyAirline");
+		// save the document - we don't care how on this call
+		airlineRepository.save(airline);
+		airlineRepository.save(airline); // If it was an insert it would fail. Can't tell if it is an upsert or replace.
+		airlineRepository.delete(airline);
+	}
+
+	@Test
+	@IgnoreWhen(clusterTypes = ClusterType.MOCKED)
+	void saveAndFindById() {
+		User user = new User(UUID.randomUUID().toString(), "saveAndFindById", "l");
 		// this currently fails when using mocked in integration.properties with status "UNKNOWN"
 		assertFalse(userRepository.existsById(user.getId()));
 
@@ -98,7 +145,7 @@ public class CouchbaseRepositoryKeyValueIntegrationTests extends ClusterAwareInt
 	@Test
 	@IgnoreWhen(clusterTypes = ClusterType.MOCKED)
 	void saveAndFindImmutableById() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
-		PersonValue personValue = new PersonValue(null, 0, "f", "l");
+		PersonValue personValue = new PersonValue(null, 0, "saveAndFindImmutableById", "l");
 		personValue = personValueRepository.save(personValue);
 		Optional<PersonValue> found = personValueRepository.findById(personValue.getId());
 		assertTrue(found.isPresent());
@@ -138,7 +185,7 @@ public class CouchbaseRepositoryKeyValueIntegrationTests extends ClusterAwareInt
 		user.setCourses(Arrays.asList(new Course(UUID.randomUUID().toString(), user.getId(), "581")));
 
 		// this currently fails when using mocked in integration.properties with status "UNKNOWN"
-		assertFalse(userRepository.existsById(user.getId()));
+		assertFalse(userSubmissionRepository.existsById(user.getId()));
 
 		userSubmissionRepository.save(user);
 
@@ -146,7 +193,7 @@ public class CouchbaseRepositoryKeyValueIntegrationTests extends ClusterAwareInt
 		assertTrue(found.isPresent());
 		found.ifPresent(u -> assertEquals(user, u));
 
-		assertTrue(userRepository.existsById(user.getId()));
+		assertTrue(userSubmissionRepository.existsById(user.getId()));
 		assertEquals(user.getSubmissions().get(0).getId(), found.get().getSubmissions().get(0).getId());
 		assertEquals(user.getCourses().get(0).getId(), found.get().getCourses().get(0).getId());
 		assertEquals(user, found.get());
@@ -177,6 +224,15 @@ public class CouchbaseRepositoryKeyValueIntegrationTests extends ClusterAwareInt
 			return bucketName();
 		}
 
+		@Override
+		protected void configureEnvironment(ClusterEnvironment.Builder builder) {
+			if(getConnectionString().contains("cloud.couchbase.com")) {
+				builder.securityConfig(SecurityConfig.builder()
+						.trustManagerFactory(InsecureTrustManagerFactory.INSTANCE)
+						.enableTls(true));
+			}
+		}
+
 	}
 
 }
diff --git a/src/test/java/org/springframework/data/couchbase/repository/CouchbaseRepositoryQueryIntegrationTests.java b/src/test/java/org/springframework/data/couchbase/repository/CouchbaseRepositoryQueryIntegrationTests.java
index c4d1f9f3..f648063d 100644
--- a/src/test/java/org/springframework/data/couchbase/repository/CouchbaseRepositoryQueryIntegrationTests.java
+++ b/src/test/java/org/springframework/data/couchbase/repository/CouchbaseRepositoryQueryIntegrationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2021 the original author or authors.
+ * Copyright 2017-2022 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,6 +18,8 @@ package org.springframework.data.couchbase.repository;
 
 import static com.couchbase.client.java.query.QueryScanConsistency.NOT_BOUNDED;
 import static com.couchbase.client.java.query.QueryScanConsistency.REQUEST_PLUS;
+import static com.couchbase.client.java.query.QueryOptions.queryOptions;
+import static com.couchbase.client.java.query.QueryScanConsistency.REQUEST_PLUS;
 import static java.util.Arrays.asList;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assertions.assertEquals;
@@ -35,6 +37,7 @@ import java.lang.reflect.Method;
 import java.time.Duration;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Locale;
 import java.util.Optional;
@@ -47,14 +50,15 @@ import java.util.stream.Collectors;
 
 import javax.validation.ConstraintViolationException;
 
+import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.context.ApplicationContext;
 import org.springframework.context.annotation.AnnotationConfigApplicationContext;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
-import org.springframework.dao.DataIntegrityViolationException;
 import org.springframework.dao.DataRetrievalFailureException;
+import org.springframework.dao.OptimisticLockingFailureException;
 import org.springframework.data.auditing.DateTimeProvider;
 import org.springframework.data.couchbase.CouchbaseClientFactory;
 import org.springframework.data.couchbase.config.AbstractCouchbaseConfiguration;
@@ -69,6 +73,7 @@ import org.springframework.data.couchbase.domain.Airport;
 import org.springframework.data.couchbase.domain.AirportMini;
 import org.springframework.data.couchbase.domain.AirportRepository;
 import org.springframework.data.couchbase.domain.AirportRepositoryScanConsistencyTest;
+import org.springframework.data.couchbase.domain.Iata;
 import org.springframework.data.couchbase.domain.NaiveAuditorAware;
 import org.springframework.data.couchbase.domain.Person;
 import org.springframework.data.couchbase.domain.PersonRepository;
@@ -89,6 +94,7 @@ import org.springframework.data.couchbase.util.IgnoreWhen;
 import org.springframework.data.domain.Page;
 import org.springframework.data.domain.PageRequest;
 import org.springframework.data.domain.Pageable;
+import org.springframework.data.domain.Slice;
 import org.springframework.data.domain.Sort;
 import org.springframework.data.projection.SpelAwareProxyProjectionFactory;
 import org.springframework.data.repository.core.support.DefaultRepositoryMetadata;
@@ -101,9 +107,10 @@ import com.couchbase.client.core.error.IndexFailureException;
 import com.couchbase.client.java.env.ClusterEnvironment;
 import com.couchbase.client.java.json.JsonArray;
 import com.couchbase.client.java.kv.GetResult;
+import com.couchbase.client.java.kv.InsertOptions;
+import com.couchbase.client.java.query.QueryOptions;
 import com.couchbase.client.java.kv.MutationState;
 import com.couchbase.client.java.kv.UpsertOptions;
-import com.couchbase.client.java.query.QueryOptions;
 import com.couchbase.client.java.query.QueryScanConsistency;
 
 /**
@@ -130,6 +137,16 @@ public class CouchbaseRepositoryQueryIntegrationTests extends ClusterAwareIntegr
 	String scopeName = "_default";
 	String collectionName = "_default";
 
+	@BeforeEach
+	public void beforeEach() {
+		super.beforeEach();
+		couchbaseTemplate.removeByQuery(User.class).withConsistency(REQUEST_PLUS).all();
+		couchbaseTemplate.removeByQuery(Person.class).withConsistency(REQUEST_PLUS).all();
+		couchbaseTemplate.findByQuery(User.class).withConsistency(REQUEST_PLUS).all();
+		couchbaseTemplate.findByQuery(Person.class).withConsistency(REQUEST_PLUS).all();
+
+	}
+
 	@Test
 	void shouldSaveAndFindAll() {
 		Airport vie = null;
@@ -237,14 +254,37 @@ public class CouchbaseRepositoryQueryIntegrationTests extends ClusterAwareIntegr
 
 	}
 
+	@Test
+	void issue1304CollectionParameter() {
+		Airport vie = null;
+		try {
+			vie = new Airport("airports::vie", "vie", "low5");
+			airportRepository.save(vie);
+			java.util.Collection<String> iatas = new LinkedList<String>();
+			iatas.add(vie.getIata());
+			java.util.Collection<String> icaos = new LinkedList<String>();
+			icaos.add(vie.getIcao());
+			icaos.add("blue");
+			PageRequest pageable = PageRequest.of(0, 1, Sort.by("iata"));
+			List<Airport> airports = airportRepository.findByIataInAndIcaoIn(iatas, icaos, pageable);
+			assertEquals(1, airports.size());
+
+			List<Airport> airports2 = airportRepository.findByIataInAndIcaoIn(iatas, icaos, pageable);
+			assertEquals(1, airports2.size());
+
+		} finally {
+			airportRepository.delete(vie);
+		}
+
+	}
+
 	@Test
 	void findBySimpleProperty() {
 		Airport vie = null;
 		try {
 			vie = new Airport("airports::vie", "vie", "low6");
 			vie = airportRepository.save(vie);
-			Airport airport2 = airportRepository
-					.withOptions(QueryOptions.queryOptions().scanConsistency(QueryScanConsistency.REQUEST_PLUS))
+			Airport airport2 = airportRepository.withOptions(queryOptions().scanConsistency(REQUEST_PLUS))
 					.findByIata(vie.getIata());
 			assertEquals(airport2, vie);
 
@@ -275,6 +315,7 @@ public class CouchbaseRepositoryQueryIntegrationTests extends ClusterAwareIntegr
 
 	@Test
 	public void saveNotBoundedRequestPlus() {
+		airportRepository.withOptions(QueryOptions.queryOptions().scanConsistency(REQUEST_PLUS)).deleteAll();
 		ApplicationContext ac = new AnnotationConfigApplicationContext(ConfigRequestPlus.class);
 		// the Config class has been modified, these need to be loaded again
 		CouchbaseTemplate couchbaseTemplateRP = (CouchbaseTemplate) ac.getBean(COUCHBASE_TEMPLATE);
@@ -313,11 +354,12 @@ public class CouchbaseRepositoryQueryIntegrationTests extends ClusterAwareIntegr
 
 	@Test
 	public void saveNotBoundedWithDefaultRepository() {
-
+		airportRepository.withOptions(QueryOptions.queryOptions().scanConsistency(REQUEST_PLUS)).deleteAll();
 		ApplicationContext ac = new AnnotationConfigApplicationContext(Config.class);
 		// the Config class has been modified, these need to be loaded again
 		CouchbaseTemplate couchbaseTemplateRP = (CouchbaseTemplate) ac.getBean(COUCHBASE_TEMPLATE);
-		AirportRepositoryScanConsistencyTest airportRepositoryRP = (AirportRepositoryScanConsistencyTest) ac.getBean("airportRepositoryScanConsistencyTest");
+		AirportRepositoryScanConsistencyTest airportRepositoryRP = (AirportRepositoryScanConsistencyTest) ac
+				.getBean("airportRepositoryScanConsistencyTest");
 
 		List<Airport> sizeBeforeTest = airportRepositoryRP.findAll();
 		assertEquals(0, sizeBeforeTest.size());
@@ -334,19 +376,19 @@ public class CouchbaseRepositoryQueryIntegrationTests extends ClusterAwareIntegr
 
 		ApplicationContext ac = new AnnotationConfigApplicationContext(ConfigRequestPlus.class);
 		// the Config class has been modified, these need to be loaded again
-		AirportRepositoryScanConsistencyTest airportRepositoryRP = (AirportRepositoryScanConsistencyTest) ac.getBean("airportRepositoryScanConsistencyTest");
+		AirportRepositoryScanConsistencyTest airportRepositoryRP = (AirportRepositoryScanConsistencyTest) ac
+				.getBean("airportRepositoryScanConsistencyTest");
 
 		List<Airport> sizeBeforeTest = airportRepositoryRP.findAll();
 		assertEquals(0, sizeBeforeTest.size());
 
 		Airport vie = new Airport("airports::vie", "vie", "low9");
 		Airport saved = airportRepositoryRP.save(vie);
-		List<Airport> allSaved = airportRepositoryRP.findAll();
+		List<Airport> allSaved = airportRepositoryRP.findAll(REQUEST_PLUS);
 		couchbaseTemplate.removeById(Airport.class).one(saved.getId());
 		assertEquals(1, allSaved.size(), "should have found 1 airport");
 	}
 
-
 	@Test
 	void findByTypeAlias() {
 		Airport vie = null;
@@ -354,9 +396,10 @@ public class CouchbaseRepositoryQueryIntegrationTests extends ClusterAwareIntegr
 			vie = new Airport("airports::vie", "vie", "loww");
 			vie = airportRepository.save(vie);
 			List<Airport> airports = couchbaseTemplate.findByQuery(Airport.class)
-					.withConsistency(QueryScanConsistency.REQUEST_PLUS)
 					.matching(org.springframework.data.couchbase.core.query.Query
 							.query(QueryCriteria.where(N1QLExpression.x("_class")).is("airport")))
+					.withConsistency(REQUEST_PLUS)
+
 					.all();
 			assertFalse(airports.isEmpty(), "should have found aiport");
 		} finally {
@@ -367,15 +410,38 @@ public class CouchbaseRepositoryQueryIntegrationTests extends ClusterAwareIntegr
 	@Test
 	void findByEnum() {
 		Airport vie = null;
+		Airport zzz = null;
 		try {
 			vie = new Airport("airports::vie", "vie", "loww");
 			vie = airportRepository.save(vie);
-			Airport airport2 = airportRepository.findByIata(vie.getIata());
+			zzz = airportRepository.save(vie.withId("airports::zzz").withIata("zzz"));
+			Airport airport2 = airportRepository.findByIata(Iata.vie);
 			assertNotNull(airport2, "should have found " + vie);
 			assertEquals(airport2.getId(), vie.getId());
-
+			Airport airport3 = airportRepository.findByIataIn(new Iata[] { Iata.vie, Iata.xxx });
+			assertNotNull(airport3, "should have found " + vie);
+			assertEquals(airport3.getId(), vie.getId());
+
+			java.util.Collection<Iata> iatas = new ArrayList<>();
+			iatas.add(Iata.vie);
+			iatas.add(Iata.xxx);
+			Airport airport4 = airportRepository.findByIataIn(iatas);
+			assertNotNull(airport4, "should have found " + vie);
+			assertEquals(airport4.getId(), vie.getId());
+
+			Airport airport5 = airportRepository.findByIataIn(Iata.vie, Iata.xxx);
+			assertNotNull(airport5, "should have found " + vie);
+			assertEquals(airport5.getId(), vie.getId());
+
+			JsonArray iatasJson = JsonArray.ja();
+			iatasJson.add(Iata.vie.toString());
+			iatasJson.add(Iata.xxx.toString());
+			Airport airport6 = airportRepository.findByIataIn(iatasJson);
+			assertNotNull(airport6, "should have found " + vie);
+			assertEquals(airport6.getId(), vie.getId());
 		} finally {
 			airportRepository.delete(vie);
+			airportRepository.delete(zzz);
 		}
 	}
 
@@ -393,15 +459,13 @@ public class CouchbaseRepositoryQueryIntegrationTests extends ClusterAwareIntegr
 			Airport saved = airportRepository.withScope(scopeName).withCollection(collectionName).save(vie);
 			// given collection (on scope used by template)
 			Airport airport2 = airportRepository.withCollection(collectionName)
-					.withOptions(QueryOptions.queryOptions().scanConsistency(QueryScanConsistency.REQUEST_PLUS))
-					.iata(vie.getIata());
+					.withOptions(queryOptions().scanConsistency(REQUEST_PLUS)).iata(vie.getIata());
 			assertEquals(saved, airport2);
 
 			// given scope and collection
 
 			Airport airport3 = airportRepository.withScope(scopeName).withCollection(collectionName)
-					.withOptions(QueryOptions.queryOptions().scanConsistency(QueryScanConsistency.REQUEST_PLUS))
-					.iata(vie.getIata());
+					.withOptions(queryOptions().scanConsistency(REQUEST_PLUS)).iata(vie.getIata());
 			assertEquals(saved, airport3);
 
 			// given bad collection
@@ -409,7 +473,8 @@ public class CouchbaseRepositoryQueryIntegrationTests extends ClusterAwareIntegr
 					() -> airportRepository.withCollection("bogusCollection").iata(vie.getIata()));
 
 			// given bad scope
-			assertThrows(IndexFailureException.class, () -> airportRepository.withScope("bogusScope").iata(vie.getIata()));
+			assertThrows(IndexFailureException.class,
+					() -> airportRepository.withScope("bogusScope").withCollection(collectionName).iata(vie.getIata()));
 
 		} finally {
 			airportRepository.delete(vie);
@@ -443,12 +508,11 @@ public class CouchbaseRepositoryQueryIntegrationTests extends ClusterAwareIntegr
 		try {
 			Airport saved = airportRepository.save(vie);
 			// Duration of 1 nano-second will cause timeout
-			assertThrows(AmbiguousTimeoutException.class, () -> airportRepository
-					.withOptions(QueryOptions.queryOptions().timeout(Duration.ofNanos(1))).iata(vie.getIata()));
+			assertThrows(AmbiguousTimeoutException.class,
+					() -> airportRepository.withOptions(queryOptions().timeout(Duration.ofNanos(1))).iata(vie.getIata()));
 
-			Airport airport3 = airportRepository.withOptions(
-					QueryOptions.queryOptions().scanConsistency(QueryScanConsistency.REQUEST_PLUS).parameters(positionalParams))
-					.iata(vie.getIata());
+			Airport airport3 = airportRepository
+					.withOptions(queryOptions().scanConsistency(REQUEST_PLUS).parameters(positionalParams)).iata(vie.getIata());
 			assertEquals(saved, airport3);
 
 		} finally {
@@ -466,7 +530,8 @@ public class CouchbaseRepositoryQueryIntegrationTests extends ClusterAwareIntegr
 			// set version == 0 so save() will be an upsert, not a replace
 			Airport saved = airportRepository.save(vie.clearVersion());
 			try {
-				airport2 = airportRepository.iata(saved.getIata());
+				airport2 = airportRepository.withOptions(queryOptions().scanConsistency(QueryScanConsistency.NOT_BOUNDED))
+						.iata(saved.getIata());
 				if (airport2 == null) {
 					break;
 				}
@@ -479,7 +544,8 @@ public class CouchbaseRepositoryQueryIntegrationTests extends ClusterAwareIntegr
 				assertEquals(vie.getId(), removeResult.getId());
 				assertTrue(removeResult.getCas() != 0);
 				assertTrue(removeResult.getMutationToken().isPresent());
-				Airport airport3 = airportRepository.iata(vie.getIata());
+				Airport airport3 = airportRepository.withOptions(queryOptions().scanConsistency(REQUEST_PLUS)
+						.consistentWith(MutationState.from(removeResult.getMutationToken().get()))).iata(vie.getIata());
 				assertNull(airport3, "should have been removed");
 			}
 		}
@@ -505,9 +571,10 @@ public class CouchbaseRepositoryQueryIntegrationTests extends ClusterAwareIntegr
 	public void testCas() {
 		User user = new User("1", "Dave", "Wilson");
 		userRepository.save(user);
+		long saveVersion = user.getVersion();
 		user.setVersion(user.getVersion() - 1);
-		assertThrows(DataIntegrityViolationException.class, () -> userRepository.save(user));
-		user.setVersion(0);
+		assertThrows(OptimisticLockingFailureException.class, () -> userRepository.save(user));
+		user.setVersion(saveVersion);
 		userRepository.save(user);
 		userRepository.delete(user);
 	}
@@ -515,7 +582,7 @@ public class CouchbaseRepositoryQueryIntegrationTests extends ClusterAwareIntegr
 	@Test
 	public void testExpiration() {
 		Airport airport = new Airport("1", "iata21", "icao21");
-		airportRepository.withOptions(UpsertOptions.upsertOptions().expiry(Duration.ofSeconds(10))).save(airport);
+		airportRepository.withOptions(InsertOptions.insertOptions().expiry(Duration.ofSeconds(10))).save(airport);
 		Airport foundAirport = airportRepository.findByIata(airport.getIata());
 		assertNotEquals(0, foundAirport.getExpiration());
 		airportRepository.delete(airport);
@@ -546,7 +613,51 @@ public class CouchbaseRepositoryQueryIntegrationTests extends ClusterAwareIntegr
 	}
 
 	@Test
-	void count() {
+	void stringQueryReturnsSimpleType() {
+		Airport airport1 = new Airport("1", "myIata1", "MyIcao");
+		airportRepository.save(airport1);
+		Airport airport2 = new Airport("2", "myIata2__", "MyIcao");
+		airportRepository.save(airport2);
+		List<String> iatas = airportRepository.getStrings();
+		assertEquals(Arrays.asList(airport1.getIata(), airport2.getIata()), iatas);
+		List<Long> iataLengths = airportRepository.getLongs();
+		assertEquals(Arrays.asList(airport1.getIata().length(), airport2.getIata().length()).toString(),
+				iataLengths.toString());
+		// this is somewhat broken, because decode is told that each "row" is just a String instead of a String[]
+		// As such, only the first element is returned. (QueryExecutionConverts.unwrapWrapperTypes)
+		List<String[]> iataAndIcaos = airportRepository.getStringArrays();
+		assertEquals(airport1.getIata(), iataAndIcaos.get(0)[0]);
+		assertEquals(airport2.getIata(), iataAndIcaos.get(1)[0]);
+		airportRepository.deleteById(airport1.getId());
+		airportRepository.deleteById(airport2.getId());
+	}
+
+	@Test
+	void sortedRepository() {
+		airportRepository.withOptions(QueryOptions.queryOptions().scanConsistency(REQUEST_PLUS)).deleteAll();
+		String[] iatas = { "JFK", "IAD", "SFO", "SJC", "SEA", "LAX", "PHX" };
+
+		try {
+			airportRepository.saveAll(
+					Arrays.stream(iatas).map((iata) -> new Airport("airports::" + iata, iata, iata.toLowerCase(Locale.ROOT)))
+							.collect(Collectors.toSet()));
+			List<Airport> airports = airportRepository.withOptions(QueryOptions.queryOptions().scanConsistency(REQUEST_PLUS))
+					.findAll(Sort.by("iata"));
+			String[] sortedIatas = iatas.clone();
+			System.out.println("" + iatas.length + " " + sortedIatas.length);
+			Arrays.sort(sortedIatas);
+			for (int i = 0; i < sortedIatas.length; i++) {
+				assertEquals(sortedIatas[i], airports.get(i).getIata());
+			}
+		} finally {
+			airportRepository
+					.deleteAllById(Arrays.stream(iatas).map((iata) -> "airports::" + iata).collect(Collectors.toSet()));
+		}
+	}
+
+	@Test
+	void countSlicePage() {
+		airportRepository.withOptions(QueryOptions.queryOptions().scanConsistency(REQUEST_PLUS)).deleteAll();
 		String[] iatas = { "JFK", "IAD", "SFO", "SJC", "SEA", "LAX", "PHX" };
 
 		airportRepository.countOne();
@@ -583,6 +694,36 @@ public class CouchbaseRepositoryQueryIntegrationTests extends ClusterAwareIntegr
 			airportCount = airportRepository.countByIataIn("XXX");
 			assertEquals(0, airportCount);
 
+			pageable = PageRequest.of(1, 2, Sort.by("iata"));
+			Slice<Airport> airportSlice = airportRepository.fetchSlice("AAA", "zzz", pageable);
+			assertEquals(2, airportSlice.getSize());
+			assertEquals("LAX", airportSlice.getContent().get(0).getIata());
+			assertEquals("PHX", airportSlice.getContent().get(1).getIata());
+
+			pageable = PageRequest.of(1, 2, Sort.by("iata"));
+			Page<Airport> airportPage = airportRepository.fetchPage("AAA", "zzz", pageable);
+			assertEquals(2, airportPage.getSize());
+			assertEquals("LAX", airportPage.getContent().get(0).getIata());
+			assertEquals("PHX", airportPage.getContent().get(1).getIata());
+
+		} finally {
+			airportRepository
+					.deleteAllById(Arrays.stream(iatas).map((iata) -> "airports::" + iata).collect(Collectors.toSet()));
+		}
+	}
+
+	@Test
+	void testGroupBy() {
+		String[] iatas = { "JFK", "IAD", "SFO", "SJC", "SEA", "LAX", "PHX" };
+		try {
+			airportRepository.saveAll(
+					Arrays.stream(iatas).map((iata) -> new Airport("airports::" + iata, iata, iata.toLowerCase(Locale.ROOT)))
+							.collect(Collectors.toSet()));
+			List<Airport> airports = airportRepository.groupByIata();
+			for (Airport a : airports) {
+				System.out.println(a);
+			}
+
 		} finally {
 			airportRepository
 					.deleteAllById(Arrays.stream(iatas).map((iata) -> "airports::" + iata).collect(Collectors.toSet()));
@@ -645,6 +786,7 @@ public class CouchbaseRepositoryQueryIntegrationTests extends ClusterAwareIntegr
 	void distinct() {
 		String[] iatas = { "JFK", "IAD", "SFO", "SJC", "SEA", "LAX", "PHX" };
 		String[] icaos = { "ic0", "ic1", "ic0", "ic1", "ic0", "ic1", "ic0" };
+		airportRepository.withOptions(QueryOptions.queryOptions().scanConsistency(REQUEST_PLUS)).deleteAll();
 
 		try {
 			for (int i = 0; i < iatas.length; i++) {
@@ -738,11 +880,12 @@ public class CouchbaseRepositoryQueryIntegrationTests extends ClusterAwareIntegr
 		}
 	}
 
-	@Test // DATACOUCH-650
+	@Test
+		// DATACOUCH-650
 	void deleteAllById() {
 
 		Airport vienna = new Airport("airports::vie", "vie", "LOWW");
-		Airport frankfurt = new Airport("airports::fra", "fra", "EDDF");
+		Airport frankfurt = new Airport("airports::fra", "fra", "EDDZ");
 		Airport losAngeles = new Airport("airports::lax", "lax", "KLAX");
 		try {
 			airportRepository.saveAll(asList(vienna, frankfurt, losAngeles));
@@ -757,8 +900,8 @@ public class CouchbaseRepositoryQueryIntegrationTests extends ClusterAwareIntegr
 	void couchbaseRepositoryQuery() throws Exception {
 		User user = new User("1", "Dave", "Wilson");
 		userRepository.save(user);
-		couchbaseTemplate.findByQuery(User.class).withConsistency(REQUEST_PLUS)
-				.matching(QueryCriteria.where("firstname").is("Dave").and("`1`").is("`1`")).all();
+		couchbaseTemplate.findByQuery(User.class).matching(QueryCriteria.where("firstname").is("Dave").and("`1`").is("`1`"))
+				.withConsistency(REQUEST_PLUS).all();
 		String input = "findByFirstname";
 		Method method = UserRepository.class.getMethod(input, String.class);
 		CouchbaseQueryMethod queryMethod = new CouchbaseQueryMethod(method,
@@ -786,9 +929,6 @@ public class CouchbaseRepositoryQueryIntegrationTests extends ClusterAwareIntegr
 	@Test
 	void findPlusN1qlJoin() throws Exception {
 
-		// needs an index for this N1ql Join
-		// create index ix2 on my_bucket(parent_id) where `_class` = 'org.springframework.data.couchbase.domain.Address';
-
 		UserSubmission user = new UserSubmission();
 		user.setId(UUID.randomUUID().toString());
 		user.setUsername("dave");
@@ -827,7 +967,17 @@ public class CouchbaseRepositoryQueryIntegrationTests extends ClusterAwareIntegr
 		}
 
 		couchbaseTemplate.removeById(Address.class)
-				.all(Arrays.asList(address1.getId(), address2.getId(), address3.getId(), user.getId()));
+				.all(Arrays.asList(address1.getId(), address2.getId(), address3.getId()));
+		couchbaseTemplate.removeById(UserSubmission.class).one(user.getId());
+	}
+
+	@Test
+	void findByKey() {
+		Airport airport = new Airport(UUID.randomUUID().toString(), "iata1038", "icao");
+		airportRepository.save(airport);
+		Airport found = airportRepository.findByKey(airport.getId());
+		assertEquals(airport, found);
+		airportRepository.delete(airport);
 	}
 
 	private void sleep(int millis) {
diff --git a/src/test/java/org/springframework/data/couchbase/repository/ReactiveCouchbaseRepositoryKeyValueIntegrationTests.java b/src/test/java/org/springframework/data/couchbase/repository/ReactiveCouchbaseRepositoryKeyValueIntegrationTests.java
index 6c1a8986..46169ba5 100644
--- a/src/test/java/org/springframework/data/couchbase/repository/ReactiveCouchbaseRepositoryKeyValueIntegrationTests.java
+++ b/src/test/java/org/springframework/data/couchbase/repository/ReactiveCouchbaseRepositoryKeyValueIntegrationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2020 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,6 +18,7 @@ package org.springframework.data.couchbase.repository;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.util.Optional;
@@ -27,9 +28,13 @@ import org.junit.jupiter.api.Test;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
+import org.springframework.dao.DuplicateKeyException;
+import org.springframework.dao.OptimisticLockingFailureException;
 import org.springframework.data.auditing.DateTimeProvider;
 import org.springframework.data.couchbase.config.AbstractCouchbaseConfiguration;
+import org.springframework.data.couchbase.domain.Airline;
 import org.springframework.data.couchbase.domain.Airport;
+import org.springframework.data.couchbase.domain.ReactiveAirlineRepository;
 import org.springframework.data.couchbase.domain.ReactiveAirportRepository;
 import org.springframework.data.couchbase.domain.ReactiveNaiveAuditorAware;
 import org.springframework.data.couchbase.domain.ReactiveUserRepository;
@@ -42,6 +47,9 @@ import org.springframework.data.couchbase.util.ClusterType;
 import org.springframework.data.couchbase.util.IgnoreWhen;
 import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
 
+/**
+ * @author Michael Reiche
+ */
 @SpringJUnitConfig(ReactiveCouchbaseRepositoryKeyValueIntegrationTests.Config.class)
 @IgnoreWhen(clusterTypes = ClusterType.MOCKED)
 public class ReactiveCouchbaseRepositoryKeyValueIntegrationTests extends ClusterAwareIntegrationTests {
@@ -50,9 +58,34 @@ public class ReactiveCouchbaseRepositoryKeyValueIntegrationTests extends Cluster
 
 	@Autowired ReactiveAirportRepository airportRepository;
 
+	@Autowired ReactiveAirlineRepository airlineRepository;
+
 	@Test
-	void saveAndFindById() {
+	@IgnoreWhen(clusterTypes = ClusterType.MOCKED)
+	void saveReplaceUpsertInsert() {
+		// the User class has a version.
 		User user = new User(UUID.randomUUID().toString(), "f", "l");
+		// save the document - we don't care how on this call
+		userRepository.save(user).block();
+		// Now set the version to 0, it should attempt an insert and fail.
+		long saveVersion = user.getVersion();
+		user.setVersion(0);
+		assertThrows(DuplicateKeyException.class, () -> userRepository.save(user).block());
+		user.setVersion(saveVersion + 1);
+		assertThrows(OptimisticLockingFailureException.class, () -> userRepository.save(user).block());
+		userRepository.delete(user);
+
+		// Airline does not have a version
+		Airline airline = new Airline(UUID.randomUUID().toString(), "MyAirline");
+		// save the document - we don't care how on this call
+		airlineRepository.save(airline).block();
+		airlineRepository.save(airline).block(); // If it was an insert it would fail. Can't tell if an upsert or replace.
+		airlineRepository.delete(airline).block();
+	}
+
+	@Test
+	void saveAndFindById() {
+		User user = new User(UUID.randomUUID().toString(), "saveAndFindById_reactive", "l");
 
 		assertFalse(userRepository.existsById(user.getId()).block());
 
@@ -63,6 +96,7 @@ public class ReactiveCouchbaseRepositoryKeyValueIntegrationTests extends Cluster
 		found.ifPresent(u -> assertEquals(save, u));
 
 		assertTrue(userRepository.existsById(user.getId()).block());
+		userRepository.delete(user).block();
 	}
 
 	@Test
diff --git a/src/test/java/org/springframework/data/couchbase/repository/ReactiveCouchbaseRepositoryQueryIntegrationTests.java b/src/test/java/org/springframework/data/couchbase/repository/ReactiveCouchbaseRepositoryQueryIntegrationTests.java
index a5f015d5..f80a3720 100644
--- a/src/test/java/org/springframework/data/couchbase/repository/ReactiveCouchbaseRepositoryQueryIntegrationTests.java
+++ b/src/test/java/org/springframework/data/couchbase/repository/ReactiveCouchbaseRepositoryQueryIntegrationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2021 the original author or authors.
+ * Copyright 2017-2022 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -22,6 +22,7 @@ import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
+import org.springframework.dao.OptimisticLockingFailureException;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 import reactor.test.StepVerifier;
@@ -40,7 +41,6 @@ import java.util.stream.Collectors;
 import org.junit.jupiter.api.Test;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.context.annotation.Configuration;
-import org.springframework.dao.DataIntegrityViolationException;
 import org.springframework.dao.DataRetrievalFailureException;
 import org.springframework.data.couchbase.CouchbaseClientFactory;
 import org.springframework.data.couchbase.config.AbstractCouchbaseConfiguration;
@@ -92,6 +92,28 @@ public class ReactiveCouchbaseRepositoryQueryIntegrationTests extends JavaIntegr
 		}
 	}
 
+	@Test
+	void testQuery() {
+		Airport vie = null;
+		Airport jfk = null;
+		try {
+			vie = new Airport("airports::vie", "vie", "low1");
+			airportRepository.save(vie).block();
+			jfk = new Airport("airports::jfk", "JFK", "xxxx");
+			airportRepository.save(jfk).block();
+
+			List<String> all = airportRepository.findIdByDynamicN1ql("","").toStream().collect(Collectors.toList());
+			System.out.println(all);
+			assertFalse(all.isEmpty());
+			assertTrue(all.stream().anyMatch(a -> a.equals("airports::vie")));
+			assertTrue(all.stream().anyMatch(a -> a.equals("airports::jfk")));
+
+		} finally {
+			airportRepository.delete(vie).block();
+			airportRepository.delete(jfk).block();
+		}
+	}
+
 	@Test
 	void findBySimpleProperty() {
 		Airport vie = null;
@@ -118,9 +140,10 @@ public class ReactiveCouchbaseRepositoryQueryIntegrationTests extends JavaIntegr
 	public void testCas() {
 		User user = new User("1", "Dave", "Wilson");
 		userRepository.save(user).block();
+		long saveVersion = user.getVersion();
 		user.setVersion(user.getVersion() - 1);
-		assertThrows(DataIntegrityViolationException.class, () -> userRepository.save(user).block());
-		user.setVersion(0);
+		assertThrows(OptimisticLockingFailureException.class, () -> userRepository.save(user).block());
+		user.setVersion(saveVersion);
 		userRepository.save(user).block();
 		userRepository.delete(user).block();
 	}
@@ -214,7 +237,7 @@ public class ReactiveCouchbaseRepositoryQueryIntegrationTests extends JavaIntegr
 	void deleteAllById() {
 
 		Airport vienna = new Airport("airports::vie", "vie", "LOWW");
-		Airport frankfurt = new Airport("airports::fra", "fra", "EDDF");
+		Airport frankfurt = new Airport("airports::fra", "fra", "EDDX");
 		Airport losAngeles = new Airport("airports::lax", "lax", "KLAX");
 
 		try {
@@ -234,7 +257,7 @@ public class ReactiveCouchbaseRepositoryQueryIntegrationTests extends JavaIntegr
 	void deleteAll() {
 
 		Airport vienna = new Airport("airports::vie", "vie", "LOWW");
-		Airport frankfurt = new Airport("airports::fra", "fra", "EDDF");
+		Airport frankfurt = new Airport("airports::fra", "fra", "EDDY");
 		Airport losAngeles = new Airport("airports::lax", "lax", "KLAX");
 
 		try {
diff --git a/src/test/java/org/springframework/data/couchbase/repository/query/CouchbaseRepositoryQueryCollectionIntegrationTests.java b/src/test/java/org/springframework/data/couchbase/repository/query/CouchbaseRepositoryQueryCollectionIntegrationTests.java
index 82d24e8d..44e51ecc 100644
--- a/src/test/java/org/springframework/data/couchbase/repository/query/CouchbaseRepositoryQueryCollectionIntegrationTests.java
+++ b/src/test/java/org/springframework/data/couchbase/repository/query/CouchbaseRepositoryQueryCollectionIntegrationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2021 the original author or authors.
+ * Copyright 2017-2022 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,7 +19,9 @@ import static com.couchbase.client.core.io.CollectionIdentifier.DEFAULT_SCOPE;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 
+import java.util.Arrays;
 import java.util.List;
+import java.util.UUID;
 
 import org.junit.jupiter.api.AfterAll;
 import org.junit.jupiter.api.AfterEach;
@@ -30,16 +32,27 @@ import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.context.ApplicationContext;
 import org.springframework.context.annotation.AnnotationConfigApplicationContext;
 import org.springframework.dao.DataRetrievalFailureException;
+import org.springframework.data.couchbase.core.CouchbaseTemplate;
+import org.springframework.data.couchbase.core.ReactiveCouchbaseTemplate;
+import org.springframework.data.couchbase.core.RemoveResult;
+import org.springframework.data.couchbase.domain.Address;
+import org.springframework.data.couchbase.domain.AddressAnnotated;
 import org.springframework.data.couchbase.domain.Airport;
 import org.springframework.data.couchbase.domain.AirportRepository;
+import org.springframework.data.couchbase.domain.CollectionsConfig;
 import org.springframework.data.couchbase.domain.Config;
 import org.springframework.data.couchbase.domain.User;
 import org.springframework.data.couchbase.domain.UserCol;
 import org.springframework.data.couchbase.domain.UserColRepository;
+import org.springframework.data.couchbase.domain.UserSubmissionAnnotated;
+import org.springframework.data.couchbase.domain.UserSubmissionAnnotatedRepository;
+import org.springframework.data.couchbase.domain.UserSubmissionUnannotated;
+import org.springframework.data.couchbase.domain.UserSubmissionUnannotatedRepository;
 import org.springframework.data.couchbase.util.Capabilities;
 import org.springframework.data.couchbase.util.ClusterType;
 import org.springframework.data.couchbase.util.CollectionAwareIntegrationTests;
 import org.springframework.data.couchbase.util.IgnoreWhen;
+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
 
 import com.couchbase.client.core.error.IndexFailureException;
 import com.couchbase.client.core.io.CollectionIdentifier;
@@ -48,10 +61,16 @@ import com.couchbase.client.java.query.QueryOptions;
 import com.couchbase.client.java.query.QueryScanConsistency;
 
 @IgnoreWhen(missesCapabilities = { Capabilities.QUERY, Capabilities.COLLECTIONS }, clusterTypes = ClusterType.MOCKED)
+@SpringJUnitConfig(CollectionsConfig.class)
 public class CouchbaseRepositoryQueryCollectionIntegrationTests extends CollectionAwareIntegrationTests {
 
 	@Autowired AirportRepository airportRepository;
 	@Autowired UserColRepository userColRepository;
+	@Autowired UserSubmissionAnnotatedRepository userSubmissionAnnotatedRepository;
+	@Autowired UserSubmissionUnannotatedRepository userSubmissionUnannotatedRepository;
+
+	@Autowired public CouchbaseTemplate couchbaseTemplate;
+	@Autowired public ReactiveCouchbaseTemplate reactiveCouchbaseTemplate;
 
 	@BeforeAll
 	public static void beforeAll() {
@@ -76,10 +95,10 @@ public class CouchbaseRepositoryQueryCollectionIntegrationTests extends Collecti
 		// then do processing for this class
 		couchbaseTemplate.removeByQuery(User.class).inCollection(collectionName).all();
 		couchbaseTemplate.removeByQuery(UserCol.class).inScope(otherScope).inCollection(otherCollection).all();
-		ApplicationContext ac = new AnnotationConfigApplicationContext(Config.class);
+		// ApplicationContext ac = new AnnotationConfigApplicationContext(Config.class);
 		// seems that @Autowired is not adequate, so ...
-		airportRepository = (AirportRepository) ac.getBean("airportRepository");
-		userColRepository = (UserColRepository) ac.getBean("userColRepository");
+		// airportRepository = (AirportRepository) ac.getBean("airportRepository");
+		// userColRepository = (UserColRepository) ac.getBean("userColRepository");
 	}
 
 	@AfterEach
@@ -91,6 +110,16 @@ public class CouchbaseRepositoryQueryCollectionIntegrationTests extends Collecti
 		super.afterEach();
 	}
 
+	@Test
+	void findByKey() {
+		UserCol userCol = new UserCol("101", "userColFirst", "userColLast");
+		userColRepository.save(userCol);
+		UserCol found = userColRepository.getById(userCol.getId());
+		System.err.println("found: " + found);
+		assertEquals(userCol, found);
+		userColRepository.delete(found);
+	}
+
 	@Test
 	public void myTest() {
 
@@ -198,9 +227,14 @@ public class CouchbaseRepositoryQueryCollectionIntegrationTests extends Collecti
 		// collection from CrudMethodMetadata of UserCol.save()
 		UserCol userCol = new UserCol("1", "Dave", "Wilson");
 		Airport airport = new Airport("3", "myIata", "myIcao");
+		try {
 			UserCol savedCol = userColRepository.save(userCol); // uses UserCol annotation scope, populates CrudMethodMetadata
 			userColRepository.delete(userCol); // uses UserCol annotation scope, populates CrudMethodMetadata
 			assertThrows(IllegalStateException.class, () -> airportRepository.save(airport));
+		} finally {
+			List<RemoveResult> removed = couchbaseTemplate.removeByQuery(Airport.class).all();
+			couchbaseTemplate.findByQuery(Airport.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).all();
+		}
 	}
 
 	// template default scope is my_scope
@@ -223,4 +257,116 @@ public class CouchbaseRepositoryQueryCollectionIntegrationTests extends Collecti
 			} catch (DataRetrievalFailureException drfe) {}
 		}
 	}
+
+	@Test
+	void findPlusN1qlJoinBothAnnotated() throws Exception {
+
+		// UserSubmissionAnnotated has scope=my_scope, collection=my_collection
+		UserSubmissionAnnotated user = new UserSubmissionAnnotated();
+		user.setId(UUID.randomUUID().toString());
+		user.setUsername("dave");
+		user = userSubmissionAnnotatedRepository.save(user);
+
+		// AddressesAnnotated has scope=dummy_scope, collection=my_collection2
+		// scope must be explicitly set on template insertById, findByQuery and removeById
+		// For userSubmissionAnnotatedRepository.findByUsername(), scope will be taken from UserSubmissionAnnotated
+		AddressAnnotated address1 = new AddressAnnotated();
+		address1.setId(UUID.randomUUID().toString());
+		address1.setStreet("3250 Olcott Street");
+		address1.setParentId(user.getId());
+		AddressAnnotated address2 = new AddressAnnotated();
+		address2.setId(UUID.randomUUID().toString());
+		address2.setStreet("148 Castro Street");
+		address2.setParentId(user.getId());
+		AddressAnnotated address3 = new AddressAnnotated();
+		address3.setId(UUID.randomUUID().toString());
+		address3.setStreet("123 Sesame Street");
+		address3.setParentId(UUID.randomUUID().toString()); // does not belong to user
+
+		try {
+
+			address1 = couchbaseTemplate.insertById(AddressAnnotated.class).inScope(scopeName).one(address1);
+			address2 = couchbaseTemplate.insertById(AddressAnnotated.class).inScope(scopeName).one(address2);
+			address3 = couchbaseTemplate.insertById(AddressAnnotated.class).inScope(scopeName).one(address3);
+			couchbaseTemplate.findByQuery(AddressAnnotated.class).inScope(scopeName).withConsistency(QueryScanConsistency.REQUEST_PLUS)
+					.all();
+
+			// scope for AddressesAnnotated in N1qlJoin comes from userSubmissionAnnotatedRepository.
+			List<UserSubmissionAnnotated> users = userSubmissionAnnotatedRepository.findByUsername(user.getUsername());
+			assertEquals(2, users.get(0).getOtherAddresses().size());
+			for (Address a : users.get(0).getOtherAddresses()) {
+				if (!(a.getStreet().equals(address1.getStreet()) || a.getStreet().equals(address2.getStreet()))) {
+					throw new Exception("street does not match : " + a);
+				}
+			}
+
+			UserSubmissionAnnotated foundUser = userSubmissionAnnotatedRepository.findById(user.getId()).get();
+			assertEquals(2, foundUser.getOtherAddresses().size());
+			for (Address a : foundUser.getOtherAddresses()) {
+				if (!(a.getStreet().equals(address1.getStreet()) || a.getStreet().equals(address2.getStreet()))) {
+					throw new Exception("street does not match : " + a);
+				}
+			}
+		} finally {
+			couchbaseTemplate.removeById(AddressAnnotated.class).inScope(scopeName)
+					.all(Arrays.asList(address1.getId(), address2.getId(), address3.getId()));
+			couchbaseTemplate.removeById(UserSubmissionAnnotated.class).one(user.getId());
+		}
+	}
+
+	@Test
+	void findPlusN1qlJoinUnannotated() throws Exception {
+		// UserSubmissionAnnotated has scope=my_scope, collection=my_collection
+		UserSubmissionUnannotated user = new UserSubmissionUnannotated();
+		user.setId(UUID.randomUUID().toString());
+		user.setUsername("dave");
+		user = userSubmissionUnannotatedRepository.save(user);
+
+		// AddressesAnnotated has scope=dummy_scope, collection=my_collection2
+		// scope must be explicitly set on template insertById, findByQuery and removeById
+		// For userSubmissionAnnotatedRepository.findByUsername(), scope will be taken from UserSubmissionAnnotated
+		AddressAnnotated address1 = new AddressAnnotated();
+		address1.setId(UUID.randomUUID().toString());
+		address1.setStreet("3250 Olcott Street");
+		address1.setParentId(user.getId());
+		AddressAnnotated address2 = new AddressAnnotated();
+		address2.setId(UUID.randomUUID().toString());
+		address2.setStreet("148 Castro Street");
+		address2.setParentId(user.getId());
+		AddressAnnotated address3 = new AddressAnnotated();
+		address3.setId(UUID.randomUUID().toString());
+		address3.setStreet("123 Sesame Street");
+		address3.setParentId(UUID.randomUUID().toString()); // does not belong to user
+
+		try {
+
+			address1 = couchbaseTemplate.insertById(AddressAnnotated.class).inScope(scopeName).one(address1);
+			address2 = couchbaseTemplate.insertById(AddressAnnotated.class).inScope(scopeName).one(address2);
+			address3 = couchbaseTemplate.insertById(AddressAnnotated.class).inScope(scopeName).one(address3);
+			couchbaseTemplate.findByQuery(AddressAnnotated.class).inScope(scopeName).withConsistency(QueryScanConsistency.REQUEST_PLUS)
+					.all();
+
+			// scope for AddressesAnnotated in N1qlJoin comes from userSubmissionAnnotatedRepository.
+			List<UserSubmissionUnannotated> users = userSubmissionUnannotatedRepository.findByUsername(user.getUsername());
+			assertEquals(2, users.get(0).getOtherAddresses().size());
+			for (Address a : users.get(0).getOtherAddresses()) {
+				if (!(a.getStreet().equals(address1.getStreet()) || a.getStreet().equals(address2.getStreet()))) {
+					throw new Exception("street does not match : " + a);
+				}
+			}
+
+			UserSubmissionUnannotated foundUser = userSubmissionUnannotatedRepository.findById(user.getId()).get();
+			assertEquals(2, foundUser.getOtherAddresses().size());
+			for (Address a : foundUser.getOtherAddresses()) {
+				if (!(a.getStreet().equals(address1.getStreet()) || a.getStreet().equals(address2.getStreet()))) {
+					throw new Exception("street does not match : " + a);
+				}
+			}
+		} finally {
+			couchbaseTemplate.removeById(AddressAnnotated.class).inScope(scopeName)
+					.all(Arrays.asList(address1.getId(), address2.getId(), address3.getId()));
+			couchbaseTemplate.removeById(UserSubmissionUnannotated.class).one(user.getId());
+		}
+	}
+
 }
diff --git a/src/test/java/org/springframework/data/couchbase/repository/query/N1qlQueryCreatorTests.java b/src/test/java/org/springframework/data/couchbase/repository/query/N1qlQueryCreatorTests.java
index 52fe975b..5a610849 100644
--- a/src/test/java/org/springframework/data/couchbase/repository/query/N1qlQueryCreatorTests.java
+++ b/src/test/java/org/springframework/data/couchbase/repository/query/N1qlQueryCreatorTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2021 the original author or authors.
+ * Copyright 2017-2022 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -109,7 +109,7 @@ class N1qlQueryCreatorTests {
 		Query query = creator.createQuery();
 
 		// Query expected = (new Query()).addCriteria(where("firstname").in("Oliver", "Charles"));
-		assertEquals(expected.export(new int[1]), query.export(new int[1]));
+		assertEquals(" WHERE `firstname` in $1", query.export(new int[1]));
 		JsonObject expectedOptions = JsonObject.create();
 		expected.buildQueryOptions(null, null).build().injectParams(expectedOptions);
 		JsonObject actualOptions = JsonObject.create();
@@ -132,7 +132,7 @@ class N1qlQueryCreatorTests {
 		Query query = creator.createQuery();
 
 		Query expected = (new Query()).addCriteria(where(i("firstname")).in("Oliver", "Charles"));
-		assertEquals(expected.export(new int[1]), query.export(new int[1]));
+		assertEquals(" WHERE `firstname` in $1", query.export(new int[1]));
 		JsonObject expectedOptions = JsonObject.create();
 		expected.buildQueryOptions(null, null).build().injectParams(expectedOptions);
 		JsonObject actualOptions = JsonObject.create();
@@ -156,7 +156,7 @@ class N1qlQueryCreatorTests {
 
 		Query expected = (new Query()).addCriteria(where(i("firstname")).in("Oliver", "Charles"));
 
-		assertEquals(expected.export(new int[1]), query.export(new int[1]));
+		assertEquals(" WHERE `firstname` in $1", query.export(new int[1]));
 		JsonObject expectedOptions = JsonObject.create();
 		expected.buildQueryOptions(null, null).build().injectParams(expectedOptions);
 		JsonObject actualOptions = JsonObject.create();
@@ -189,8 +189,8 @@ class N1qlQueryCreatorTests {
 				converter, bucketName);
 		Query query = creator.createQuery();
 
-		assertEquals(query.export(),
-				" WHERE " + where(x("META(`" + bucketName + "`).`id`")).isNotNull().and(i("firstname")).is("Oliver").export());
+		assertEquals(" WHERE " + where(x("META().`id`")).isNotNull().and(i("firstname")).is("Oliver").export(),
+				query.export());
 	}
 
 	@Test // https://github.com/spring-projects/spring-data-couchbase/issues/1072
@@ -204,8 +204,9 @@ class N1qlQueryCreatorTests {
 				getAccessor(getParameters(method), 1611287177404088320L, "Oliver"), queryMethod, converter, bucketName);
 		Query query = creator.createQuery();
 
-		assertEquals(query.export(), " WHERE " + where(x("META(`" + bucketName + "`).`cas`")).is(1611287177404088320L)
-				.and(i("firstname")).is("Oliver").export());
+		assertEquals(
+				" WHERE " + where(x("META().`cas`")).is(1611287177404088320L).and(i("firstname")).is("Oliver").export(),
+				query.export());
 	}
 
 	private ParameterAccessor getAccessor(Parameters<?, ?> params, Object... values) {
diff --git a/src/test/java/org/springframework/data/couchbase/repository/query/ReactiveCouchbaseRepositoryQueryCollectionIntegrationTests.java b/src/test/java/org/springframework/data/couchbase/repository/query/ReactiveCouchbaseRepositoryQueryCollectionIntegrationTests.java
index 51f6a5ef..0318d463 100644
--- a/src/test/java/org/springframework/data/couchbase/repository/query/ReactiveCouchbaseRepositoryQueryCollectionIntegrationTests.java
+++ b/src/test/java/org/springframework/data/couchbase/repository/query/ReactiveCouchbaseRepositoryQueryCollectionIntegrationTests.java
@@ -29,7 +29,10 @@ import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.context.ApplicationContext;
 import org.springframework.context.annotation.AnnotationConfigApplicationContext;
 import org.springframework.dao.DataRetrievalFailureException;
+import org.springframework.data.couchbase.core.CouchbaseTemplate;
+import org.springframework.data.couchbase.core.ReactiveCouchbaseTemplate;
 import org.springframework.data.couchbase.domain.Airport;
+import org.springframework.data.couchbase.domain.CollectionsConfig;
 import org.springframework.data.couchbase.domain.Config;
 import org.springframework.data.couchbase.domain.ReactiveAirportRepository;
 import org.springframework.data.couchbase.domain.ReactiveUserColRepository;
@@ -39,6 +42,7 @@ import org.springframework.data.couchbase.util.Capabilities;
 import org.springframework.data.couchbase.util.ClusterType;
 import org.springframework.data.couchbase.util.CollectionAwareIntegrationTests;
 import org.springframework.data.couchbase.util.IgnoreWhen;
+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
 
 import com.couchbase.client.core.error.IndexFailureException;
 import com.couchbase.client.core.io.CollectionIdentifier;
@@ -47,10 +51,13 @@ import com.couchbase.client.java.query.QueryOptions;
 import com.couchbase.client.java.query.QueryScanConsistency;
 
 @IgnoreWhen(missesCapabilities = { Capabilities.QUERY, Capabilities.COLLECTIONS }, clusterTypes = ClusterType.MOCKED)
+@SpringJUnitConfig(CollectionsConfig.class)
 public class ReactiveCouchbaseRepositoryQueryCollectionIntegrationTests extends CollectionAwareIntegrationTests {
 
 	@Autowired ReactiveAirportRepository airportRepository;
 	@Autowired ReactiveUserColRepository userColRepository;
+	@Autowired public CouchbaseTemplate couchbaseTemplate;
+	@Autowired public ReactiveCouchbaseTemplate reactiveCouchbaseTemplate;
 
 	@BeforeAll
 	public static void beforeAll() {
diff --git a/src/test/java/org/springframework/data/couchbase/repository/query/StringN1qlQueryCreatorMockedTests.java b/src/test/java/org/springframework/data/couchbase/repository/query/StringN1qlQueryCreatorMockedTests.java
index a0de49fe..516f4c9c 100644
--- a/src/test/java/org/springframework/data/couchbase/repository/query/StringN1qlQueryCreatorMockedTests.java
+++ b/src/test/java/org/springframework/data/couchbase/repository/query/StringN1qlQueryCreatorMockedTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2019 the original author or authors.
+ * Copyright 2017-2022 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -85,7 +85,7 @@ class StringN1qlQueryCreatorMockedTests extends ClusterAwareIntegrationTests {
 
 		Query query = creator.createQuery();
 		assertEquals(
-				"SELECT META(`travel-sample`).id AS __id, META(`travel-sample`).cas AS __cas, `travel-sample`.* FROM `travel-sample` where `_class` = \"org.springframework.data.couchbase.domain.User\" and firstname = $1 and lastname = $2",
+				"SELECT META(`travel-sample`).id AS __id, META(`travel-sample`).cas AS __cas, `_class`, `createdBy`, `createdDate`, `lastModifiedBy`, `lastModifiedDate`, `firstname`, `lastname`, `subtype` FROM `travel-sample` where `_class` = \"abstractuser\" and firstname = $1 and lastname = $2",
 				query.toN1qlSelectString(couchbaseTemplate.reactive(), User.class, false));
 	}
 
@@ -104,7 +104,7 @@ class StringN1qlQueryCreatorMockedTests extends ClusterAwareIntegrationTests {
 
 		Query query = creator.createQuery();
 		assertEquals(
-				"SELECT META(`travel-sample`).id AS __id, META(`travel-sample`).cas AS __cas, `travel-sample`.* FROM `travel-sample` where `_class` = \"org.springframework.data.couchbase.domain.User\" and (firstname = $first or lastname = $last)",
+				"SELECT META(`travel-sample`).id AS __id, META(`travel-sample`).cas AS __cas, `_class`, `createdBy`, `createdDate`, `lastModifiedBy`, `lastModifiedDate`, `firstname`, `lastname`, `subtype` FROM `travel-sample` where `_class` = \"abstractuser\" and (firstname = $first or lastname = $last)",
 				query.toN1qlSelectString(couchbaseTemplate.reactive(), User.class, false));
 	}
 
diff --git a/src/test/java/org/springframework/data/couchbase/repository/query/StringN1qlQueryCreatorTests.java b/src/test/java/org/springframework/data/couchbase/repository/query/StringN1qlQueryCreatorTests.java
index 72f657d2..50c66366 100644
--- a/src/test/java/org/springframework/data/couchbase/repository/query/StringN1qlQueryCreatorTests.java
+++ b/src/test/java/org/springframework/data/couchbase/repository/query/StringN1qlQueryCreatorTests.java
@@ -23,7 +23,6 @@ import java.util.Optional;
 import java.util.Properties;
 import java.util.UUID;
 
-import com.couchbase.client.java.query.QueryScanConsistency;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.springframework.context.ApplicationContext;
@@ -58,6 +57,8 @@ import org.springframework.data.repository.query.QueryMethodEvaluationContextPro
 import org.springframework.expression.spel.standard.SpelExpressionParser;
 import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
 
+import com.couchbase.client.java.query.QueryScanConsistency;
+
 /**
  * @author Michael Nitschinger
  * @author Michael Reiche
@@ -99,8 +100,8 @@ class StringN1qlQueryCreatorTests extends ClusterAwareIntegrationTests {
 
 			Query query = creator.createQuery();
 
-			ExecutableFindByQuery q = (ExecutableFindByQuery) couchbaseTemplate
-					.findByQuery(Airline.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).matching(query);
+			ExecutableFindByQuery q = (ExecutableFindByQuery) couchbaseTemplate.findByQuery(Airline.class).matching(query)
+					.withConsistency(QueryScanConsistency.REQUEST_PLUS);
 
 			Optional<Airline> al = q.one();
 			assertEquals(airline.toString(), al.get().toString());
diff --git a/src/test/java/org/springframework/data/couchbase/transactions/AfterTransactionAssertion.java b/src/test/java/org/springframework/data/couchbase/transactions/AfterTransactionAssertion.java
new file mode 100644
index 00000000..1771e909
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/transactions/AfterTransactionAssertion.java
@@ -0,0 +1,33 @@
+package org.springframework.data.couchbase.transactions;
+
+import lombok.Data;
+
+import org.springframework.data.domain.Persistable;
+
+/**
+ * @author Christoph Strobl
+ * @currentRead Shadow's Edge - Brent Weeks
+ */
+@Data
+public class AfterTransactionAssertion<T extends Persistable> {
+
+  private final T persistable;
+  private boolean expectToBePresent;
+
+  public void isPresent() {
+    expectToBePresent = true;
+  }
+
+  public void isNotPresent() {
+    expectToBePresent = false;
+  }
+
+  public Object getId() {
+    return persistable.getId();
+  }
+
+  public boolean shouldBePresent() {
+    return expectToBePresent;
+  }
+}
+
diff --git a/src/test/java/org/springframework/data/couchbase/transactions/Config.java b/src/test/java/org/springframework/data/couchbase/transactions/Config.java
new file mode 100644
index 00000000..e9193f29
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/transactions/Config.java
@@ -0,0 +1,74 @@
+package org.springframework.data.couchbase.transactions;
+
+import java.time.Duration;
+
+import com.couchbase.client.core.msg.kv.DurabilityLevel;
+import com.couchbase.client.core.transaction.config.CoreTransactionsConfig;
+import com.couchbase.client.java.transactions.config.TransactionsConfig;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.data.couchbase.config.AbstractCouchbaseConfiguration;
+import org.springframework.data.couchbase.repository.config.EnableCouchbaseRepositories;
+import org.springframework.data.couchbase.repository.config.EnableReactiveCouchbaseRepositories;
+import org.springframework.data.couchbase.util.ClusterAwareIntegrationTests;
+import org.springframework.transaction.annotation.EnableTransactionManagement;
+
+import com.couchbase.client.java.transactions.config.TransactionOptions;
+
+@Configuration
+@EnableCouchbaseRepositories("org.springframework.data.couchbase")
+@EnableReactiveCouchbaseRepositories("org.springframework.data.couchbase")
+@EnableTransactionManagement
+class Config extends AbstractCouchbaseConfiguration {
+
+	@Override
+	public String getConnectionString() {
+		return ClusterAwareIntegrationTests.connectionString();
+	}
+
+	@Override
+	public String getUserName() {
+		return ClusterAwareIntegrationTests.config().adminUsername();
+	}
+
+	@Override
+	public String getPassword() {
+		return ClusterAwareIntegrationTests.config().adminPassword();
+	}
+
+	@Override
+	public String getBucketName() {
+		return ClusterAwareIntegrationTests.bucketName();
+	}
+
+	@Override
+	public TransactionsConfig.Builder transactionsConfig() {
+		return TransactionsConfig.builder().durabilityLevel(DurabilityLevel.NONE).timeout(Duration.ofMinutes(20));// for testing
+	}
+
+	/*
+	@Override
+	public TransactionsConfig transactionConfig() {
+	  // expirationTime 20 minutes for stepping with the debugger
+	  return TransactionsConfig.create()
+	      .logDirectly(Event.Severity.INFO)
+	      .logOnFailure(true,
+	          Event.Severity.ERROR)
+	      .expirationTime(Duration.ofMinutes(20))
+	      .durabilityLevel(TransactionDurabilityLevel.MAJORITY)
+	      .build();
+	}
+	*/
+	/*
+	    beforeAll creates a PersonService bean in the applicationContext
+	
+	    context = new AnnotationConfigApplicationContext(CouchbasePersonTransactionIntegrationTests.Config.class,
+	    PersonService.class);
+	
+	    @Bean("personService")
+	        PersonService getPersonService(CouchbaseOperations ops, CouchbaseTransactionManager mgr,
+	                                       ReactiveCouchbaseOperations opsRx, ReactiveCouchbaseTransactionManager mgrRx) {
+	          return new PersonService(ops, mgr, opsRx, mgrRx);
+	        }
+	*/
+
+}
diff --git a/src/test/java/org/springframework/data/couchbase/transactions/CouchbasePersonTransactionIntegrationTests.java b/src/test/java/org/springframework/data/couchbase/transactions/CouchbasePersonTransactionIntegrationTests.java
new file mode 100644
index 00000000..4a5e54ac
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/transactions/CouchbasePersonTransactionIntegrationTests.java
@@ -0,0 +1,891 @@
+/*
+ * Copyright 2012-2021 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.data.couchbase.transactions;
+
+import static com.couchbase.client.java.query.QueryScanConsistency.REQUEST_PLUS;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.springframework.data.couchbase.util.Util.assertInAnnotationTransaction;
+
+import com.couchbase.client.core.transaction.CoreTransactionAttemptContext;
+import com.couchbase.client.java.transactions.AttemptContextReactiveAccessor;
+import com.couchbase.client.java.transactions.config.TransactionOptions;
+import lombok.Data;
+import reactor.core.publisher.Flux;
+import reactor.core.publisher.Mono;
+import reactor.util.retry.Retry;
+
+import java.time.Duration;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Disabled;
+import org.junit.jupiter.api.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.dao.DataRetrievalFailureException;
+import org.springframework.dao.DuplicateKeyException;
+import org.springframework.data.couchbase.CouchbaseClientFactory;
+import org.springframework.data.couchbase.ReactiveCouchbaseClientFactory;
+import org.springframework.data.couchbase.config.BeanNames;
+import org.springframework.data.couchbase.core.CouchbaseOperations;
+import org.springframework.data.couchbase.core.CouchbaseTemplate;
+import org.springframework.data.couchbase.core.ReactiveCouchbaseOperations;
+import org.springframework.data.couchbase.core.ReactiveCouchbaseTemplate;
+import org.springframework.data.couchbase.core.RemoveResult;
+import org.springframework.data.couchbase.core.query.Query;
+import org.springframework.data.couchbase.core.query.QueryCriteria;
+import org.springframework.data.couchbase.domain.Person;
+import org.springframework.data.couchbase.domain.PersonRepository;
+import org.springframework.data.couchbase.domain.ReactivePersonRepository;
+import org.springframework.data.couchbase.transaction.CouchbaseSimpleCallbackTransactionManager;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionDefinition;
+import org.springframework.data.couchbase.transaction.ReactiveCouchbaseResourceHolder;
+import org.springframework.data.couchbase.transaction.ReactiveCouchbaseTransactionManager;
+import org.springframework.data.couchbase.transaction.ReactiveTransactionsWrapper;
+import org.springframework.data.couchbase.transaction.TransactionsWrapper;
+import org.springframework.data.couchbase.util.Capabilities;
+import org.springframework.data.couchbase.util.ClusterType;
+import org.springframework.data.couchbase.util.IgnoreWhen;
+import org.springframework.data.couchbase.util.JavaIntegrationTests;
+import org.springframework.stereotype.Component;
+import org.springframework.stereotype.Service;
+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
+import org.springframework.transaction.annotation.EnableTransactionManagement;
+import org.springframework.transaction.annotation.Transactional;
+import org.springframework.transaction.ReactiveTransaction;
+import org.springframework.transaction.TransactionDefinition;
+import org.springframework.transaction.annotation.EnableTransactionManagement;
+import org.springframework.transaction.annotation.Transactional;
+import org.springframework.transaction.reactive.TransactionContextManager;
+import org.springframework.transaction.reactive.TransactionSynchronizationManager;
+import org.springframework.transaction.reactive.TransactionalOperator;
+import org.springframework.transaction.support.DefaultTransactionDefinition;
+
+import com.couchbase.client.core.error.DocumentNotFoundException;
+import com.couchbase.client.core.error.transaction.RetryTransactionException;
+import com.couchbase.client.core.error.transaction.TransactionOperationFailedException;
+import com.couchbase.client.java.Collection;
+import com.couchbase.client.java.ReactiveCollection;
+import com.couchbase.client.java.kv.RemoveOptions;
+import com.couchbase.client.java.transactions.TransactionResult;
+import com.couchbase.client.java.transactions.Transactions;
+import com.couchbase.client.java.transactions.error.TransactionFailedException;
+
+/**
+ * Tests for com.couchbase.transactions using
+ * <li><le>couchbase reactive transaction manager via transactional operator</le> <le>couchbase non-reactive transaction
+ * manager via @Transactional</le> <le>@Transactional(transactionManager =
+ * BeanNames.REACTIVE_COUCHBASE_TRANSACTION_MANAGER)</le></li>
+ *
+ * @author Michael Reiche
+ */
+@IgnoreWhen(missesCapabilities = Capabilities.QUERY, clusterTypes = ClusterType.MOCKED)
+@SpringJUnitConfig(classes = { Config.class, CouchbasePersonTransactionIntegrationTests.PersonService.class })
+public class CouchbasePersonTransactionIntegrationTests extends JavaIntegrationTests {
+
+	@Autowired CouchbaseClientFactory couchbaseClientFactory;
+	@Autowired ReactiveCouchbaseClientFactory reactiveCouchbaseClientFactory;
+	@Autowired ReactiveCouchbaseTransactionManager reactiveCouchbaseTransactionManager;
+	@Autowired ReactivePersonRepository rxRepo;
+	@Autowired PersonRepository repo;
+	@Autowired CouchbaseTemplate cbTmpl;
+	@Autowired ReactiveCouchbaseTemplate rxCBTmpl;
+	@Autowired PersonService personService;
+	@Autowired CouchbaseTemplate operations;
+
+	// if these are changed from default, then beforeEach needs to clean up separately
+	String sName = "_default";
+	String cName = "_default";
+	private TransactionalOperator transactionalOperator;
+
+	@BeforeAll
+	public static void beforeAll() {
+		callSuperBeforeAll(new Object() {});
+	}
+
+	@AfterAll
+	public static void afterAll() {
+		callSuperAfterAll(new Object() {});
+	}
+
+	@BeforeEach
+	public void beforeEachTest() {
+		List<RemoveResult> rp0 = operations.removeByQuery(Person.class).withConsistency(REQUEST_PLUS).all();
+		List<RemoveResult> rp1 = operations.removeByQuery(Person.class).inScope(sName).inCollection(cName)
+				.withConsistency(REQUEST_PLUS).all();
+		List<RemoveResult> rp2 = operations.removeByQuery(EventLog.class).withConsistency(REQUEST_PLUS).all();
+		List<RemoveResult> rp3 = operations.removeByQuery(EventLog.class).inScope(sName).inCollection(cName)
+				.withConsistency(REQUEST_PLUS).all();
+
+		List<Person> p0 = operations.findByQuery(Person.class).withConsistency(REQUEST_PLUS).all();
+		List<Person> p1 = operations.findByQuery(Person.class).inScope(sName).inCollection(cName)
+				.withConsistency(REQUEST_PLUS).all();
+		List<EventLog> e0 = operations.findByQuery(EventLog.class).withConsistency(REQUEST_PLUS).all();
+		List<EventLog> e1 = operations.findByQuery(EventLog.class).inScope(sName).inCollection(cName)
+				.withConsistency(REQUEST_PLUS).all();
+
+		Person walterWhite = new Person(1, "Walter", "White");
+		remove(cbTmpl, sName, cName, walterWhite.getId().toString());
+		transactionalOperator = TransactionalOperator.create(reactiveCouchbaseTransactionManager);
+	}
+
+	@Test
+	public void shouldRollbackAfterException() {
+		Person p = new Person(null, "Walter", "White");
+		assertThrows(SimulateFailureException.class, () -> personService.savePersonErrors(p));
+		Long count = operations.findByQuery(Person.class).withConsistency(REQUEST_PLUS).count();
+		assertEquals(0, count, "should have done roll back and left 0 entries");
+	}
+
+	@Test
+	public void shouldRollbackAfterExceptionOfTxAnnotatedMethod() {
+		Person p = new Person(null, "Walter", "White");
+		assertThrowsOneOf(() -> personService.declarativeSavePersonErrors(p), TransactionFailedException.class);
+		Long count = operations.findByQuery(Person.class).withConsistency(REQUEST_PLUS).count();
+		assertEquals(0, count, "should have done roll back and left 0 entries");
+	}
+
+	@Test
+	public void shouldRollbackAfterExceptionOfTxAnnotatedMethodReactive() {
+		Person p = new Person(null, "Walter", "White");
+		assertThrows(SimulateFailureException.class, () -> personService.declarativeSavePersonErrorsReactive(p).block());
+		Long count = operations.findByQuery(Person.class).withConsistency(REQUEST_PLUS).count();
+		assertEquals(0, count, "should have done roll back and left 0 entries");
+	}
+
+	@Test
+	public void commitShouldPersistTxEntries() {
+		Person p = new Person(null, "Walter", "White");
+		Person s = personService.savePerson(p);
+		Long count = operations.findByQuery(Person.class).withConsistency(REQUEST_PLUS).count();
+		assertEquals(1, count, "should have saved and found 1");
+	}
+
+	@Test
+	public void commitShouldPersistTxEntriesOfTxAnnotatedMethod() {
+		Person p = new Person(null, "Walter", "White");
+		Person s = personService.declarativeSavePerson(p);
+		Long count = operations.findByQuery(Person.class).withConsistency(REQUEST_PLUS).count();
+		assertEquals(1, count, "should have saved and found 1");
+	}
+
+	@Test
+	public void replaceInTxAnnotatedCallback() {
+		Person person = new Person(1, "Walter", "White");
+		Person switchedPerson = new Person(1, "Dave", "Reynolds");
+		cbTmpl.insertById(Person.class).one(person);
+		AtomicInteger tryCount = new AtomicInteger(0);
+		Person p = personService.declarativeFindReplacePersonCallback(switchedPerson, tryCount);
+		Person pFound = rxCBTmpl.findById(Person.class).one(person.getId().toString()).block();
+		assertEquals(switchedPerson.getFirstname(), pFound.getFirstname(), "should have been switched");
+	}
+
+	@Test
+	public void commitShouldPersistTxEntriesOfTxAnnotatedMethodReactive() {
+		Person p = new Person(null, "Walter", "White");
+		Person s = personService.declarativeSavePersonReactive(p).block();
+		Long count = operations.findByQuery(Person.class).withConsistency(REQUEST_PLUS).count();
+		assertEquals(1, count, "should have saved and found 1");
+	}
+
+	@Test
+	public void commitShouldPersistTxEntriesAcrossCollections() {
+		List<EventLog> persons = personService.saveWithLogs(new Person(null, "Walter", "White"));
+		Long count = operations.findByQuery(Person.class).withConsistency(REQUEST_PLUS).count();
+		assertEquals(1, count, "should have saved and found 1");
+		Long countEvents = operations.count(new Query(), EventLog.class); //
+		assertEquals(4, countEvents, "should have saved and found 4");
+	}
+
+	@Test
+	public void rollbackShouldAbortAcrossCollections() {
+		assertThrows(SimulateFailureException.class,
+				() -> personService.saveWithErrorLogs(new Person(null, "Walter", "White")));
+		List<Person> persons = operations.findByQuery(Person.class).withConsistency(REQUEST_PLUS).all();
+		assertEquals(0, persons.size(), "should have done roll back and left 0 entries");
+		List<EventLog> events = operations.findByQuery(EventLog.class).withConsistency(REQUEST_PLUS).all(); //
+		assertEquals(0, events.size(), "should have done roll back and left 0 entries");
+	}
+
+	@Test
+	public void countShouldWorkInsideTransaction() {
+		Long count = personService.countDuringTx(new Person(null, "Walter", "White"));
+		assertEquals(1, count, "should have counted 1 during tx");
+	}
+
+	@Test
+	public void emitMultipleElementsDuringTransaction() {
+		List<EventLog> docs = personService.saveWithLogs(new Person(null, "Walter", "White"));
+		assertEquals(4, docs.size(), "should have found 4 eventlogs");
+	}
+
+	@Test
+	public void errorAfterTxShouldNotAffectPreviousStep() {
+		Person p = personService.savePerson(new Person(null, "Walter", "White"));
+		// todo gp user shouldn't be getting exposed to TransactionOperationFailedException
+		// todo mr
+		/*
+		TransactionOperationFailedException {cause:com.couchbase.client.core.error.DocumentExistsException, retry:false, autoRollback:true, raise:TRANSACTION_FAILED}
+		at com.couchbase.client.core.error.transaction.TransactionOperationFailedException$Builder.build(TransactionOperationFailedException.java:136)
+		at com.couchbase.client.core.transaction.CoreTransactionAttemptContext.lambda$handleDocExistsDuringStagedInsert$116(CoreTransactionAttemptContext.java:1801)
+		 */
+		assertThrows(TransactionOperationFailedException.class, () -> personService.savePerson(p));
+		Long count = operations.findByQuery(Person.class).withConsistency(REQUEST_PLUS).count();
+		assertEquals(1, count, "should have saved and found 1");
+	}
+
+	/**
+	 * This will appear to work even if replaceById does not use a transaction.
+	 */
+	@Test
+	@Disabled
+	public void replacePersonCBTransactionsRxTmpl() {
+		Person person = new Person(1, "Walter", "White");
+		cbTmpl.insertById(Person.class).one(person);
+		Mono<Person> result = rxCBTmpl.findById(Person.class).one(person.getId().toString()) //
+				.flatMap((pp) -> rxCBTmpl.replaceById(Person.class).one(pp)) //
+				.as(transactionalOperator::transactional);
+		result.block();
+		Person pFound = rxCBTmpl.findById(Person.class).one(person.getId().toString()).block();
+		assertEquals(person, pFound, "should have found expected " + person);
+	}
+
+	@Test
+	public void insertPersonCBTransactionsRxTmplRollback() {
+		Person person = new Person(1, "Walter", "White");
+		Mono<Person> result = rxCBTmpl.insertById(Person.class).one(person) //
+				.flatMap(p -> throwSimulatedFailure(p)).as(transactionalOperator::transactional); // tx
+		assertThrows(SimulateFailureException.class, result::block);
+		Person pFound = rxCBTmpl.findById(Person.class).one(person.getId().toString()).block();
+		assertNull(pFound, "insert should have been rolled back");
+	}
+
+	@Test
+	public void insertTwicePersonCBTransactionsRxTmplRollback() {
+		Person person = new Person(1, "Walter", "White");
+		Mono<Person> result = rxCBTmpl.insertById(Person.class).one(person) //
+				.flatMap((ppp) -> rxCBTmpl.insertById(Person.class).one(ppp)) //
+				.as(transactionalOperator::transactional);
+		assertThrows(DuplicateKeyException.class, result::block);
+		Person pFound = rxCBTmpl.findById(Person.class).one(person.getId().toString()).block();
+		assertNull(pFound, "insert should have been rolled back");
+	}
+
+	/**
+	 * This test has the bare minimum for reactive transactions. Create the ClientSession that holds the ctx and put it in
+	 * a resourceHolder and binds it to the currentContext. The retries are handled by couchbase-transactions - which
+	 * creates a new ctx and re-runs the lambda. This is essentially what TransactionWrapper does.
+	 */
+	@Test
+	public void wrapperReplaceWithCasConflictResolvedViaRetry() {
+		Person person = new Person(1, "Walter", "White");
+		Person switchedPerson = new Person(1, "Dave", "Reynolds");
+		AtomicInteger tryCount = new AtomicInteger(0);
+		cbTmpl.insertById(Person.class).one(person);
+
+		for (int i = 0; i < 50; i++) { // the transaction sometimes succeeds on the first try
+			ReplaceLoopThread t = new ReplaceLoopThread(switchedPerson);
+			t.start();
+			tryCount.set(0);
+			TransactionsWrapper transactionsWrapper = new TransactionsWrapper(couchbaseClientFactory);
+			TransactionResult txResult = transactionsWrapper.run(ctx -> {
+				System.err.println("try: " + tryCount.incrementAndGet());
+				Person ppp = cbTmpl.findById(Person.class).one(person.getId().toString());
+				Person pppp = cbTmpl.replaceById(Person.class).one(ppp);
+			});
+			System.out.println("txResult: " + txResult);
+			t.setStopFlag();
+			if (tryCount.get() > 1) {
+				break;
+			}
+		}
+		Person pFound = cbTmpl.findById(Person.class).one(person.getId().toString());
+		assertTrue(tryCount.get() > 1, "should have been more than one try. tries: " + tryCount.get());
+		assertEquals(switchedPerson.getFirstname(), pFound.getFirstname(), "should have been switched");
+	}
+
+	@Test
+	public void wrapperReplaceWithCasConflictResolvedViaRetryReactive() {
+		Person person = new Person(1, "Walter", "White");
+		Person switchedPerson = new Person(1, "Dave", "Reynolds");
+		AtomicInteger tryCount = new AtomicInteger(0);
+		cbTmpl.insertById(Person.class).one(person);
+
+		for (int i = 0; i < 50; i++) { // the transaction sometimes succeeds on the first try
+			ReplaceLoopThread t = new ReplaceLoopThread(switchedPerson);
+			t.start();
+			tryCount.set(0);
+			ReactiveTransactionsWrapper reactiveTransactionsWrapper = new ReactiveTransactionsWrapper(
+					reactiveCouchbaseClientFactory);
+			Mono<TransactionResult> result = reactiveTransactionsWrapper.run(ctx -> {
+				System.err.println("try: " + tryCount.incrementAndGet());
+				return rxCBTmpl.findById(Person.class).one(person.getId().toString()) //
+						.flatMap((ppp) -> rxCBTmpl.replaceById(Person.class).one(ppp)).then();
+			});
+			TransactionResult txResult = result.block();
+			System.out.println("txResult: " + txResult);
+			t.setStopFlag();
+			if (tryCount.get() > 1) {
+				break;
+			}
+		}
+		Person pFound = rxCBTmpl.findById(Person.class).one(person.getId().toString()).block();
+		assertTrue(tryCount.get() > 1, "should have been more than one try. tries: " + tryCount.get());
+		assertEquals(switchedPerson.getFirstname(), pFound.getFirstname(), "should have been switched");
+	}
+
+	/**
+	 * This does process retries - by CallbackTransactionManager.execute() -> transactions.run() -> executeTransaction()
+	 * -> retryWhen.
+	 */
+	@Test
+	public void replaceWithCasConflictResolvedViaRetryAnnotatedCallback() {
+		Person person = new Person(1, "Walter", "White");
+		Person switchedPerson = new Person(1, "Dave", "Reynolds");
+		AtomicInteger tryCount = new AtomicInteger(0);
+		cbTmpl.insertById(Person.class).one(person);
+
+		for (int i = 0; i < 50; i++) { // the transaction sometimes succeeds on the first try
+			ReplaceLoopThread t = new ReplaceLoopThread(switchedPerson);
+			t.start();
+			tryCount.set(0);
+			Person p = personService.declarativeFindReplacePersonCallback(switchedPerson, tryCount);
+			t.setStopFlag();
+			if (tryCount.get() > 1) {
+				break;
+			}
+		}
+		Person pFound = rxCBTmpl.findById(Person.class).one(person.getId().toString()).block();
+		assertEquals(switchedPerson.getFirstname(), pFound.getFirstname(), "should have been switched");
+		assertTrue(tryCount.get() > 1, "should have been more than one try. tries: " + tryCount.get());
+	}
+
+	/**
+	 * Reactive @Transactional does not retry write-write conflicts. It throws RetryTransactionException up to the client
+	 * and expects the client to retry.
+	 */
+	@Test
+	public void replaceWithCasConflictResolvedViaRetryAnnotatedReactive() {
+		Person person = new Person(1, "Walter", "White");
+		Person switchedPerson = new Person(1, "Dave", "Reynolds");
+		cbTmpl.insertById(Person.class).one(person);
+		AtomicInteger tryCount = new AtomicInteger(0);
+		for (int i = 0; i < 50; i++) { // the transaction sometimes succeeds on the first try
+			ReplaceLoopThread t = new ReplaceLoopThread(switchedPerson);
+			t.start();
+			tryCount.set(0);
+			// TODO mr - Graham says not to do delegate retries to user. He's a party pooper.
+			Person res = personService.declarativeFindReplacePersonReactive(switchedPerson, tryCount)
+					.retryWhen(Retry.backoff(10, Duration.ofMillis(50))
+							.filter(throwable -> throwable instanceof TransactionOperationFailedException)
+							.onRetryExhaustedThrow((retryBackoffSpec, retrySignal) -> {
+								throw new RuntimeException("Transaction failed  after max retries");
+							}))
+					.block();
+			t.setStopFlag();
+			if (tryCount.get() > 1) {
+				break;
+			}
+		}
+		Person pFound = rxCBTmpl.findById(Person.class).one(person.getId().toString()).block();
+		assertEquals(switchedPerson.getFirstname(), pFound.getFirstname(), "should have been switched");
+		assertTrue(tryCount.get() > 1, "should have been more than one try. tries: " + tryCount.get());
+	}
+
+	@Test
+	/**
+	 * This fails with TransactionOperationFailed {ec:FAIL_CAS_MISMATCH, retry:true, autoRollback:true}. I don't know why
+	 * it isn't retried. This seems like it is due to the functioning of AbstractPlatformTransactionManager
+	 */
+	public void replaceWithCasConflictResolvedViaRetryAnnotated() {
+		Person person = new Person(1, "Walter", "White");
+		Person switchedPerson = new Person(1, "Dave", "Reynolds");
+		cbTmpl.insertById(Person.class).one(person);
+		AtomicInteger tryCount = new AtomicInteger(0);
+
+		for (int i = 0; i < 50; i++) { // the transaction sometimes succeeds on the first try
+			ReplaceLoopThread t = new ReplaceLoopThread(switchedPerson);
+			t.start();
+			tryCount.set(0);
+			Person p = personService.declarativeFindReplacePerson(person, tryCount);
+			t.setStopFlag();
+			if (tryCount.get() > 1) {
+				break;
+			}
+		}
+		Person pFound = rxCBTmpl.findById(Person.class).one(person.getId().toString()).block();
+		System.out.println("pFound: " + pFound);
+		assertEquals(switchedPerson.getFirstname(), pFound.getFirstname(), "should have been switched");
+		assertTrue(tryCount.get() > 1, "should have been more than one try. tries: " + tryCount.get());
+	}
+
+	@Test
+	public void replacePersonCBTransactionsRxTmplRollback() {
+		Person person = new Person(1, "Walter", "White");
+		String newName = "Walt";
+		rxCBTmpl.insertById(Person.class).one(person).block();
+
+		// doesn't TransactionWrapper do the same thing?
+		ReactiveTransactionsWrapper reactiveTransactionsWrapper = new ReactiveTransactionsWrapper(
+				reactiveCouchbaseClientFactory);
+		Mono<TransactionResult> result = reactiveTransactionsWrapper.run(ctx -> { //
+			return rxCBTmpl.findById(Person.class).one(person.getId().toString()) //
+					.flatMap(pp -> rxCBTmpl.replaceById(Person.class).one(pp.withFirstName(newName))).then(Mono.empty());
+		});
+
+		result.block();
+		Person pFound = rxCBTmpl.findById(Person.class).one(person.getId().toString()).block();
+		System.err.println(pFound);
+		assertEquals(newName, pFound.getFirstname());
+	}
+
+	@Test
+	public void deletePersonCBTransactionsRxTmpl() {
+		Person person = new Person(1, "Walter", "White");
+		remove(cbTmpl, sName, cName, person.getId().toString());
+		rxCBTmpl.insertById(Person.class).inCollection(cName).one(person).block();
+
+		ReactiveTransactionsWrapper reactiveTransactionsWrapper = new ReactiveTransactionsWrapper(
+				reactiveCouchbaseClientFactory);
+		Mono<TransactionResult> result = reactiveTransactionsWrapper.run(ctx -> { // get the ctx
+			return rxCBTmpl.removeById(Person.class).inCollection(cName).oneEntity(person).then();
+		});
+		result.block();
+		Person pFound = rxCBTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString()).block();
+		assertNull(pFound, "Should not have found " + pFound);
+	}
+
+	@Test
+	public void deletePersonCBTransactionsRxTmplFail() {
+		Person person = new Person(1, "Walter", "White");
+		remove(cbTmpl, sName, cName, person.getId().toString());
+		cbTmpl.insertById(Person.class).inCollection(cName).one(person);
+
+		ReactiveTransactionsWrapper reactiveTransactionsWrapper = new ReactiveTransactionsWrapper(
+				reactiveCouchbaseClientFactory);
+		Mono<TransactionResult> result = reactiveTransactionsWrapper.run(ctx -> { // get the ctx
+			return rxCBTmpl.removeById(Person.class).inCollection(cName).oneEntity(person)
+					.then(rxCBTmpl.removeById(Person.class).inCollection(cName).oneEntity(person)).then();
+		});
+		assertThrowsWithCause(result::block, TransactionFailedException.class, DataRetrievalFailureException.class);
+		Person pFound = cbTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString());
+		assertEquals(pFound, person, "Should have found " + person);
+	}
+
+	@Test
+	public void deletePersonCBTransactionsRxRepo() {
+		Person person = new Person(1, "Walter", "White");
+		remove(cbTmpl, sName, cName, person.getId().toString());
+		rxRepo.withCollection(cName).save(person).block();
+
+		ReactiveTransactionsWrapper reactiveTransactionsWrapper = new ReactiveTransactionsWrapper(
+				reactiveCouchbaseClientFactory);
+		Mono<TransactionResult> result = reactiveTransactionsWrapper.run(ctx -> { // get the ctx
+			return rxRepo.withCollection(cName).delete(person).then();
+		});
+		result.block();
+		Person pFound = cbTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString());
+		assertNull(pFound, "Should not have found " + pFound);
+	}
+
+	@Test
+	public void deletePersonCBTransactionsRxRepoFail() {
+		Person person = new Person(1, "Walter", "White");
+		remove(cbTmpl, sName, cName, person.getId().toString());
+		rxRepo.withCollection(cName).save(person).block();
+
+		ReactiveTransactionsWrapper reactiveTransactionsWrapper = new ReactiveTransactionsWrapper(
+				reactiveCouchbaseClientFactory);
+		Mono<TransactionResult> result = reactiveTransactionsWrapper.run(ctx -> { // get the ctx
+			return rxRepo.withCollection(cName).findById(person.getId().toString())
+					.flatMap(pp -> rxRepo.withCollection(cName).delete(pp).then(rxRepo.withCollection(cName).delete(pp))).then();
+		});
+		assertThrowsWithCause(result::block, TransactionFailedException.class, DataRetrievalFailureException.class);
+		Person pFound = cbTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString());
+		assertEquals(pFound, person, "Should have found " + person + " instead of " + pFound);
+	}
+
+	@Test
+	public void findPersonCBTransactions() {
+		Person person = new Person(1, "Walter", "White");
+		remove(cbTmpl, sName, cName, person.getId().toString());
+		cbTmpl.insertById(Person.class).inScope(sName).inCollection(cName).one(person);
+		List<Object> docs = new LinkedList<>();
+		Query q = Query.query(QueryCriteria.where("meta().id").eq(person.getId()));
+		ReactiveTransactionsWrapper reactiveTransactionsWrapper = new ReactiveTransactionsWrapper(
+				reactiveCouchbaseClientFactory);
+		Mono<TransactionResult> result = reactiveTransactionsWrapper.run(ctx -> rxCBTmpl.findByQuery(Person.class)
+				.inScope(sName).inCollection(cName).matching(q).withConsistency(REQUEST_PLUS).one().doOnSuccess(doc -> {
+					System.err.println("doc: " + doc);
+					docs.add(doc);
+				}));
+		result.block();
+		assertFalse(docs.isEmpty(), "Should have found " + person);
+		for (Object o : docs) {
+			assertEquals(o, person, "Should have found " + person + " instead of " + o);
+		}
+	}
+
+	@Test
+	public void insertPersonRbCBTransactions() {
+		Person person = new Person(1, "Walter", "White");
+		remove(cbTmpl, sName, cName, person.getId().toString());
+
+		ReactiveTransactionsWrapper reactiveTransactionsWrapper = new ReactiveTransactionsWrapper(
+				reactiveCouchbaseClientFactory);
+		Mono<TransactionResult> result = reactiveTransactionsWrapper
+				.run(ctx -> rxCBTmpl.insertById(Person.class).inScope(sName).inCollection(cName).one(person)
+						.<Person> flatMap(it -> Mono.error(new SimulateFailureException())));
+
+		assertThrowsWithCause(() -> result.block(), TransactionFailedException.class, SimulateFailureException.class);
+		Person pFound = cbTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString());
+		assertNull(pFound, "Should not have found " + pFound);
+	}
+
+	@Test
+	public void replacePersonRbCBTransactions() {
+		Person person = new Person(1, "Walter", "White");
+		remove(cbTmpl, sName, cName, person.getId().toString());
+		cbTmpl.insertById(Person.class).inScope(sName).inCollection(cName).one(person);
+		ReactiveTransactionsWrapper reactiveTransactionsWrapper = new ReactiveTransactionsWrapper(
+				reactiveCouchbaseClientFactory);
+		Mono<TransactionResult> result = reactiveTransactionsWrapper.run(ctx -> //
+		rxCBTmpl.findById(Person.class).inScope(sName).inCollection(cName).one(person.getId().toString()) //
+				.flatMap(pFound -> rxCBTmpl.replaceById(Person.class).inScope(sName).inCollection(cName)
+						.one(pFound.withFirstName("Walt")))
+				.<Person> flatMap(it -> Mono.error(new SimulateFailureException())));
+		assertThrowsWithCause(() -> result.block(), TransactionFailedException.class, SimulateFailureException.class);
+
+		Person pFound = cbTmpl.findById(Person.class).inScope(sName).inCollection(cName).one(person.getId().toString());
+		assertEquals(person, pFound, "Should have found " + person + " instead of " + pFound);
+	}
+
+	@Test
+	public void findPersonSpringTransactions() {
+		Person person = new Person(1, "Walter", "White");
+		remove(cbTmpl, sName, cName, person.getId().toString());
+		cbTmpl.insertById(Person.class).inScope(sName).inCollection(cName).one(person);
+		List<Object> docs = new LinkedList<>();
+		Query q = Query.query(QueryCriteria.where("meta().id").eq(person.getId()));
+		ReactiveTransactionsWrapper reactiveTransactionsWrapper = new ReactiveTransactionsWrapper(
+				reactiveCouchbaseClientFactory);
+		Mono<TransactionResult> result = reactiveTransactionsWrapper.run(ctx -> rxCBTmpl.findByQuery(Person.class)
+				.inScope(sName).inCollection(cName).matching(q).one().doOnSuccess(r -> docs.add(r)));
+		result.block();
+		assertFalse(docs.isEmpty(), "Should have found " + person);
+		for (Object o : docs) {
+			assertEquals(o, person, "Should have found " + person);
+		}
+	}
+
+	private class ReplaceLoopThread extends Thread {
+		AtomicBoolean stop = new AtomicBoolean(false);
+		Person person;
+		int maxIterations = 100;
+
+		public ReplaceLoopThread(Person person, int... iterations) {
+			this.person = person;
+			if (iterations != null && iterations.length == 1) {
+				this.maxIterations = iterations[0];
+			}
+		}
+
+		public void run() {
+			for (int i = 0; i < maxIterations && !stop.get(); i++) {
+				sleepMs(10);
+				try {
+					// note that this does not go through spring-data, therefore it does not have the @Field , @Version etc.
+					// annotations processed so we just check getFirstname().equals()
+					// switchedPerson has version=0, so it doesn't check CAS
+					couchbaseClientFactory.getBucket().defaultCollection().replace(person.getId().toString(), person);
+					System.out.println("********** replace thread: " + i + " success");
+				} catch (Exception e) {
+					System.out.println("********** replace thread: " + i + " " + e.getClass().getName());
+				}
+			}
+
+		}
+
+		public void setStopFlag() {
+			stop.set(true);
+		}
+	}
+
+	void remove(Collection col, String id) {
+		remove(col.reactive(), id);
+	}
+
+	void remove(ReactiveCollection col, String id) {
+		try {
+			col.remove(id, RemoveOptions.removeOptions().timeout(Duration.ofSeconds(10))).block();
+		} catch (DocumentNotFoundException nfe) {
+			System.out.println(id + " : " + "DocumentNotFound when deleting");
+		}
+	}
+
+	void remove(CouchbaseTemplate template, String scope, String collection, String id) {
+		remove(template.reactive(), scope, collection, id);
+	}
+
+	void remove(ReactiveCouchbaseTemplate template, String scope, String collection, String id) {
+		try {
+			template.removeById(Person.class).inScope(scope).inCollection(collection).one(id).block();
+			System.out.println("removed " + id);
+			List<Person> ps = template.findByQuery(Person.class).inScope(scope).inCollection(collection)
+					.withConsistency(REQUEST_PLUS).all().collectList().block();
+		} catch (DocumentNotFoundException | DataRetrievalFailureException nfe) {
+			System.out.println(id + " : " + "DocumentNotFound when deleting");
+		}
+	}
+
+	private <T> Mono<T> throwSimulatedFailure(T p) {
+		throw new SimulateFailureException();
+	}
+
+	@Data
+	static class EventLog {
+
+		public EventLog(){};
+
+		public EventLog(ObjectId oid, String action) {
+			this.id = oid.toString();
+			this.action = action;
+		}
+
+		String id;
+		String action;
+
+		public String toString() {
+			StringBuilder sb = new StringBuilder();
+			sb.append("EventLog : {\n");
+			sb.append("  id : " + getId());
+			sb.append(", action: " + action);
+			return sb.toString();
+		}
+	}
+
+	// todo gp disabled while trying to get alternative method of CouchbaseCallbackTransactionManager working
+	// @Configuration(proxyBeanMethods = false)
+	// @Role(BeanDefinition.ROLE_INFRASTRUCTURE)
+	// static class TransactionInterception {
+	//
+	// @Bean
+	// @Role(BeanDefinition.ROLE_INFRASTRUCTURE)
+	// public TransactionInterceptor transactionInterceptor(TransactionAttributeSource transactionAttributeSource,
+	// CouchbaseTransactionManager txManager) {
+	// TransactionInterceptor interceptor = new CouchbaseTransactionInterceptor();
+	// interceptor.setTransactionAttributeSource(transactionAttributeSource);
+	// if (txManager != null) {
+	// interceptor.setTransactionManager(txManager);
+	// }
+	// return interceptor;
+	// }
+	//
+	// @Bean
+	// @Role(BeanDefinition.ROLE_INFRASTRUCTURE)
+	// public TransactionAttributeSource transactionAttributeSource() {
+	// return new AnnotationTransactionAttributeSource();
+	// }
+	//
+	// @Bean(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)
+	// @Role(BeanDefinition.ROLE_INFRASTRUCTURE)
+	// public BeanFactoryTransactionAttributeSourceAdvisor transactionAdvisor(
+	// TransactionAttributeSource transactionAttributeSource, TransactionInterceptor transactionInterceptor) {
+	//
+	// BeanFactoryTransactionAttributeSourceAdvisor advisor = new BeanFactoryTransactionAttributeSourceAdvisor();
+	// advisor.setTransactionAttributeSource(transactionAttributeSource);
+	// advisor.setAdvice(transactionInterceptor);
+	// // if (this.enableTx != null) {
+	// // advisor.setOrder(this.enableTx.<Integer>getNumber("order"));
+	// // }
+	// return advisor;
+	// }
+	//
+	// }
+
+	@Service
+	@Component
+	@EnableTransactionManagement
+	static class PersonService {
+
+		final CouchbaseOperations personOperations;
+		final CouchbaseSimpleCallbackTransactionManager manager; // final ReactiveCouchbaseTransactionManager manager;
+		final ReactiveCouchbaseOperations personOperationsRx;
+		final ReactiveCouchbaseTransactionManager managerRx;
+
+		public PersonService(CouchbaseOperations ops, CouchbaseSimpleCallbackTransactionManager mgr,
+							 ReactiveCouchbaseOperations opsRx, ReactiveCouchbaseTransactionManager mgrRx) {
+			personOperations = ops;
+			manager = mgr;
+			System.err.println("operations cluster  : " + personOperations.getCouchbaseClientFactory().getCluster());
+			// System.err.println("manager cluster : " + manager.getDatabaseFactory().getCluster());
+			System.err.println("manager Manager     : " + manager);
+
+			personOperationsRx = opsRx;
+			managerRx = mgrRx;
+			System.out
+					.println("operationsRx cluster  : " + personOperationsRx.getCouchbaseClientFactory().getCluster().block());
+			System.out.println("managerRx cluster     : " + mgrRx.getDatabaseFactory().getCluster().block());
+			System.out.println("managerRx Manager     : " + managerRx);
+			return;
+		}
+
+		public Person savePersonErrors(Person person) {
+			assertInAnnotationTransaction(false);
+			TransactionalOperator transactionalOperator = TransactionalOperator.create(managerRx,
+					new DefaultTransactionDefinition());
+
+			return personOperationsRx.insertById(Person.class).one(person)//
+					.<Person> flatMap(it -> Mono.error(new SimulateFailureException()))//
+					.as(transactionalOperator::transactional).block();
+		}
+
+		public Person savePerson(Person person) {
+			assertInAnnotationTransaction(false);
+			TransactionalOperator transactionalOperator = TransactionalOperator.create(managerRx,
+					new DefaultTransactionDefinition());
+			return personOperationsRx.insertById(Person.class).one(person)//
+					.as(transactionalOperator::transactional).block();
+		}
+
+		public Long countDuringTx(Person person) {
+			assertInAnnotationTransaction(false);
+			TransactionalOperator transactionalOperator = TransactionalOperator.create(managerRx,
+					new DefaultTransactionDefinition());
+			return personOperationsRx.insertById(Person.class).one(person)//
+					.then(personOperationsRx.findByQuery(Person.class).withConsistency(REQUEST_PLUS).count())
+					.as(transactionalOperator::transactional).block();
+		}
+
+		public List<EventLog> saveWithLogs(Person person) {
+			assertInAnnotationTransaction(false);
+			TransactionalOperator transactionalOperator = TransactionalOperator.create(managerRx,
+					new DefaultTransactionDefinition());
+
+			return Flux
+					.merge(personOperationsRx.insertById(EventLog.class).one(new EventLog(new ObjectId(), "beforeConvert")), //
+							personOperationsRx.insertById(EventLog.class).one(new EventLog(new ObjectId(), "afterConvert")), //
+							personOperationsRx.insertById(EventLog.class).one(new EventLog(new ObjectId(), "beforeInsert")), //
+							personOperationsRx.insertById(Person.class).one(person), //
+							personOperationsRx.insertById(EventLog.class).one(new EventLog(new ObjectId(), "afterInsert"))) //
+					.thenMany(personOperationsRx.findByQuery(EventLog.class).all()) //
+					.as(transactionalOperator::transactional).collectList().block();
+
+		}
+
+		public List<EventLog> saveWithErrorLogs(Person person) {
+			assertInAnnotationTransaction(false);
+			TransactionalOperator transactionalOperator = TransactionalOperator.create(managerRx,
+					new DefaultTransactionDefinition());
+
+			return Flux
+					.merge(personOperationsRx.insertById(EventLog.class).one(new EventLog(new ObjectId(), "beforeConvert")), //
+							personOperationsRx.insertById(EventLog.class).one(new EventLog(new ObjectId(), "afterConvert")), //
+							personOperationsRx.insertById(EventLog.class).one(new EventLog(new ObjectId(), "beforeInsert")), //
+							personOperationsRx.insertById(Person.class).one(person), //
+							personOperationsRx.insertById(EventLog.class).one(new EventLog(new ObjectId(), "afterInsert"))) //
+					.thenMany(personOperationsRx.findByQuery(EventLog.class).all()) //
+					.<EventLog> flatMap(it -> Mono.error(new SimulateFailureException())).as(transactionalOperator::transactional)
+					.collectList().block();
+
+		}
+
+		// org.springframework.beans.factory.NoUniqueBeanDefinitionException:
+		// No qualifying bean of type 'org.springframework.transaction.TransactionManager' available: expected single
+		// matching bean but found 2: reactiveCouchbaseTransactionManager,couchbaseTransactionManager
+		@Transactional(transactionManager = BeanNames.COUCHBASE_SIMPLE_CALLBACK_TRANSACTION_MANAGER)
+		public Person declarativeSavePerson(Person person) {
+			assertInAnnotationTransaction(true);
+			return personOperations.insertById(Person.class).one(person);
+		}
+
+		@Transactional(transactionManager = BeanNames.COUCHBASE_SIMPLE_CALLBACK_TRANSACTION_MANAGER)
+		public Person declarativeSavePersonErrors(Person person) {
+			assertInAnnotationTransaction(true);
+			Person p = personOperations.insertById(Person.class).one(person); //
+			SimulateFailureException.throwEx();
+			return p;
+		}
+
+		/**
+		 * to execute while ThreadReplaceloop() is running should force a retry
+		 *
+		 * @param person
+		 * @return
+		 */
+		@Transactional(transactionManager = BeanNames.COUCHBASE_SIMPLE_CALLBACK_TRANSACTION_MANAGER)
+		public Person declarativeFindReplacePersonCallback(Person person, AtomicInteger tryCount) {
+			assertInAnnotationTransaction(true);
+			System.err.println("declarativeFindReplacePersonCallback try: " + tryCount.incrementAndGet());
+			Person p = personOperations.findById(Person.class).one(person.getId().toString());
+			return personOperations.replaceById(Person.class).one(p.withFirstName(person.getFirstname()));
+		}
+
+		/**
+		 * The ReactiveCouchbaseTransactionManager does not retry on write-write conflict. Instead it will throw
+		 * RetryTransactionException to execute while ThreadReplaceloop() is running should force a retry
+		 *
+		 * @param person
+		 * @return
+		 */
+		@Transactional(transactionManager = BeanNames.REACTIVE_COUCHBASE_TRANSACTION_MANAGER)
+		public Mono<Person> declarativeFindReplacePersonReactive(Person person, AtomicInteger tryCount) {
+			assertInAnnotationTransaction(true);
+			System.err.println("declarativeFindReplacePersonReactive try: " + tryCount.incrementAndGet());
+			return personOperationsRx.findById(Person.class).one(person.getId().toString())
+					.flatMap(p -> personOperationsRx.replaceById(Person.class).one(p.withFirstName(person.getFirstname())));
+		}
+
+		/**
+		 * to execute while ThreadReplaceloop() is running should force a retry
+		 *
+		 * @param person
+		 * @return
+		 */
+		@Transactional(transactionManager = BeanNames.COUCHBASE_SIMPLE_CALLBACK_TRANSACTION_MANAGER)
+		public Person declarativeFindReplacePerson(Person person, AtomicInteger tryCount) {
+			assertInAnnotationTransaction(true);
+			System.err.println("declarativeFindReplacePerson try: " + tryCount.incrementAndGet());
+			Person p = personOperations.findById(Person.class).one(person.getId().toString());
+			return personOperations.replaceById(Person.class).one(p);
+		}
+
+		@Transactional(transactionManager = BeanNames.REACTIVE_COUCHBASE_TRANSACTION_MANAGER) // doesn't retry
+		public Mono<Person> declarativeSavePersonReactive(Person person) {
+			assertInAnnotationTransaction(true);
+			return personOperationsRx.insertById(Person.class).one(person);
+		}
+
+		@Transactional(transactionManager = BeanNames.REACTIVE_COUCHBASE_TRANSACTION_MANAGER)
+		public Mono<Person> declarativeSavePersonErrorsReactive(Person person) {
+			assertInAnnotationTransaction(true);
+			Mono<Person> p = personOperationsRx.insertById(Person.class).one(person); //
+			SimulateFailureException.throwEx();
+			return p;
+		}
+
+	}
+
+}
diff --git a/src/test/java/org/springframework/data/couchbase/transactions/CouchbasePersonTransactionReactiveIntegrationTests.java b/src/test/java/org/springframework/data/couchbase/transactions/CouchbasePersonTransactionReactiveIntegrationTests.java
new file mode 100644
index 00000000..b92bd331
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/transactions/CouchbasePersonTransactionReactiveIntegrationTests.java
@@ -0,0 +1,612 @@
+/*
+ * Copyright 2012-2021 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.data.couchbase.transactions;
+
+import com.couchbase.client.java.Cluster;
+import lombok.Data;
+import org.springframework.context.annotation.AnnotationConfigApplicationContext;
+import org.springframework.context.annotation.Bean;
+import org.springframework.data.annotation.Version;
+import org.springframework.data.couchbase.config.BeanNames;
+import org.springframework.data.couchbase.core.CouchbaseOperations;
+import org.springframework.data.couchbase.transaction.CouchbaseSimpleCallbackTransactionManager;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionManager;
+import org.springframework.data.domain.Persistable;
+import org.springframework.test.context.transaction.AfterTransaction;
+import org.springframework.test.context.transaction.BeforeTransaction;
+import reactor.core.publisher.Flux;
+import reactor.core.publisher.Mono;
+import reactor.test.StepVerifier;
+
+import java.time.Duration;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.UUID;
+
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.context.support.GenericApplicationContext;
+import org.springframework.dao.DataRetrievalFailureException;
+import org.springframework.data.couchbase.CouchbaseClientFactory;
+import org.springframework.data.couchbase.config.AbstractCouchbaseConfiguration;
+import org.springframework.data.couchbase.core.CouchbaseTemplate;
+import org.springframework.data.couchbase.core.ReactiveCouchbaseOperations;
+import org.springframework.data.couchbase.core.ReactiveCouchbaseTemplate;
+import org.springframework.data.couchbase.core.query.Query;
+import org.springframework.data.couchbase.domain.Person;
+import org.springframework.data.couchbase.domain.PersonRepository;
+import org.springframework.data.couchbase.domain.ReactivePersonRepository;
+import org.springframework.data.couchbase.repository.config.EnableCouchbaseRepositories;
+import org.springframework.data.couchbase.repository.config.EnableReactiveCouchbaseRepositories;
+import org.springframework.data.couchbase.transaction.ReactiveCouchbaseTransactionManager;
+import org.springframework.data.couchbase.util.Capabilities;
+import org.springframework.data.couchbase.util.ClusterType;
+import org.springframework.data.couchbase.util.IgnoreWhen;
+import org.springframework.data.couchbase.util.JavaIntegrationTests;
+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
+import org.springframework.transaction.annotation.Transactional;
+import org.springframework.transaction.reactive.TransactionalOperator;
+import org.springframework.transaction.support.DefaultTransactionDefinition;
+
+import com.couchbase.client.core.cnc.Event;
+import com.couchbase.client.core.error.DocumentNotFoundException;
+import com.couchbase.client.java.Collection;
+import com.couchbase.client.java.ReactiveCollection;
+import com.couchbase.client.java.kv.RemoveOptions;
+
+import static com.couchbase.client.java.query.QueryScanConsistency.REQUEST_PLUS;
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * Tests for com.couchbase.transactions without using the spring data transactions framework
+ *
+ * @author Michael Reiche
+ */
+@IgnoreWhen(missesCapabilities = Capabilities.QUERY, clusterTypes = ClusterType.MOCKED)
+@SpringJUnitConfig(CouchbasePersonTransactionReactiveIntegrationTests.Config.class)
+//@Transactional(transactionManager = BeanNames.COUCHBASE_TRANSACTION_MANAGER)
+public class CouchbasePersonTransactionReactiveIntegrationTests extends JavaIntegrationTests {
+
+	@Autowired CouchbaseClientFactory couchbaseClientFactory;
+	@Autowired ReactiveCouchbaseTransactionManager reactiveCouchbaseTransactionManager;
+	@Autowired CouchbaseSimpleCallbackTransactionManager couchbaseTransactionManager;
+	@Autowired ReactivePersonRepository rxRepo;
+	@Autowired PersonRepository repo;
+	@Autowired ReactiveCouchbaseTemplate rxCBTmpl;
+
+	@Autowired Cluster myCluster;
+
+	/* DO NOT @Autowired */ PersonService personService;
+
+	static GenericApplicationContext context;
+	@Autowired ReactiveCouchbaseTemplate operations;
+
+	@BeforeAll
+	public static void beforeAll() {
+		callSuperBeforeAll(new Object() {});
+		context = new AnnotationConfigApplicationContext(CouchbasePersonTransactionReactiveIntegrationTests.Config.class,
+				CouchbasePersonTransactionReactiveIntegrationTests.PersonService.class);
+	}
+
+	@AfterAll
+	public static void afterAll() {
+		callSuperAfterAll(new Object() {});
+	}
+
+	@BeforeEach
+	public void beforeEachTest() {
+		personService = context.getBean(CouchbasePersonTransactionReactiveIntegrationTests.PersonService.class); // getting it via autowired results in no @Transactional
+		operations.removeByQuery(Person.class).withConsistency(REQUEST_PLUS).all().collectList().block();
+		operations.removeByQuery(EventLog.class).withConsistency(REQUEST_PLUS).all().collectList().block();
+		operations.findByQuery(Person.class).withConsistency(REQUEST_PLUS).all().collectList().block();
+		operations.findByQuery(EventLog.class).withConsistency(REQUEST_PLUS).all().collectList().block();
+	}
+
+
+	@Test // DATAMONGO-2265
+	public void shouldRollbackAfterException() {
+		personService.savePersonErrors(new Person(null, "Walter", "White")) //
+				.as(StepVerifier::create) //
+				.verifyError(RuntimeException.class);
+		// operations.findByQuery(Person.class).withConsistency(QueryScanConsistency.REQUEST_PLUS).count().block();
+		// sleepMs(5000);
+		operations.count(new Query(), Person.class) //
+				.as(StepVerifier::create) //
+				.expectNext(0L) //
+				.verifyComplete();
+	}
+
+	@Test // DATAMONGO-2265
+	// @Rollback(false)
+	public void shouldRollbackAfterExceptionOfTxAnnotatedMethod() {
+		Person p = new Person(null, "Walter", "White");
+		try {
+			personService.declarativeSavePersonErrors(p) //
+					.as(StepVerifier::create) //
+					.expectComplete();
+			// .verifyError(RuntimeException.class);
+		} catch (RuntimeException e) {
+			if (e instanceof SimulateFailureException || (e.getMessage() != null && e.getMessage().contains("poof"))) {
+				System.err.println(e);
+			} else {
+				throw e;
+			}
+		}
+
+	}
+
+	@Test // DATAMONGO-2265
+	public void commitShouldPersistTxEntries() {
+
+		personService.savePerson(new Person(null, "Walter", "White")) //
+				.as(StepVerifier::create) //
+				.expectNextCount(1) //
+				.verifyComplete();
+
+		operations.findByQuery(Person.class).withConsistency(REQUEST_PLUS).count().block();
+
+		operations.findByQuery(Person.class).withConsistency(REQUEST_PLUS).count() //
+				.as(StepVerifier::create) //
+				.expectNext(1L) //
+				.verifyComplete();
+	}
+
+	@Test // DATAMONGO-2265
+	public void commitShouldPersistTxEntriesOfTxAnnotatedMethod() {
+
+		personService.declarativeSavePerson(new Person(null, "Walter", "White")).as(StepVerifier::create) //
+				.expectNextCount(1) //
+				.verifyComplete();
+
+		operations.findByQuery(Person.class).withConsistency(REQUEST_PLUS).count() //
+				.as(StepVerifier::create) //
+				.expectNext(1L) //
+				.verifyComplete();
+
+	}
+
+	@Test // DATAMONGO-2265
+	public void commitShouldPersistTxEntriesAcrossCollections() {
+
+		personService.saveWithLogs(new Person(null, "Walter", "White")) //
+				.then() //
+				.as(StepVerifier::create) //
+				.verifyComplete();
+
+		operations.findByQuery(Person.class).withConsistency(REQUEST_PLUS).count() //
+				.as(StepVerifier::create) //
+				.expectNext(1L) //
+				.verifyComplete();
+
+		operations.findByQuery(EventLog.class).withConsistency(REQUEST_PLUS).count() //
+				.as(StepVerifier::create) //
+				.expectNext(4L) //
+				.verifyComplete();
+	}
+
+	@Test // DATAMONGO-2265
+	public void rollbackShouldAbortAcrossCollections() {
+
+		personService.saveWithErrorLogs(new Person(null, "Walter", "White")) //
+				.then() //
+				.as(StepVerifier::create) //
+				.verifyError();
+
+		operations.count(new Query(), Person.class) //
+				.as(StepVerifier::create) //
+				.expectNext(0L) //
+				.verifyComplete();
+
+		operations.count(new Query(), EventLog.class)//
+				.as(StepVerifier::create) //
+				.expectNext(0L) //
+				.verifyComplete();
+	}
+
+	@Test // DATAMONGO-2265
+	public void countShouldWorkInsideTransaction() {
+
+		personService.countDuringTx(new Person(null, "Walter", "White")) //
+				.as(StepVerifier::create) //
+				.expectNext(1L) //
+				.verifyComplete();
+	}
+
+	@Test // DATAMONGO-2265
+	public void emitMultipleElementsDuringTransaction() {
+
+		try {
+			personService.saveWithLogs(new Person(null, "Walter", "White")) //
+					.as(StepVerifier::create) //
+					.expectNextCount(4L) //
+					.verifyComplete();
+		} catch (Exception e) {
+			System.err.println("Done");
+			throw e;
+		}
+	}
+
+	@Test // DATAMONGO-2265
+	public void errorAfterTxShouldNotAffectPreviousStep() {
+
+		Person p = new Person(1, "Walter", "White");
+		//remove(couchbaseTemplate, "_default", p.getId().toString());
+		personService.savePerson(p) //
+				//.delayElement(Duration.ofMillis(100)) //
+				.then(Mono.error(new RuntimeException("my big bad evil error"))).as(StepVerifier::create) //
+				.expectError()
+				.verify();
+				//.expectError() //
+				//.as(StepVerifier::create)
+				//.expectNext(p)
+				//.verifyComplete();
+
+		operations.findByQuery(Person.class).withConsistency(REQUEST_PLUS).count() //
+				.as(StepVerifier::create) //
+				.expectNext(1L) //
+				.verifyComplete();
+	}
+
+	// @RequiredArgsConstructor
+	static class PersonService {
+
+		final ReactiveCouchbaseOperations personOperationsRx;
+		final ReactiveCouchbaseTransactionManager managerRx;
+		final CouchbaseOperations personOperations;
+		//final CouchbaseCallbackTransactionManager manager;
+
+		public PersonService(CouchbaseOperations ops, /* CouchbaseCallbackTransactionManager mgr, */ ReactiveCouchbaseOperations opsRx,
+				ReactiveCouchbaseTransactionManager mgrRx) {
+			personOperations = ops;
+			//manager = mgr;
+			System.err.println("operations cluster  : " + personOperations.getCouchbaseClientFactory().getCluster());
+//			System.err.println("manager cluster     : " + manager.getDatabaseFactory().getCluster());
+			//System.err.println("manager Manager     : " + manager);
+
+			personOperationsRx = opsRx;
+			managerRx = mgrRx;
+			System.out
+					.println("operationsRx cluster  : " + personOperationsRx.getCouchbaseClientFactory().getCluster().block());
+			System.out.println("managerRx cluster     : " + mgrRx.getDatabaseFactory().getCluster().block());
+			System.out.println("managerRx Manager     : " + managerRx);
+			return;
+		}
+
+		public Mono<Person> savePersonErrors(Person person) {
+
+			TransactionalOperator transactionalOperator = TransactionalOperator.create(managerRx);
+			return personOperationsRx.insertById(Person.class).one(person) //
+					.<Person> flatMap(it -> Mono.error(new RuntimeException("poof!"))) //
+					.as(transactionalOperator::transactional);
+		}
+
+		public Mono<Person> savePerson(Person person) {
+
+			TransactionalOperator transactionalOperator = TransactionalOperator.create(managerRx,
+					new DefaultTransactionDefinition());
+
+			return personOperationsRx.insertById(Person.class).one(person) //
+					.flatMap(Mono::just) //
+					.as(transactionalOperator::transactional);
+		}
+
+		public Mono<Long> countDuringTx(Person person) {
+
+			TransactionalOperator transactionalOperator = TransactionalOperator.create(managerRx,
+					new DefaultTransactionDefinition());
+
+			return personOperationsRx.save(person) //
+					.then(personOperationsRx.count(new Query(), Person.class)) //
+					.as(transactionalOperator::transactional);
+		}
+
+		public Flux<EventLog> saveWithLogs(Person person) {
+
+			TransactionalOperator transactionalOperator = TransactionalOperator.create(managerRx,
+					new DefaultTransactionDefinition());
+
+			return Flux.merge(personOperationsRx.save(new EventLog(new ObjectId().toString(), "beforeConvert")), //
+					personOperationsRx.save(new EventLog(new ObjectId(), "afterConvert")), //
+					personOperationsRx.save(new EventLog(new ObjectId(), "beforeInsert")), //
+					personOperationsRx.save(person), //
+					personOperationsRx.save(new EventLog(new ObjectId(), "afterInsert"))) //
+					.thenMany(personOperationsRx.findByQuery(EventLog.class).all()) //
+					.as(transactionalOperator::transactional);
+		}
+
+		public Flux<Void> saveWithErrorLogs(Person person) {
+
+			TransactionalOperator transactionalOperator = TransactionalOperator.create(managerRx,
+					new DefaultTransactionDefinition());
+
+			return Flux.merge(personOperationsRx.save(new EventLog(new ObjectId(), "beforeConvert")), //
+					personOperationsRx.save(new EventLog(new ObjectId(), "afterConvert")), //
+					personOperationsRx.save(new EventLog(new ObjectId(), "beforeInsert")), //
+					personOperationsRx.save(person), //
+					personOperationsRx.save(new EventLog(new ObjectId(), "afterInsert"))) //
+					.<Void> flatMap(it -> Mono.error(new RuntimeException("poof!"))) //
+					.as(transactionalOperator::transactional);
+		}
+
+		@Transactional
+		public Flux<Person> declarativeSavePerson(Person person) {
+
+			TransactionalOperator transactionalOperator = TransactionalOperator.create(managerRx,
+					new DefaultTransactionDefinition());
+
+			return transactionalOperator.execute(reactiveTransaction -> personOperationsRx.save(person));
+		}
+
+		@Transactional(transactionManager = BeanNames.COUCHBASE_TRANSACTION_MANAGER)
+		public Flux<Person> declarativeSavePersonErrors(Person person) {
+			Person p = personOperations.insertById(Person.class).one(person);
+			// if(1==1)throw new RuntimeException("poof!");
+			Person pp = personOperations.findByQuery(Person.class).withConsistency(REQUEST_PLUS).all().get(0);
+			System.err.println("pp=" + pp);
+			SimulateFailureException.throwEx();
+			return Flux.just(p);
+		}
+	}
+
+	/*
+	  @Test
+	  public void deletePersonCBTransactionsRxTmpl() {
+	    Person person = new Person(1, "Walter", "White");
+	    remove(cbTmpl, cName, person.getId().toString());
+	    rxCBTmpl.insertById(Person.class).inCollection(cName).one(person).block();
+
+	    Mono<TransactionResult> result = transactions.reactive(((ctx) -> { // get the ctx
+	      return rxCBTmpl.removeById(Person.class).inCollection(cName).transaction(ctx).one(person.getId().toString())
+	          .then();
+	    }));
+	    result.block();
+	    Person pFound = rxCBTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString()).block();
+	    assertNull(pFound, "Should not have found " + pFound);
+	  }
+
+	  @Test
+	  public void deletePersonCBTransactionsRxTmplFail() {
+	    Person person = new Person(1, "Walter", "White");
+	    remove(cbTmpl, cName, person.getId().toString());
+	    cbTmpl.insertById(Person.class).inCollection(cName).one(person);
+
+	    Mono<TransactionResult> result = transactions.reactive(((ctx) -> { // get the ctx
+	      return rxCBTmpl.removeById(Person.class).inCollection(cName).transaction(ctx).one(person.getId().toString())
+	          .then(rxCBTmpl.removeById(Person.class).inCollection(cName).transaction(ctx).one(person.getId().toString()))
+	          .then();
+	    }));
+	    assertThrows(TransactionFailedException.class, result::block);
+	    Person pFound = cbTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString());
+	    assertEquals(pFound, person, "Should have found " + person);
+	  }
+
+	  //  RxRepo ////////////////////////////////////////////////////////////////////////////////////////////
+
+	  @Test
+	  public void deletePersonCBTransactionsRxRepo() {
+	    Person person = new Person(1, "Walter", "White");
+	    remove(cbTmpl, cName, person.getId().toString());
+	    rxRepo.withCollection(cName).save(person).block();
+
+	    Mono<TransactionResult> result = transactions.reactive(((ctx) -> { // get the ctx
+	      return rxRepo.withCollection(cName).withTransaction(ctx).deleteById(person.getId().toString()).then();
+	    }));
+	    result.block();
+	    Person pFound = cbTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString());
+	    assertNull(pFound, "Should not have found " + pFound);
+	  }
+
+	  @Test
+	  public void deletePersonCBTransactionsRxRepoFail() {
+	    Person person = new Person(1, "Walter", "White");
+	    remove(cbTmpl, cName, person.getId().toString());
+	    rxRepo.withCollection(cName).save(person).block();
+
+	    Mono<TransactionResult> result = transactions.reactive(((ctx) -> { // get the ctx
+	      return rxRepo.withCollection(cName).withTransaction(ctx).deleteById(person.getId().toString())
+	          .then(rxRepo.withCollection(cName).withTransaction(ctx).deleteById(person.getId().toString())).then();
+	    }));
+	    assertThrows(TransactionFailedException.class, result::block);
+	    Person pFound = cbTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString());
+	    assertEquals(pFound, person, "Should have found " + person);
+	  }
+
+	  @Test
+	  public void findPersonCBTransactions() {
+	    Person person = new Person(1, "Walter", "White");
+	    remove(cbTmpl, cName, person.getId().toString());
+	    cbTmpl.insertById(Person.class).inCollection(cName).one(person);
+	    List<Object> docs = new LinkedList<>();
+	    Query q = Query.query(QueryCriteria.where("meta().id").eq(person.getId()));
+	    Mono<TransactionResult> result = transactions.reactive(((ctx) -> { // get the ctx
+	      return rxCBTmpl.findByQuery(Person.class).inCollection(cName).matching(q).transaction(ctx).one().map(doc -> {
+	        docs.add(doc);
+	        return doc;
+	      }).then();
+	    }));
+	    result.block();
+	    assertFalse(docs.isEmpty(), "Should have found " + person);
+	    for (Object o : docs) {
+	      assertEquals(o, person, "Should have found " + person);
+	    }
+	  }
+
+	  @Test
+	  // @Transactional // TODO @Transactional does nothing. Transaction is handled by transactionalOperator
+	  // Failed to retrieve PlatformTransactionManager for @Transactional test:
+	  public void insertPersonRbCBTransactions() {
+	    Person person = new Person(1, "Walter", "White");
+	    remove(cbTmpl, cName, person.getId().toString());
+
+	    Mono<TransactionResult> result = transactions.reactive((ctx) -> { // get the ctx
+	      return rxCBTmpl.insertById(Person.class).inCollection(cName).transaction(ctx).one(person)
+	          .<Person> flatMap(it -> Mono.error(new PoofException())).then();
+	    });
+
+	    try {
+	      result.block();
+	    } catch (TransactionFailedException e) {
+	      e.printStackTrace();
+	      if (e.getCause() instanceof PoofException) {
+	        Person pFound = cbTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString());
+	        assertNull(pFound, "Should not have found " + pFound);
+	        return;
+	      } else {
+	        e.printStackTrace();
+	      }
+	    }
+	    throw new RuntimeException("Should have been a TransactionFailedException exception with a cause of PoofException");
+	  }
+
+	  @Test
+	  // @Transactional // TODO @Transactional does nothing. Transaction is handled by transactionalOperator
+	  // Failed to retrieve PlatformTransactionManager for @Transactional test:
+	  public void replacePersonRbCBTransactions() {
+	    Person person = new Person(1, "Walter", "White");
+	    remove(cbTmpl, cName, person.getId().toString());
+	    cbTmpl.insertById(Person.class).inCollection(cName).one(person);
+	    Mono<TransactionResult> result = transactions.reactive((ctx) -> { // get the ctx
+	      return rxCBTmpl.findById(Person.class).inCollection(cName).transaction(ctx).one(person.getId().toString())
+	          .flatMap(pFound -> rxCBTmpl.replaceById(Person.class).inCollection(cName).transaction(ctx)
+	              .one(pFound.withFirstName("Walt")))
+	          .<Person> flatMap(it -> Mono.error(new PoofException())).then();
+	    });
+
+	    try {
+	      result.block();
+	    } catch (TransactionFailedException e) {
+	      if (e.getCause() instanceof PoofException) {
+	        Person pFound = cbTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString());
+	        assertEquals(person, pFound, "Should have found " + person);
+	        return;
+	      } else {
+	        e.printStackTrace();
+	      }
+	    }
+	    throw new RuntimeException("Should have been a TransactionFailedException exception with a cause of PoofException");
+	  }
+
+	  @Test
+	  public void findPersonSpringTransactions() {
+	    Person person = new Person(1, "Walter", "White");
+	    remove(cbTmpl, cName, person.getId().toString());
+	    cbTmpl.insertById(Person.class).inCollection(cName).one(person);
+	    List<Object> docs = new LinkedList<>();
+	    Query q = Query.query(QueryCriteria.where("meta().id").eq(person.getId()));
+	    Mono<TransactionResult> result = transactions.reactive((ctx) -> { // get the ctx
+	      return rxCBTmpl.findByQuery(Person.class).inCollection(cName).matching(q).transaction(ctx).one().map(doc -> {
+	        docs.add(doc);
+	        return doc;
+	      }).then();
+	    });
+	    result.block();
+	    assertFalse(docs.isEmpty(), "Should have found " + person);
+	    for (Object o : docs) {
+	      assertEquals(o, person, "Should have found " + person);
+	    }
+	  }
+	*/
+	void remove(Collection col, String id) {
+		remove(col.reactive(), id);
+	}
+
+	void remove(ReactiveCollection col, String id) {
+		try {
+			col.remove(id, RemoveOptions.removeOptions().timeout(Duration.ofSeconds(10))).block();
+		} catch (DocumentNotFoundException nfe) {
+			System.out.println(id + " : " + "DocumentNotFound when deleting");
+		}
+	}
+
+	void remove(CouchbaseTemplate template, String collection, String id) {
+		remove(template.reactive(), collection, id);
+	}
+
+	void remove(ReactiveCouchbaseTemplate template, String collection, String id) {
+		try {
+			template.removeById(Person.class).inCollection(collection).one(id).block();
+			System.out.println("removed " + id);
+		} catch (DocumentNotFoundException | DataRetrievalFailureException nfe) {
+			System.out.println(id + " : " + "DocumentNotFound when deleting");
+		}
+	}
+
+	@Configuration
+	@EnableCouchbaseRepositories("org.springframework.data.couchbase")
+	@EnableReactiveCouchbaseRepositories("org.springframework.data.couchbase")
+	static class Config extends AbstractCouchbaseConfiguration {
+
+		@Override
+		public String getConnectionString() {
+			return connectionString();
+		}
+
+		@Override
+		public String getUserName() {
+			return config().adminUsername();
+		}
+
+		@Override
+		public String getPassword() {
+			return config().adminPassword();
+		}
+
+		@Override
+		public String getBucketName() {
+			return bucketName();
+		}
+
+		@Bean
+		public Cluster couchbaseCluster() {
+			return Cluster.connect("10.144.220.101", "Administrator", "password");
+		}
+
+		/*
+		@Bean("personService")
+		PersonService getPersonService(CouchbaseOperations ops, CouchbaseTransactionManager mgr,
+				ReactiveCouchbaseOperations opsRx, ReactiveCouchbaseTransactionManager mgrRx) {
+			return new PersonService(ops, mgr, opsRx, mgrRx);
+		}
+		 */
+
+    }
+
+    @Data
+    // @AllArgsConstructor
+    static class EventLog {
+        public EventLog() {}
+
+        public EventLog(ObjectId oid, String action) {
+            this.id = oid.toString();
+            this.action = action;
+        }
+
+        public EventLog(String id, String action) {
+            this.id = id;
+            this.action = action;
+        }
+
+        String id;
+        String action;
+        @Version
+        Long version;
+    }
+}
diff --git a/src/test/java/org/springframework/data/couchbase/transactions/CouchbaseReactiveTransactionNativeTests.java b/src/test/java/org/springframework/data/couchbase/transactions/CouchbaseReactiveTransactionNativeTests.java
new file mode 100644
index 00000000..1dd8e795
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/transactions/CouchbaseReactiveTransactionNativeTests.java
@@ -0,0 +1,428 @@
+/*
+ * Copyright 2012-2021 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.data.couchbase.transactions;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNull;
+
+import com.couchbase.client.java.transactions.TransactionResult;
+import com.couchbase.client.java.transactions.error.TransactionFailedException;
+import reactor.core.publisher.Mono;
+
+import java.time.Duration;
+
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.context.support.GenericApplicationContext;
+import org.springframework.dao.DataRetrievalFailureException;
+import org.springframework.data.couchbase.CouchbaseClientFactory;
+import org.springframework.data.couchbase.config.AbstractCouchbaseConfiguration;
+import org.springframework.data.couchbase.core.CouchbaseTemplate;
+import org.springframework.data.couchbase.core.ReactiveCouchbaseTemplate;
+import org.springframework.data.couchbase.domain.Person;
+import org.springframework.data.couchbase.domain.PersonRepository;
+import org.springframework.data.couchbase.domain.ReactivePersonRepository;
+import org.springframework.data.couchbase.repository.config.EnableCouchbaseRepositories;
+import org.springframework.data.couchbase.repository.config.EnableReactiveCouchbaseRepositories;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
+import org.springframework.data.couchbase.transaction.ReactiveCouchbaseTransactionManager;
+import org.springframework.data.couchbase.util.Capabilities;
+import org.springframework.data.couchbase.util.ClusterType;
+import org.springframework.data.couchbase.util.IgnoreWhen;
+import org.springframework.data.couchbase.util.JavaIntegrationTests;
+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
+import org.springframework.transaction.reactive.TransactionalOperator;
+
+import com.couchbase.client.core.error.DocumentNotFoundException;
+import com.couchbase.client.java.Collection;
+import com.couchbase.client.java.ReactiveCollection;
+import com.couchbase.client.java.kv.RemoveOptions;
+
+/**
+ * Tests for com.couchbase.transactions without using the spring data transactions framework
+ *
+ * @author Michael Reiche
+ */
+@IgnoreWhen(missesCapabilities = Capabilities.QUERY, clusterTypes = ClusterType.MOCKED)
+@SpringJUnitConfig(CouchbaseReactiveTransactionNativeTests.Config.class)
+//@Disabled // Now using TransactionSyncronizationManager for the session
+public class CouchbaseReactiveTransactionNativeTests extends JavaIntegrationTests {
+
+	@Autowired CouchbaseClientFactory couchbaseClientFactory;
+	@Autowired ReactiveCouchbaseTransactionManager reactiveCouchbaseTransactionManager;
+	@Autowired ReactivePersonRepository rxRepo;
+	@Autowired PersonRepository repo;
+	@Autowired ReactiveCouchbaseTemplate rxCBTmpl;
+
+	static String cName; // short name
+
+	static GenericApplicationContext context;
+	ReactiveCouchbaseTemplate operations;
+
+	@BeforeAll
+	public static void beforeAll() {
+		callSuperBeforeAll(new Object() {});
+		cName = null;// cName;
+	}
+
+	@AfterAll
+	public static void afterAll() {
+		callSuperAfterAll(new Object() {});
+		if(context != null){
+			context.close();
+		}
+	}
+
+	@BeforeEach
+	public void beforeEachTest() {
+		operations = rxCBTmpl;
+
+	}
+
+	@Test
+	public void replacePersonTemplate() {
+		Person person = new Person(1, "Walter", "White");
+		remove(rxCBTmpl, cName, person.getId().toString());
+		rxCBTmpl.insertById(Person.class).inCollection(cName).one(person).block();
+
+		CouchbaseTransactionalOperator txOperator = new CouchbaseTransactionalOperator(reactiveCouchbaseTransactionManager);
+		Mono<TransactionResult> result = txOperator
+				.reactive((ctx) -> ctx.template(rxCBTmpl).findById(Person.class).one(person.getId().toString())
+						.flatMap(p -> ctx.template(rxCBTmpl).replaceById(Person.class).one(p.withFirstName("Walt")))
+						// .flatMap(it -> Mono.error(new PoofException()))
+						.then());
+
+		try {
+			result.block();
+		} catch (TransactionFailedException e) {
+			if (e.getCause() instanceof SimulateFailureException) {
+				Person pFound = rxCBTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString()).block();
+				assertEquals(person, pFound, "Should have found " + person);
+				return;
+			}
+			e.printStackTrace();
+		}
+		Person pFound = rxCBTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString()).block();
+		assertEquals("Walt", pFound.getFirstname(), "firstname should be Walt");
+		// throw new RuntimeException("Should have been a TransactionFailedException exception with a cause of PoofException");
+	}
+
+	@Test
+	public void replacePersonRbTemplate() {
+		Person person = new Person(1, "Walter", "White");
+		remove(rxCBTmpl, cName, person.getId().toString());
+		rxCBTmpl.insertById(Person.class).inCollection(cName).one(person).block();
+		sleepMs(1000);
+		CouchbaseTransactionalOperator txOperator = new CouchbaseTransactionalOperator(reactiveCouchbaseTransactionManager);
+		Mono<TransactionResult> result = txOperator
+				.reactive((ctx) -> ctx.template(rxCBTmpl).findById(Person.class).one(person.getId().toString())
+						.flatMap(p -> ctx.template(rxCBTmpl).replaceById(Person.class).one(p.withFirstName("Walt")))
+						.flatMap(it -> Mono.error(new SimulateFailureException())).then());
+
+		try {
+			result.block();
+		} catch (TransactionFailedException e) {
+			if (e.getCause() instanceof SimulateFailureException) {
+				Person pFound = rxCBTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString()).block();
+				assertEquals(person, pFound, "Should have found " + person);
+				return;
+			}
+			e.printStackTrace();
+		}
+		// Person pFound = rxCBTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString()).block();
+		// assertEquals("Walt", pFound.getFirstname(), "firstname should be Walt");
+		throw new RuntimeException("Should have been a TransactionFailedException exception with a cause of PoofException");
+	}
+
+	@Test
+	public void insertPersonTemplate() {
+		Person person = new Person(1, "Walter", "White");
+		remove(rxCBTmpl, cName, person.getId().toString());
+
+		CouchbaseTransactionalOperator txOperator = new CouchbaseTransactionalOperator(reactiveCouchbaseTransactionManager);
+		Mono<TransactionResult> result = txOperator.reactive((ctx) -> ctx.template(rxCBTmpl).insertById(Person.class)
+				.one(person).flatMap(p -> ctx.template(rxCBTmpl).replaceById(Person.class).one(p.withFirstName("Walt")))
+				// .flatMap(it -> Mono.error(new PoofException()))
+				.then());
+
+		try {
+			result.block();
+		} catch (TransactionFailedException e) {
+			if (e.getCause() instanceof SimulateFailureException) {
+				Person pFound = rxCBTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString()).block();
+				assertNull(pFound, "Should NOT have found " + pFound);
+				return;
+			}
+			e.printStackTrace();
+		}
+		Person pFound = rxCBTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString()).block();
+		assertEquals("Walt", pFound.getFirstname(), "firstname should be Walt");
+		// throw new RuntimeException("Should have been a TransactionFailedException exception with a cause of PoofException");
+	}
+
+	@Test
+	public void insertPersonRbTemplate() {
+		Person person = new Person(1, "Walter", "White");
+		remove(rxCBTmpl, cName, person.getId().toString());
+
+		CouchbaseTransactionalOperator txOperator = new CouchbaseTransactionalOperator(reactiveCouchbaseTransactionManager);
+		Mono<TransactionResult> result = txOperator.reactive((ctx) -> ctx.template(rxCBTmpl).insertById(Person.class)
+				.one(person).flatMap(p -> ctx.template(rxCBTmpl).replaceById(Person.class).one(p.withFirstName("Walt")))
+				.flatMap(it -> Mono.error(new SimulateFailureException())).then());
+
+		try {
+			result.block();
+		} catch (TransactionFailedException e) {
+			if (e.getCause() instanceof SimulateFailureException) {
+				Person pFound = rxCBTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString()).block();
+				assertNull(pFound, "Should NOT have found " + pFound);
+				return;
+			}
+			e.printStackTrace();
+		}
+		// Person pFound = rxCBTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString()).block();
+		// assertEquals("Walt", pFound.getFirstname(), "firstname should be Walt");
+		throw new RuntimeException("Should have been a TransactionFailedException exception with a cause of "+SimulateFailureException.class);
+	}
+
+	@Test
+	public void replacePersonRbRepo() {
+		Person person = new Person(1, "Walter", "White");
+		remove(rxCBTmpl, cName, person.getId().toString());
+		rxRepo.withCollection(cName).save(person).block();
+
+		CouchbaseTransactionalOperator txOperator = new CouchbaseTransactionalOperator(reactiveCouchbaseTransactionManager);
+		Mono<TransactionResult> result = txOperator
+				.reactive((ctx) -> ctx.repository(rxRepo).withCollection(cName).findById(person.getId().toString())
+						.flatMap(p -> ctx.repository(rxRepo).withCollection(cName).save(p.withFirstName("Walt")))
+						.flatMap(it -> Mono.error(new SimulateFailureException())).then());
+
+		try {
+			result.block();
+		} catch (TransactionFailedException e) {
+			if (e.getCause() instanceof SimulateFailureException) {
+				Person pFound = rxRepo.withCollection(cName).findById(person.getId().toString()).block();
+				assertEquals(person, pFound, "Should have found " + person);
+				return;
+			}
+			e.printStackTrace();
+		}
+		// Person pFound = rxRepo.withCollection(cName).findById(person.getId().toString()).block();
+		// assertEquals("Walt", pFound.getFirstname(), "firstname should be Walt");
+		throw new RuntimeException("Should have been a TransactionFailedException exception with a cause of PoofException");
+	}
+
+	@Test
+	public void insertPersonRbRepo() {
+		Person person = new Person(1, "Walter", "White");
+		remove(rxCBTmpl, cName, person.getId().toString());
+
+		CouchbaseTransactionalOperator txOperator = new CouchbaseTransactionalOperator(reactiveCouchbaseTransactionManager);
+		Mono<TransactionResult> result = txOperator
+				.reactive((ctx) -> ctx.repository(rxRepo).withTransaction(txOperator).withCollection(cName).save(person) // insert
+						//.flatMap(p -> ctx.repository(rxRepo).withCollection(cName).save(p.withFirstName("Walt"))) // replace
+						.flatMap(it -> Mono.error(new SimulateFailureException())).then());
+
+		try {
+			result.block();
+		} catch (TransactionFailedException e) {
+			if (e.getCause() instanceof SimulateFailureException) {
+				Person pFound = rxRepo.withCollection(cName).findById(person.getId().toString()).block();
+				assertNull(pFound, "Should NOT have found " + pFound);
+				return;
+			}
+			e.printStackTrace();
+		}
+		// Person pFound = rxRepo.withCollection(cName).findById(person.getId().toString()).block();
+		// assertEquals("Walt", pFound.getFirstname(), "firstname should be Walt");
+		throw new RuntimeException("Should have been a TransactionFailedException exception with a cause of PoofException");
+	}
+
+	@Test
+	public void insertPersonRepo() {
+		Person person = new Person(1, "Walter", "White");
+		remove(rxCBTmpl, cName, person.getId().toString());
+
+		CouchbaseTransactionalOperator txOperator = new CouchbaseTransactionalOperator(reactiveCouchbaseTransactionManager);
+		Mono<TransactionResult> result = txOperator
+				.reactive((ctx) -> ctx.repository(rxRepo).withCollection(cName).save(person) // insert
+						.flatMap(p -> ctx.repository(rxRepo).withCollection(cName).save(p.withFirstName("Walt"))) // replace
+						// .flatMap(it -> Mono.error(new PoofException()))
+						.then());
+
+		try {
+			result.block();
+		} catch (TransactionFailedException e) {
+			if (e.getCause() instanceof SimulateFailureException) {
+				Person pFound = rxRepo.withCollection(cName).findById(person.getId().toString()).block();
+				assertNull(pFound, "Should NOT have found " + pFound);
+				return;
+			}
+			e.printStackTrace();
+		}
+		Person pFound = rxRepo.withCollection(cName).findById(person.getId().toString()).block();
+		assertEquals("Walt", pFound.getFirstname(), "firstname should be Walt");
+		// throw new RuntimeException("Should have been a TransactionFailedException exception with a cause of PoofException");
+	}
+
+	/*
+	@Test
+	public void replacePersonRbSpringTransactional() {
+		Person person = new Person(1, "Walter", "White");
+		remove(rxCBTmpl, cName, person.getId().toString());
+		rxCBTmpl.insertById(Person.class).inCollection(cName).one(person).block();
+
+
+				TransactionalOperator txOperator = TransactionalOperator.create(reactiveCouchbaseTransactionManager);
+		Mono<TransactionResult> result = txOperator.reactive((ctx) -> {
+			ctx.transactionResultHolder(123);
+			return ctx.template(rxCBTmpl).findById(Person.class).one(person.getId().toString())
+					.flatMap(p -> ctx.template(rxCBTmpl).replaceById(Person.class).one(p.withFirstName("Walt")))
+					.as(txOperator::transactional).then();
+		}, false);
+
+		//TransactionalOperator txOperator = TransactionalOperator.create(reactiveCouchbaseTransactionManager, new CouchbaseTransactionDefinition());
+		//Mono<TransactionResult> result = txOperator.reactive((ctx) -> {
+		//	ctx.transactionResultHolder(123);
+		//	return ctx.template(rxCBTmpl).findById(Person.class).one(person.getId().toString())
+		//			.flatMap(p -> ctx.template(rxCBTmpl).replaceById(Person.class).one(p.withFirstName("Walt")))
+		//			.as(txOperator::transactional).then();
+		//}, false);
+
+		try {
+			result.block();
+		} catch (TransactionFailedException e) {
+			if (e.getCause() instanceof PoofException) {
+				Person pFound = rxCBTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString()).block();
+				assertEquals(person, pFound, "Should have found " + person);
+				return;
+			}
+			e.printStackTrace();
+		}
+		Person pFound = rxCBTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString()).block();
+		assertEquals("Walt", pFound.getFirstname(), "firstname should be Walt");
+		// throw new RuntimeException("Should have been a TransactionFailedException exception with a cause of PoofException");
+	}
+*/
+	@Test
+	public void findReplacePersonCBTransactionsRxTmpl() {
+		Person person = new Person(1, "Walter", "White");
+		remove(rxCBTmpl, cName, person.getId().toString());
+		rxCBTmpl.insertById(Person.class).inCollection(cName).one(person).block();
+		CouchbaseTransactionalOperator txOperator = new CouchbaseTransactionalOperator(reactiveCouchbaseTransactionManager);
+		Mono<TransactionResult> result = txOperator.reactive(ctx -> {
+			rxCBTmpl.support().getTxResultHolder(person);
+			return rxCBTmpl.findById(Person.class).inCollection(cName).transaction(txOperator).one(person.getId().toString())
+					.flatMap(pGet -> rxCBTmpl.replaceById(Person.class).inCollection(cName).transaction(txOperator)
+							.one(pGet.withFirstName("Walt")))
+					.then();
+		});
+		result.block();
+		Person pFound = rxCBTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString()).block();
+		assertEquals(person.withFirstName("Walt"), pFound, "Should have found Walt");
+	}
+
+	@Test
+	public void insertReplacePersonsCBTransactionsRxTmpl() {
+		Person person = new Person(1, "Walter", "White");
+		remove(rxCBTmpl, cName, person.getId().toString());
+
+		CouchbaseTransactionalOperator txOperator = new CouchbaseTransactionalOperator(reactiveCouchbaseTransactionManager);
+		Mono<TransactionResult> result = txOperator.reactive((ctx) -> {
+			return rxCBTmpl
+					.insertById(Person.class).inCollection(cName).transaction(txOperator).one(person).flatMap(pInsert -> rxCBTmpl
+							.replaceById(Person.class).inCollection(cName).transaction(txOperator).one(pInsert.withFirstName("Walt")))
+					.then();
+		});
+
+		result.block();
+		Person pFound = rxCBTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString()).block();
+		assertEquals(person.withFirstName("Walt"), pFound, "Should have found Walt");
+	}
+
+	@Test void transactionalSavePerson(){
+		Person person = new Person(1, "Walter", "White");
+		remove(rxCBTmpl, cName, person.getId().toString());
+		savePerson(person).block();
+		Person pFound = rxCBTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString()).block();
+		assertEquals(person, pFound, "Should have found "+person);
+	}
+
+	public Mono<Person> savePerson(Person person) {
+
+		TransactionalOperator transactionalOperator = TransactionalOperator.create(reactiveCouchbaseTransactionManager);
+		return operations.save(person) //
+				.flatMap(Mono::just) //
+				.as(transactionalOperator::transactional);
+	}
+
+	void remove(Collection col, String id) {
+		remove(col.reactive(), id);
+	}
+
+	void remove(ReactiveCollection col, String id) {
+		try {
+			col.remove(id, RemoveOptions.removeOptions().timeout(Duration.ofSeconds(10))).block();
+		} catch (DocumentNotFoundException nfe) {
+			System.out.println(id + " : " + "DocumentNotFound when deleting");
+		}
+	}
+
+	void remove(CouchbaseTemplate template, String collection, String id) {
+		remove(template.reactive(), collection, id);
+	}
+
+	void remove(ReactiveCouchbaseTemplate template, String collection, String id) {
+		try {
+			template.removeById(Person.class).inCollection(collection).one(id).block();
+			System.out.println("removed " + id);
+		} catch (DocumentNotFoundException | DataRetrievalFailureException nfe) {
+			System.out.println(id + " : " + "DocumentNotFound when deleting");
+		}
+	}
+
+	@Configuration
+	@EnableCouchbaseRepositories("org.springframework.data.couchbase")
+	@EnableReactiveCouchbaseRepositories("org.springframework.data.couchbase")
+	static class Config extends AbstractCouchbaseConfiguration {
+
+		@Override
+		public String getConnectionString() {
+			return connectionString();
+		}
+
+		@Override
+		public String getUserName() {
+			return config().adminUsername();
+		}
+
+		@Override
+		public String getPassword() {
+			return config().adminPassword();
+		}
+
+		@Override
+		public String getBucketName() {
+			return bucketName();
+		}
+	}
+
+}
diff --git a/src/test/java/org/springframework/data/couchbase/transactions/CouchbaseTemplateTransactionIntegrationTests.java b/src/test/java/org/springframework/data/couchbase/transactions/CouchbaseTemplateTransactionIntegrationTests.java
new file mode 100644
index 00000000..72d91e07
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/transactions/CouchbaseTemplateTransactionIntegrationTests.java
@@ -0,0 +1,210 @@
+/*
+ * Copyright 2018-2021 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.springframework.data.couchbase.transactions;
+
+import static com.couchbase.client.java.query.QueryScanConsistency.REQUEST_PLUS;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.springframework.data.couchbase.util.Util.assertInAnnotationTransaction;
+
+import com.couchbase.client.core.error.DocumentNotFoundException;
+import com.example.demo.CouchbaseTransactionalTemplate;
+import lombok.AllArgsConstructor;
+import lombok.Data;
+
+import java.time.Duration;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Disabled;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.dao.DataRetrievalFailureException;
+import org.springframework.data.annotation.Id;
+import org.springframework.data.couchbase.CouchbaseClientFactory;
+import org.springframework.data.couchbase.config.AbstractCouchbaseConfiguration;
+import org.springframework.data.couchbase.config.BeanNames;
+import org.springframework.data.couchbase.core.CouchbaseTemplate;
+import org.springframework.data.couchbase.core.mapping.Document;
+import org.springframework.data.couchbase.repository.config.EnableCouchbaseRepositories;
+import org.springframework.data.couchbase.repository.config.EnableReactiveCouchbaseRepositories;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionManager;
+import org.springframework.data.couchbase.util.Capabilities;
+import org.springframework.data.couchbase.util.ClusterType;
+import org.springframework.data.couchbase.util.IgnoreWhen;
+import org.springframework.data.couchbase.util.JavaIntegrationTests;
+import org.springframework.data.domain.Persistable;
+import org.springframework.test.annotation.Rollback;
+import org.springframework.test.context.ContextConfiguration;
+import org.springframework.test.context.junit.jupiter.SpringExtension;
+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
+import org.springframework.test.context.transaction.AfterTransaction;
+import org.springframework.test.context.transaction.BeforeTransaction;
+import org.springframework.test.context.transaction.TestTransaction;
+import org.springframework.transaction.annotation.EnableTransactionManagement;
+import org.springframework.transaction.annotation.Transactional;
+
+import com.couchbase.client.core.cnc.Event;
+//import com.example.demo.CouchbaseTransactionManager;
+//import com.example.demo.CouchbaseTransactionalTemplate;
+
+/**
+ * @author Christoph Strobl
+ * @currentRead Shadow's Edge - Brent Weeks
+ */
+
+//@ContextConfiguration
+@ExtendWith({ SpringExtension.class })
+@IgnoreWhen(missesCapabilities = Capabilities.QUERY, clusterTypes = ClusterType.MOCKED)
+@Transactional(transactionManager = BeanNames.COUCHBASE_SIMPLE_CALLBACK_TRANSACTION_MANAGER)
+@SpringJUnitConfig(CouchbaseTemplateTransactionIntegrationTests.Config.class)
+public class CouchbaseTemplateTransactionIntegrationTests extends JavaIntegrationTests {
+
+	static final String DB_NAME = "template-tx-tests";
+	static final String COLLECTION_NAME = "assassins";
+
+	@Configuration
+	@EnableCouchbaseRepositories("org.springframework.data.couchbase")
+	@EnableReactiveCouchbaseRepositories("org.springframework.data.couchbase")
+	@EnableTransactionManagement
+	static class Config extends AbstractCouchbaseConfiguration {
+
+		@Override
+		public String getConnectionString() {
+			return connectionString();
+		}
+
+		@Override
+		public String getUserName() {
+			return config().adminUsername();
+		}
+
+		@Override
+		public String getPassword() {
+			return config().adminPassword();
+		}
+
+		@Override
+		public String getBucketName() {
+			return bucketName();
+		}
+
+		@Bean
+		public CouchbaseTransactionManager transactionManager(@Autowired CouchbaseClientFactory template) {
+			return new CouchbaseTransactionManager(template, null);
+		}
+
+		//@Bean
+		//public CouchbaseTransactionalTemplate transactionalTemplate(CouchbaseTransactionManager manager) {
+		//	return manager.template();
+		//}
+
+	}
+
+	@Autowired CouchbaseTemplate template;
+
+	List<AfterTransactionAssertion<? extends Persistable<?>>> assertionList;
+
+	@BeforeEach
+	public void setUp() {
+		assertionList = new CopyOnWriteArrayList<>();
+	}
+
+	@BeforeTransaction
+	public void beforeTransaction() {
+		template.removeByQuery(Assassin.class).withConsistency(REQUEST_PLUS).all();
+		Collection<Assassin> a = template.findByQuery(Assassin.class).withConsistency(REQUEST_PLUS).all();
+	}
+
+	@AfterTransaction
+	public void verifyDbState() {
+		Collection<Assassin> p = template.findByQuery(Assassin.class).withConsistency(REQUEST_PLUS).all();
+		System.out.println("assassins: " + p);
+		assertionList.forEach(it -> {
+
+			boolean isPresent = template.findById(Assassin.class).one(it.getId().toString()) != null; // (Filters.eq("_id",
+			// it.getId())) != 0;
+
+			assertThat(isPresent).isEqualTo(it.shouldBePresent())
+					.withFailMessage(String.format("After transaction entity %s should %s.", it.getPersistable(),
+							it.shouldBePresent() ? "be present" : "NOT be present"));
+		});
+	}
+
+	@Test
+	@Rollback(false)
+	@Transactional(transactionManager = BeanNames.COUCHBASE_TRANSACTION_MANAGER)
+	public void shouldOperateCommitCorrectly() {
+		assert(TestTransaction.isActive());
+		Assassin hu = new Assassin("hu", "Hu Gibbet");
+		template.insertById(Assassin.class).one(hu);
+		assertAfterTransaction(hu).isPresent();
+	}
+
+	@Test
+	@Disabled // JCBC-1951 - run it twice second time fails.  Recreate bucket, it succeeds
+	@Rollback(true)
+	@Transactional(transactionManager = BeanNames.COUCHBASE_TRANSACTION_MANAGER)
+	public void shouldOperateRollbackCorrectly() {
+		assert(TestTransaction.isActive());
+		Assassin vi = new Assassin("vi", "Viridiana Sovari");
+		try {
+			template.removeById(Assassin.class).one(vi.getId()); // could be something that is not an Assassin
+		} catch (DataRetrievalFailureException dnfe) {}
+		template.insertById(Assassin.class).one(vi);
+		assertAfterTransaction(vi).isNotPresent();
+	}
+
+	@Test
+	@Transactional(BeanNames.COUCHBASE_TRANSACTION_MANAGER)
+	@Disabled // JCBC-1951 - run it twice, second time fails. Recreate bucket, it succeeds
+	@Rollback(true)
+	public void shouldBeAbleToViewChangesDuringTransaction(){
+		assert(TestTransaction.isActive());
+		Assassin durzo = new Assassin("durzo", "Durzo Blint");
+		template.insertById(Assassin.class).one(durzo);
+		Assassin retrieved = template.findById(Assassin.class).one(durzo.getId());
+		assertThat(retrieved).isEqualTo(durzo);
+		assertAfterTransaction(durzo).isNotPresent();
+	}
+
+	// --- Just some helpers and tests entities
+
+	private AfterTransactionAssertion assertAfterTransaction(Assassin assassin) {
+		assertInAnnotationTransaction(false);
+		AfterTransactionAssertion<Assassin> assertion = new AfterTransactionAssertion<>(assassin);
+		assertionList.add(assertion);
+		return assertion;
+	}
+
+	@Data
+	@AllArgsConstructor
+	@Document
+	static class Assassin implements Persistable<String> {
+
+		@Id String id;
+		String name;
+
+		@Override
+		public boolean isNew() {
+			return id == null;
+		}
+	}
+}
diff --git a/src/test/java/org/springframework/data/couchbase/transactions/CouchbaseTransactionNativeTests.java b/src/test/java/org/springframework/data/couchbase/transactions/CouchbaseTransactionNativeTests.java
new file mode 100644
index 00000000..640b0c8c
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/transactions/CouchbaseTransactionNativeTests.java
@@ -0,0 +1,266 @@
+/*
+ * Copyright 2012-2021 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.data.couchbase.transactions;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNull;
+
+import reactor.core.publisher.Mono;
+
+import java.time.Duration;
+import java.util.Optional;
+
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.dao.DataRetrievalFailureException;
+import org.springframework.data.couchbase.CouchbaseClientFactory;
+import org.springframework.data.couchbase.config.AbstractCouchbaseConfiguration;
+import org.springframework.data.couchbase.core.CouchbaseTemplate;
+import org.springframework.data.couchbase.core.ReactiveCouchbaseTemplate;
+import org.springframework.data.couchbase.domain.Person;
+import org.springframework.data.couchbase.domain.PersonRepository;
+import org.springframework.data.couchbase.domain.ReactivePersonRepository;
+import org.springframework.data.couchbase.repository.config.EnableCouchbaseRepositories;
+import org.springframework.data.couchbase.repository.config.EnableReactiveCouchbaseRepositories;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionManager;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionalOperator;
+import org.springframework.data.couchbase.transaction.ReactiveCouchbaseTransactionManager;
+import org.springframework.data.couchbase.util.Capabilities;
+import org.springframework.data.couchbase.util.ClusterType;
+import org.springframework.data.couchbase.util.IgnoreWhen;
+import org.springframework.data.couchbase.util.JavaIntegrationTests;
+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
+
+import com.couchbase.client.core.error.DocumentNotFoundException;
+import com.couchbase.client.java.Collection;
+import com.couchbase.client.java.ReactiveCollection;
+import com.couchbase.client.java.kv.RemoveOptions;
+import com.couchbase.client.java.transactions.error.TransactionFailedException;
+
+/**
+ * Tests for com.couchbase.transactions without using the spring data transactions framework
+ *
+ * @author Michael Reiche
+ */
+@IgnoreWhen(missesCapabilities = Capabilities.QUERY, clusterTypes = ClusterType.MOCKED)
+@SpringJUnitConfig(CouchbaseTransactionNativeTests.Config.class)
+public class CouchbaseTransactionNativeTests extends JavaIntegrationTests {
+
+	// @Autowired not supported on static fields. These are initialized in beforeAll()
+	// Also - @Autowired doesn't work here on couchbaseClientFactory even when it is not static, not sure why - oh, it
+	// seems there is not a ReactiveCouchbaseClientFactory bean
+	@Autowired CouchbaseClientFactory couchbaseClientFactory;
+	@Autowired CouchbaseTransactionManager couchbaseTransactionManager;
+
+	@Autowired ReactiveCouchbaseTransactionManager reactiveCouchbaseTransactionManager;
+
+	@Autowired PersonRepository repo;
+	@Autowired ReactivePersonRepository repoRx;
+	@Autowired CouchbaseTemplate cbTmpl;;
+	static String cName; // short name
+
+	@BeforeAll
+	public static void beforeAll() {
+		callSuperBeforeAll(new Object() {});
+		// short names
+		cName = null;// cName;
+	}
+
+	@AfterAll
+	public static void afterAll() {
+		callSuperAfterAll(new Object() {});
+	}
+
+	@Test
+	public void replacePersonTemplate() {
+		Person person = new Person(1, "Walter", "White");
+		remove(cbTmpl, cName, person.getId().toString());
+		cbTmpl.insertById(Person.class).inCollection(cName).one(person);
+
+		CouchbaseTransactionalOperator txOperator = new CouchbaseTransactionalOperator(reactiveCouchbaseTransactionManager);
+
+		assertThrowsWithCause(() -> txOperator.run((ctx) -> {
+			Person p = txOperator.template(cbTmpl.reactive()).findById(Person.class).one(person.getId().toString()).block();
+			Person pp = txOperator.template(cbTmpl.reactive()).replaceById(Person.class).one(p.withFirstName("Walt")).block();
+			throw new PoofException();
+		}), TransactionFailedException.class, PoofException.class);
+
+		Person pFound = cbTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString());
+		assertEquals("Walter", pFound.getFirstname(), "firstname should be Walter");
+
+	}
+
+	@Test
+	public void replacePersonRbTemplate() {
+		Person person = new Person(1, "Walter", "White");
+		remove(cbTmpl, cName, person.getId().toString());
+		cbTmpl.insertById(Person.class).inCollection(cName).one(person);
+		CouchbaseTransactionalOperator txOperator = new CouchbaseTransactionalOperator(reactiveCouchbaseTransactionManager);
+		assertThrowsWithCause(() -> txOperator.run((ctx) -> {
+			Person p = ctx.template(cbTmpl.reactive()).findById(Person.class).one(person.getId().toString()).block();
+			Person pp = ctx.template(cbTmpl.reactive()).replaceById(Person.class).one(p.withFirstName("Walt")).block();
+			throw new PoofException();
+		}), TransactionFailedException.class, PoofException.class);
+		Person pFound = cbTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString());
+		assertEquals("Walter", pFound.getFirstname(), "firstname should be Walter");
+
+	}
+
+	@Test
+	public void insertPersonTemplate() {
+		Person person = new Person(1, "Walter", "White");
+		remove(cbTmpl, cName, person.getId().toString());
+		CouchbaseTransactionalOperator txOperator = new CouchbaseTransactionalOperator(reactiveCouchbaseTransactionManager);
+		txOperator.reactive((ctx) -> ctx.template(cbTmpl.reactive()).insertById(Person.class).one(person)
+				.flatMap(p -> ctx.template(cbTmpl.reactive()).replaceById(Person.class).one(p.withFirstName("Walt"))).then())
+				.block();
+		Person pFound = cbTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString());
+		assertEquals("Walt", pFound.getFirstname(), "firstname should be Walt");
+	}
+
+	@Test
+	public void insertPersonRbTemplate() {
+		Person person = new Person(1, "Walter", "White");
+		remove(cbTmpl, cName, person.getId().toString());
+		CouchbaseTransactionalOperator txOperator = new CouchbaseTransactionalOperator(reactiveCouchbaseTransactionManager);
+		assertThrowsWithCause(
+				() -> txOperator.reactive((ctx) -> ctx.template(cbTmpl.reactive()).insertById(Person.class).one(person)
+						.flatMap(p -> ctx.template(cbTmpl.reactive()).replaceById(Person.class).one(p.withFirstName("Walt")))
+						.flatMap(it -> Mono.error(new PoofException()))).block(),
+				TransactionFailedException.class, PoofException.class);
+
+		Person pFound = cbTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString());
+		assertNull(pFound, "Should NOT have found " + pFound);
+	}
+
+	@Test
+	public void replacePersonRbRepo() {
+		Person person = new Person(1, "Walter", "White");
+		remove(cbTmpl, cName, person.getId().toString());
+		repo.withCollection(cName).save(person);
+
+		CouchbaseTransactionalOperator txOperator = new CouchbaseTransactionalOperator(reactiveCouchbaseTransactionManager);
+		assertThrowsWithCause(() -> txOperator.run(ctx -> {
+			ctx.repository(repoRx).withCollection(cName).findById(person.getId().toString())
+					.flatMap(p -> ctx.repository(repoRx).withCollection(cName).save(p.withFirstName("Walt")));
+			throw new PoofException();
+		}), TransactionFailedException.class, PoofException.class);
+
+		Person pFound = cbTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString());
+		assertEquals(person, pFound, "Should have found " + person);
+	}
+
+	@Test
+	public void insertPersonRbRepo() {
+		Person person = new Person(1, "Walter", "White");
+		remove(cbTmpl, cName, person.getId().toString());
+		CouchbaseTransactionalOperator txOperator = new CouchbaseTransactionalOperator(reactiveCouchbaseTransactionManager);
+		assertThrowsWithCause(() -> txOperator.reactive((ctx) -> ctx.repository(repoRx).withCollection(cName).save(person) // insert
+				.flatMap(p -> ctx.repository(repoRx).withCollection(cName).save(p.withFirstName("Walt"))) // replace
+				.flatMap(it -> Mono.error(new PoofException()))).block(), TransactionFailedException.class,
+				PoofException.class);
+
+		Person pFound = cbTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString());
+		assertNull(pFound, "Should NOT have found " + pFound);
+	}
+
+	@Test
+	public void insertPersonRepo() {
+		Person person = new Person(1, "Walter", "White");
+		remove(cbTmpl, cName, person.getId().toString());
+		CouchbaseTransactionalOperator txOperator = new CouchbaseTransactionalOperator(reactiveCouchbaseTransactionManager);
+		txOperator.reactive((ctx) -> ctx.repository(repoRx).withCollection(cName).save(person) // insert
+				.flatMap(p -> ctx.repository(repoRx).withCollection(cName).save(p.withFirstName("Walt"))) // replace
+				.then()).block();
+		Optional<Person> pFound = repo.withCollection(cName).findById(person.getId().toString());
+		assertEquals("Walt", pFound.get().getFirstname(), "firstname should be Walt");
+	}
+
+	@Test
+	public void replacePersonRbSpringTransactional() {
+		Person person = new Person(1, "Walter", "White");
+		remove(cbTmpl, cName, person.getId().toString());
+		cbTmpl.insertById(Person.class).inCollection(cName).one(person);
+		CouchbaseTransactionalOperator txOperator = new CouchbaseTransactionalOperator(reactiveCouchbaseTransactionManager);
+		assertThrowsWithCause(
+				() -> txOperator
+						.reactive((ctx) -> ctx.template(cbTmpl.reactive()).findById(Person.class).one(person.getId().toString())
+								.flatMap(p -> ctx.template(cbTmpl.reactive()).replaceById(Person.class).one(p.withFirstName("Walt")))
+								.flatMap(it -> Mono.error(new PoofException())))
+						.block(),
+				TransactionFailedException.class, PoofException.class);
+		Person pFound = cbTmpl.findById(Person.class).inCollection(cName).one(person.getId().toString());
+		assertEquals("Walter", pFound.getFirstname(), "firstname should be Walter");
+	}
+
+	void remove(Collection col, String id) {
+		remove(col.reactive(), id);
+	}
+
+	void remove(ReactiveCollection col, String id) {
+		try {
+			col.remove(id, RemoveOptions.removeOptions().timeout(Duration.ofSeconds(10)));
+		} catch (DocumentNotFoundException nfe) {
+			System.out.println(id + " : " + "DocumentNotFound when deleting");
+		}
+	}
+
+	void remove(CouchbaseTemplate template, String collection, String id) {
+		remove(template.reactive(), collection, id);
+	}
+
+	void remove(ReactiveCouchbaseTemplate template, String collection, String id) {
+		try {
+			template.removeById(Person.class).inCollection(collection).one(id).block();
+			System.out.println("removed " + id);
+		} catch (DocumentNotFoundException | DataRetrievalFailureException nfe) {
+			System.out.println(id + " : " + "DocumentNotFound when deleting");
+		}
+	}
+
+	static class PoofException extends RuntimeException {};
+
+	@Configuration
+	@EnableCouchbaseRepositories("org.springframework.data.couchbase")
+	@EnableReactiveCouchbaseRepositories("org.springframework.data.couchbase")
+	static class Config extends AbstractCouchbaseConfiguration {
+
+		@Override
+		public String getConnectionString() {
+			return connectionString();
+		}
+
+		@Override
+		public String getUserName() {
+			return config().adminUsername();
+		}
+
+		@Override
+		public String getPassword() {
+			return config().adminPassword();
+		}
+
+		@Override
+		public String getBucketName() {
+			return bucketName();
+		}
+
+	}
+}
diff --git a/src/test/java/org/springframework/data/couchbase/transactions/CouchbaseTransactionalIntegrationTests.java b/src/test/java/org/springframework/data/couchbase/transactions/CouchbaseTransactionalIntegrationTests.java
new file mode 100644
index 00000000..cee3a1fb
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/transactions/CouchbaseTransactionalIntegrationTests.java
@@ -0,0 +1,497 @@
+/*
+ * Copyright 2012-2021 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.data.couchbase.transactions;
+
+import com.couchbase.client.java.transactions.error.TransactionFailedException;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Disabled;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.annotation.AnnotationConfigApplicationContext;
+import org.springframework.context.support.GenericApplicationContext;
+import org.springframework.data.couchbase.CouchbaseClientFactory;
+import org.springframework.data.couchbase.config.BeanNames;
+import org.springframework.data.couchbase.core.CouchbaseOperations;
+import org.springframework.data.couchbase.core.CouchbaseTemplate;
+import org.springframework.data.couchbase.core.ReactiveCouchbaseOperations;
+import org.springframework.data.couchbase.domain.Person;
+import org.springframework.data.couchbase.domain.PersonWithoutVersion;
+import org.springframework.data.couchbase.transaction.CouchbaseSimpleCallbackTransactionManager;
+import org.springframework.data.couchbase.util.Capabilities;
+import org.springframework.data.couchbase.util.ClusterType;
+import org.springframework.data.couchbase.util.IgnoreWhen;
+import org.springframework.data.couchbase.util.JavaIntegrationTests;
+import org.springframework.stereotype.Component;
+import org.springframework.stereotype.Service;
+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
+import org.springframework.transaction.annotation.EnableTransactionManagement;
+import org.springframework.transaction.annotation.Transactional;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Function;
+
+import static com.couchbase.client.java.query.QueryScanConsistency.REQUEST_PLUS;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotEquals;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.fail;
+
+/**
+ * Tests for @Transactional.
+ */
+@IgnoreWhen(missesCapabilities = Capabilities.QUERY, clusterTypes = ClusterType.MOCKED)
+@SpringJUnitConfig(Config.class)
+public class CouchbaseTransactionalIntegrationTests extends JavaIntegrationTests {
+
+	@Autowired CouchbaseClientFactory couchbaseClientFactory;
+	/* DO NOT @Autowired - it will result in no @Transactional annotation behavior */ PersonService personService;
+	@Autowired CouchbaseTemplate operations;
+
+	static GenericApplicationContext context;
+
+	@BeforeAll
+	public static void beforeAll() {
+		callSuperBeforeAll(new Object() {});
+		context = new AnnotationConfigApplicationContext(Config.class, PersonService.class);
+	}
+
+	@AfterAll
+	public static void afterAll() {
+		callSuperAfterAll(new Object() {});
+	}
+
+	@BeforeEach
+	public void beforeEachTest() {
+		personService = context.getBean(PersonService.class); // getting it via autowired results in no @Transactional
+		// Skip this as we just one to track TransactionContext
+		operations.removeByQuery(Person.class).withConsistency(REQUEST_PLUS).all(); // doesn't work???
+		List<Person> p = operations.findByQuery(Person.class).withConsistency(REQUEST_PLUS).all();
+
+		Person walterWhite = new Person(1, "Walter", "White");
+		try {
+			couchbaseClientFactory.getBucket().defaultCollection().remove(walterWhite.getId().toString());
+		} catch (Exception ex) {
+			// System.err.println(ex);
+		}
+	}
+
+	@DisplayName("A basic golden path insert should succeed")
+	@Test
+	public void committedInsert() {
+		AtomicInteger tryCount = new AtomicInteger(0);
+
+		Person inserted = personService.doInTransaction(tryCount, (ops) -> {
+			Person person = new Person(1, "Walter", "White");
+			ops.insertById(Person.class).one(person);
+			return person;
+		});
+
+		Person fetched = operations.findById(Person.class).one(inserted.getId().toString());
+		assertEquals("Walter", fetched.getFirstname());
+		assertEquals(1, tryCount.get());
+	}
+
+	@DisplayName("A basic golden path replace should succeed")
+	@Test
+	public void committedReplace() {
+		AtomicInteger tryCount = new AtomicInteger(0);
+		Person person = new Person(1, "Walter", "White");
+		operations.insertById(Person.class).one(person);
+
+		personService.fetchAndReplace(person.getId().toString(), tryCount, (p) -> {
+			p.setFirstname("changed");
+			return p;
+		});
+
+		Person fetched = operations.findById(Person.class).one(person.getId().toString());
+		assertEquals("changed", fetched.getFirstname());
+		assertEquals(1, tryCount.get());
+	}
+
+	@DisplayName("A basic golden path remove should succeed")
+	@Test
+	public void committedRemove() {
+		AtomicInteger tryCount = new AtomicInteger(0);
+		Person person = new Person(1, "Walter", "White");
+		operations.insertById(Person.class).one(person);
+
+		personService.fetchAndRemove(person.getId().toString(), tryCount);
+
+		Person fetched = operations.findById(Person.class).one(person.getId().toString());
+		assertNull(fetched);
+		assertEquals(1, tryCount.get());
+	}
+
+	@DisplayName("Basic test of doing an insert then rolling back")
+	@Test
+	public void rollbackInsert() {
+		AtomicInteger tryCount = new AtomicInteger(0);
+		AtomicReference<String> id = new AtomicReference<>();
+
+		try {
+			personService.doInTransaction(tryCount, (ops) -> {
+				Person person = new Person(1, "Walter", "White");
+				ops.insertById(Person.class).one(person);
+				id.set(person.getId().toString());
+				throw new SimulateFailureException();
+			});
+			fail();
+		}
+		catch (TransactionFailedException err) {
+			assertTrue(err.getCause() instanceof SimulateFailureException);
+		}
+
+		Person fetched = operations.findById(Person.class).one(id.get());
+		assertNull(fetched);
+		assertEquals(1, tryCount.get());
+	}
+
+	@DisplayName("Basic test of doing a replace then rolling back")
+	@Test
+	public void rollbackReplace() {
+		AtomicInteger tryCount = new AtomicInteger(0);
+		Person person = new Person(1, "Walter", "White");
+		operations.insertById(Person.class).one(person);
+
+		try {
+			personService.doInTransaction(tryCount, (ops) -> {
+				Person p = ops.findById(Person.class).one(person.getId().toString());
+				p.setFirstname("changed");
+				ops.replaceById(Person.class).one(p);
+				throw new SimulateFailureException();
+			});
+			fail();
+		}
+		catch (TransactionFailedException err) {
+			assertTrue(err.getCause() instanceof SimulateFailureException);
+		}
+
+		Person fetched = operations.findById(Person.class).one(person.getId().toString());
+		assertEquals("Walter", fetched.getFirstname());
+		assertEquals(1, tryCount.get());
+	}
+
+	@DisplayName("Basic test of doing a remove then rolling back")
+	@Test
+	public void rollbackRemove() {
+		AtomicInteger tryCount = new AtomicInteger(0);
+		Person person = new Person(1, "Walter", "White");
+		operations.insertById(Person.class).one(person);
+
+		try {
+			personService.doInTransaction(tryCount, (ops) -> {
+				Person p = ops.findById(Person.class).one(person.getId().toString());
+				ops.removeById(Person.class).oneEntity(p);
+				throw new SimulateFailureException();
+			});
+			fail();
+		}
+		catch (TransactionFailedException err) {
+			assertTrue(err.getCause() instanceof SimulateFailureException);
+		}
+
+		Person fetched = operations.findById(Person.class).one(person.getId().toString());
+		assertNotNull(fetched);
+		assertEquals(1, tryCount.get());
+	}
+
+	@Test
+	public void shouldRollbackAfterException() {
+		try {
+			personService.insertThenThrow();
+			fail();
+		}
+		catch (TransactionFailedException err) {
+			assertTrue(err.getCause() instanceof SimulateFailureException);
+		}
+
+		Long count = operations.findByQuery(Person.class).withConsistency(REQUEST_PLUS).count();
+		assertEquals(0, count, "should have done roll back and left 0 entries");
+	}
+
+	@Test
+	public void commitShouldPersistTxEntries() {
+		Person p = new Person(null, "Walter", "White");
+		Person s = personService.declarativeSavePerson(p);
+		Long count = operations.findByQuery(Person.class).withConsistency(REQUEST_PLUS).count();
+		assertEquals(1, count, "should have saved and found 1");
+	}
+
+	@Disabled("because hanging - requires JCBC-1955 fix")
+	@Test
+	public void concurrentTxns() {
+		Runnable r = () -> {
+			Thread t = Thread.currentThread();
+			System.out.printf("Started thread %d %s%n", t.getId(), t.getName());
+			Person p = new Person(null, "Walter", "White");
+			Person s = personService.declarativeSavePersonWithThread(p, t);
+			System.out.printf("Finished thread %d %s%n", t.getId(), t.getName());
+		};
+		List<Thread> threads = new ArrayList<>();
+		for (int i = 0; i < 99; i ++) {
+			Thread t = new Thread(r);
+			t.start();
+			threads.add(t);
+		}
+		threads.forEach(t -> {
+			try {
+				System.out.printf("Waiting for thread %d %s%n", t.getId(), t.getName());
+				t.join();
+				System.out.printf("Finished waiting for thread %d %s%n", t.getId(), t.getName());
+			} catch (InterruptedException e) {
+				fail();
+			}
+		});
+	}
+
+	// todo gpx investigate how @Transactional @Rollback/@Commit interacts with us
+	// todo gpx how to provide per-transaction options?
+	// todo gpx verify we aren't in a transactional context after the transaction ends (success or failure)
+
+	@Disabled("taking too long - must fix")
+	@DisplayName("Create a Person outside a @Transactional block, modify it, and then replace that person in the @Transactional.  The transaction will retry until timeout.")
+	@Test
+	public void replacePerson() {
+		Person person = new Person(1, "Walter", "White");
+		operations.insertById(Person.class).one(person);
+
+		System.out.printf("insert  CAS: %s%n", person.getVersion());
+
+		Person refetched = operations.findById(Person.class).one(person.getId().toString());
+		operations.replaceById(Person.class).one(refetched);
+
+		System.out.printf("replace CAS: %s%n", refetched.getVersion());
+
+		assertNotEquals(person.getVersion(), refetched.getVersion());
+
+		AtomicInteger tryCount = new AtomicInteger(0);
+		// todo gpx this is raising incorrect error:
+		// com.couchbase.client.core.retry.reactor.RetryExhaustedException: com.couchbase.client.core.error.transaction.RetryTransactionException: User request to retry transaction
+		personService.replace(person, tryCount);
+	}
+
+
+	@DisplayName("Entity must have CAS field during replace")
+	@Test
+	public void replaceEntityWithoutCas() {
+		PersonWithoutVersion person = new PersonWithoutVersion(1, "Walter", "White");
+		operations.insertById(PersonWithoutVersion.class).one(person);
+		try {
+			personService.replaceEntityWithoutVersion(person.getId().toString());
+		}
+		catch (TransactionFailedException err) {
+			assertTrue(err.getCause() instanceof IllegalArgumentException);
+		}
+	}
+
+	@DisplayName("Entity must have non-zero CAS during replace")
+	@Test
+	public void replaceEntityWithCasZero() {
+		Person person = new Person(1, "Walter", "White");
+		operations.insertById(Person.class).one(person);
+
+		// switchedPerson here will have CAS=0, which will fail
+		Person switchedPerson = new Person(1, "Dave", "Reynolds");
+		AtomicInteger tryCount = new AtomicInteger(0);
+
+		try {
+			personService.replacePerson(switchedPerson, tryCount);
+		}
+		catch (TransactionFailedException err) {
+			assertTrue(err.getCause() instanceof IllegalArgumentException);
+		}
+	}
+
+	@DisplayName("Entity must have CAS field during remove")
+	@Test
+	public void removeEntityWithoutCas() {
+		PersonWithoutVersion person = new PersonWithoutVersion(1, "Walter", "White");
+		operations.insertById(PersonWithoutVersion.class).one(person);
+		try {
+			personService.removeEntityWithoutVersion(person.getId().toString());
+		}
+		catch (TransactionFailedException err) {
+			assertTrue(err.getCause() instanceof IllegalArgumentException);
+		}
+	}
+
+	@DisplayName("removeById().one(id) isn't allowed in transactions, since we don't have the CAS")
+	@Test
+	public void removeEntityById() {
+		AtomicInteger tryCount = new AtomicInteger(0);
+		Person person = new Person(1, "Walter", "White");
+		operations.insertById(Person.class).one(person);
+
+		try {
+            personService.doInTransaction(tryCount, (ops) -> {
+                Person p = ops.findById(Person.class).one(person.getId().toString());
+                ops.removeById(Person.class).one(p.getId().toString());
+                return p;
+            });
+            fail();
+        }
+		catch (TransactionFailedException err) {
+			assertTrue(err.getCause() instanceof IllegalArgumentException);
+		}
+	}
+
+	@Service
+	@Component
+	@EnableTransactionManagement
+	static
+	class PersonService {
+		final CouchbaseOperations personOperations;
+		final ReactiveCouchbaseOperations personOperationsRx;
+
+		public PersonService(CouchbaseOperations ops, ReactiveCouchbaseOperations opsRx) {
+			personOperations = ops;
+			personOperationsRx = opsRx;
+		}
+
+		@Transactional(transactionManager = BeanNames.COUCHBASE_SIMPLE_CALLBACK_TRANSACTION_MANAGER)
+		public Person declarativeSavePerson(Person person) {
+			assertInAnnotationTransaction(true);
+			long currentThreadId = Thread.currentThread().getId();
+			System.out.println(String.format("Thread %d %s", Thread.currentThread().getId(), Thread.currentThread().getName()));
+			Person ret = personOperations.insertById(Person.class).one(person);
+			System.out.println(String.format("Thread %d (was %d) %s", Thread.currentThread().getId(), currentThreadId, Thread.currentThread().getName()));
+			if (currentThreadId != Thread.currentThread().getId()) {
+				throw new IllegalStateException();
+			}
+			return ret;
+		}
+
+		@Transactional(transactionManager = BeanNames.COUCHBASE_SIMPLE_CALLBACK_TRANSACTION_MANAGER)
+		public Person declarativeSavePersonWithThread(Person person, Thread thread) {
+			assertInAnnotationTransaction(true);
+			long currentThreadId = Thread.currentThread().getId();
+			System.out.printf("Thread %d %s, started from %d %s%n", Thread.currentThread().getId(), Thread.currentThread().getName(), thread.getId(), thread.getName());
+			Person ret = personOperations.insertById(Person.class).one(person);
+			System.out.printf("Thread %d (was %d) %s, started from %d %s%n", Thread.currentThread().getId(), currentThreadId, Thread.currentThread().getName(), thread.getId(), thread.getName());
+			if (currentThreadId != Thread.currentThread().getId()) {
+				throw new IllegalStateException();
+			}
+			return ret;
+		}
+
+		@Transactional(transactionManager = BeanNames.COUCHBASE_SIMPLE_CALLBACK_TRANSACTION_MANAGER)
+		public void insertThenThrow() {
+			Person person = new Person(null, "Walter", "White");
+			assertInAnnotationTransaction(true);
+			personOperations.insertById(Person.class).one(person);
+			SimulateFailureException.throwEx();
+		}
+
+		@Autowired CouchbaseSimpleCallbackTransactionManager callbackTm;
+
+		/**
+		 * to execute while ThreadReplaceloop() is running should force a retry
+		 *
+		 * @param person
+		 * @return
+		 */
+		@Transactional(transactionManager = BeanNames.COUCHBASE_SIMPLE_CALLBACK_TRANSACTION_MANAGER)
+		public Person replacePerson(Person person, AtomicInteger tryCount) {
+			tryCount.incrementAndGet();
+			// Note that passing in a Person and replace it in this way, is not supported
+			return personOperations.replaceById(Person.class).one(person);
+		}
+
+		@Transactional(transactionManager = BeanNames.COUCHBASE_SIMPLE_CALLBACK_TRANSACTION_MANAGER)
+		public void replaceEntityWithoutVersion(String id) {
+			PersonWithoutVersion fetched = personOperations.findById(PersonWithoutVersion.class).one(id);
+			personOperations.replaceById(PersonWithoutVersion.class).one(fetched);
+		}
+
+		@Transactional(transactionManager = BeanNames.COUCHBASE_SIMPLE_CALLBACK_TRANSACTION_MANAGER)
+		public void removeEntityWithoutVersion(String id) {
+			PersonWithoutVersion fetched = personOperations.findById(PersonWithoutVersion.class).one(id);
+			personOperations.removeById(PersonWithoutVersion.class).oneEntity(fetched);
+		}
+
+		@Transactional(transactionManager = BeanNames.COUCHBASE_SIMPLE_CALLBACK_TRANSACTION_MANAGER)
+		public Person declarativeFindReplaceTwicePersonCallback(Person person, AtomicInteger tryCount) {
+			assertInAnnotationTransaction(true);
+			System.err.println("declarativeFindReplacePersonCallback try: " + tryCount.incrementAndGet());
+//			System.err.println("declarativeFindReplacePersonCallback cluster : "
+//					+ callbackTm.template().getCouchbaseClientFactory().getCluster().block());
+//			System.err.println("declarativeFindReplacePersonCallback resourceHolder : "
+//					+ org.springframework.transaction.support.TransactionSynchronizationManager
+//							.getResource(callbackTm.template().getCouchbaseClientFactory().getCluster().block()));
+			Person p = personOperations.findById(Person.class).one(person.getId().toString());
+			Person pUpdated = personOperations.replaceById(Person.class).one(p);
+			return personOperations.replaceById(Person.class).one(pUpdated);
+		}
+
+
+		// todo gpx how do we make COUCHBASE_SIMPLE_CALLBACK_TRANSACTION_MANAGER the default so user only has to specify @Transactional, without the transactionManager?
+		@Transactional(transactionManager = BeanNames.COUCHBASE_SIMPLE_CALLBACK_TRANSACTION_MANAGER)
+		public Person replace(Person person, AtomicInteger tryCount) {
+			assertInAnnotationTransaction(true);
+			tryCount.incrementAndGet();
+			return personOperations.replaceById(Person.class).one(person);
+		}
+
+		@Transactional(transactionManager = BeanNames.COUCHBASE_SIMPLE_CALLBACK_TRANSACTION_MANAGER)
+		public Person fetchAndReplace(String id, AtomicInteger tryCount, Function<Person, Person> callback) {
+			assertInAnnotationTransaction(true);
+			tryCount.incrementAndGet();
+			Person p = personOperations.findById(Person.class).one(id);
+			Person modified = callback.apply(p);
+			return personOperations.replaceById(Person.class).one(modified);
+		}
+
+		@Transactional(transactionManager = BeanNames.COUCHBASE_SIMPLE_CALLBACK_TRANSACTION_MANAGER)
+		public <T> T doInTransaction(AtomicInteger tryCount, Function<CouchbaseOperations, T> callback) {
+			assertInAnnotationTransaction(true);
+			tryCount.incrementAndGet();
+			return callback.apply(personOperations);
+		}
+
+		@Transactional(transactionManager = BeanNames.COUCHBASE_SIMPLE_CALLBACK_TRANSACTION_MANAGER)
+		public void fetchAndRemove(String id, AtomicInteger tryCount) {
+			assertInAnnotationTransaction(true);
+			tryCount.incrementAndGet();
+			Person p = personOperations.findById(Person.class).one(id);
+			personOperations.removeById(Person.class).oneEntity(p);
+		}
+	}
+
+	static void assertInAnnotationTransaction(boolean inTransaction) {
+		StackTraceElement[] stack = Thread.currentThread().getStackTrace();
+		for (StackTraceElement ste : stack) {
+			if (ste.getClassName().startsWith("org.springframework.transaction.interceptor")) {
+				if (inTransaction) {
+					return;
+				}
+			}
+		}
+		if (!inTransaction) {
+			return;
+		}
+		throw new RuntimeException(
+				"in transaction = " + (!inTransaction) + " but expected in annotation transaction = " + inTransaction);
+	}
+}
diff --git a/src/test/java/org/springframework/data/couchbase/transactions/CouchbaseTransactionalNonAllowableOperationsIntegrationTests.java b/src/test/java/org/springframework/data/couchbase/transactions/CouchbaseTransactionalNonAllowableOperationsIntegrationTests.java
new file mode 100644
index 00000000..fc0fcda2
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/transactions/CouchbaseTransactionalNonAllowableOperationsIntegrationTests.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright 2012-2022 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.data.couchbase.transactions;
+
+import com.couchbase.client.java.transactions.error.TransactionFailedException;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.annotation.AnnotationConfigApplicationContext;
+import org.springframework.context.support.GenericApplicationContext;
+import org.springframework.data.couchbase.CouchbaseClientFactory;
+import org.springframework.data.couchbase.config.BeanNames;
+import org.springframework.data.couchbase.core.CouchbaseOperations;
+import org.springframework.data.couchbase.domain.Person;
+import org.springframework.data.couchbase.util.Capabilities;
+import org.springframework.data.couchbase.util.ClusterType;
+import org.springframework.data.couchbase.util.IgnoreWhen;
+import org.springframework.data.couchbase.util.JavaIntegrationTests;
+import org.springframework.stereotype.Component;
+import org.springframework.stereotype.Service;
+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
+import org.springframework.transaction.annotation.EnableTransactionManagement;
+import org.springframework.transaction.annotation.Transactional;
+
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Consumer;
+import java.util.function.Function;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.fail;
+
+/**
+ * Tests for @Transactional methods, where operations that aren't supported in a transaction are being used.
+ * They should be prevented at runtime.
+ */
+@IgnoreWhen(missesCapabilities = Capabilities.QUERY, clusterTypes = ClusterType.MOCKED)
+@SpringJUnitConfig(Config.class)
+public class CouchbaseTransactionalNonAllowableOperationsIntegrationTests extends JavaIntegrationTests {
+
+	@Autowired CouchbaseClientFactory couchbaseClientFactory;
+	PersonService personService;
+	static GenericApplicationContext context;
+
+	@BeforeAll
+	public static void beforeAll() {
+		callSuperBeforeAll(new Object() {});
+		context = new AnnotationConfigApplicationContext(Config.class, PersonService.class);
+	}
+
+	@BeforeEach
+	public void beforeEachTest() {
+		personService = context.getBean(PersonService.class);
+
+		Person walterWhite = new Person(1, "Walter", "White");
+		try {
+			couchbaseClientFactory.getBucket().defaultCollection().remove(walterWhite.getId().toString());
+		} catch (Exception ex) {
+			// System.err.println(ex);
+		}
+	}
+
+	void test(Consumer<CouchbaseOperations> r) {
+		AtomicInteger tryCount = new AtomicInteger(0);
+
+		try {
+			personService.doInTransaction(tryCount, (ops) -> {
+				r.accept(ops);
+				return null;
+			});
+			fail("Transaction should not succeed");
+		}
+		catch (TransactionFailedException err) {
+			assertTrue(err.getCause() instanceof IllegalArgumentException);
+		}
+
+		assertEquals(1, tryCount.get());
+	}
+
+	@DisplayName("Using existsById() in a transaction is rejected at runtime")
+	@Test
+	public void existsById() {
+		test((ops) -> {
+			Person person = new Person(1, "Walter", "White");
+			ops.existsById(Person.class).one(person.getId().toString());
+		});
+	}
+
+	@DisplayName("Using findByAnalytics() in a transaction is rejected at runtime")
+	@Test
+	public void findByAnalytics() {
+		test((ops) -> {
+			ops.findByAnalytics(Person.class).one();
+		});
+	}
+
+	@DisplayName("Using findFromReplicasById() in a transaction is rejected at runtime")
+	@Test
+	public void findFromReplicasById() {
+		test((ops) -> {
+			Person person = new Person(1, "Walter", "White");
+			ops.findFromReplicasById(Person.class).any(person.getId().toString());
+		});
+	}
+
+	@DisplayName("Using upsertById() in a transaction is rejected at runtime")
+	@Test
+	public void upsertById() {
+		test((ops) -> {
+			Person person = new Person(1, "Walter", "White");
+			ops.upsertById(Person.class).one(person);
+		});
+	}
+
+	@Service
+	@Component
+	@EnableTransactionManagement
+	static
+	class PersonService {
+		final CouchbaseOperations personOperations;
+
+		public PersonService(CouchbaseOperations ops) {
+			personOperations = ops;
+		}
+
+		@Transactional(transactionManager = BeanNames.COUCHBASE_SIMPLE_CALLBACK_TRANSACTION_MANAGER)
+		public <T> T doInTransaction(AtomicInteger tryCount, Function<CouchbaseOperations, T> callback) {
+			tryCount.incrementAndGet();
+			return callback.apply(personOperations);
+		}
+	}
+}
diff --git a/src/test/java/org/springframework/data/couchbase/transactions/CouchbaseTransactionalOptionsIntegrationTests.java b/src/test/java/org/springframework/data/couchbase/transactions/CouchbaseTransactionalOptionsIntegrationTests.java
new file mode 100644
index 00000000..62941e8c
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/transactions/CouchbaseTransactionalOptionsIntegrationTests.java
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2012-2022 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.data.couchbase.transactions;
+
+import com.couchbase.client.java.transactions.error.TransactionFailedException;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.annotation.AnnotationConfigApplicationContext;
+import org.springframework.context.support.GenericApplicationContext;
+import org.springframework.data.couchbase.CouchbaseClientFactory;
+import org.springframework.data.couchbase.config.BeanNames;
+import org.springframework.data.couchbase.core.CouchbaseOperations;
+import org.springframework.data.couchbase.core.CouchbaseTemplate;
+import org.springframework.data.couchbase.domain.Person;
+import org.springframework.data.couchbase.util.ClusterType;
+import org.springframework.data.couchbase.util.IgnoreWhen;
+import org.springframework.data.couchbase.util.JavaIntegrationTests;
+import org.springframework.stereotype.Component;
+import org.springframework.stereotype.Service;
+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
+import org.springframework.transaction.annotation.EnableTransactionManagement;
+import org.springframework.transaction.annotation.Isolation;
+import org.springframework.transaction.annotation.Transactional;
+
+import java.time.Duration;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Function;
+
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.fail;
+
+/**
+ * Tests for @Transactional methods, setting all the various options allowed by @Transactional.
+ */
+@IgnoreWhen(clusterTypes = ClusterType.MOCKED)
+@SpringJUnitConfig(Config.class)
+public class CouchbaseTransactionalOptionsIntegrationTests extends JavaIntegrationTests {
+
+	@Autowired CouchbaseClientFactory couchbaseClientFactory;
+	PersonService personService;
+	@Autowired
+	CouchbaseTemplate operations;
+	static GenericApplicationContext context;
+
+	@BeforeAll
+	public static void beforeAll() {
+		callSuperBeforeAll(new Object() {});
+		context = new AnnotationConfigApplicationContext(Config.class, PersonService.class);
+	}
+
+	@BeforeEach
+	public void beforeEachTest() {
+		personService = context.getBean(PersonService.class);
+
+		Person walterWhite = new Person(1, "Walter", "White");
+		try {
+			couchbaseClientFactory.getBucket().defaultCollection().remove(walterWhite.getId().toString());
+		} catch (Exception ex) {
+			// System.err.println(ex);
+		}
+	}
+
+	@DisplayName("@Transactional(timeout = 2) will timeout at around 2 seconds")
+	@Test
+	public void timeout() {
+		long start = System.nanoTime();
+		Person person = new Person(1, "Walter", "White");
+		operations.insertById(Person.class).one(person);
+		try {
+			personService.timeout(person.getId().toString());
+			fail();
+		}
+		catch (TransactionFailedException err) {
+		}
+		Duration timeTaken = Duration.ofNanos(System.nanoTime() - start);
+		assertTrue(timeTaken.toMillis() >= 2000);
+		assertTrue(timeTaken.toMillis() < 10_000);  // Default transaction timeout is 15s
+	}
+
+	@DisplayName("@Transactional(isolation = Isolation.ANYTHING_BUT_READ_COMMITTED) will fail")
+	@Test
+	public void unsupportedIsolation() {
+		try {
+			personService.unsupportedIsolation();
+			fail();
+		}
+		catch (IllegalArgumentException err) {
+		}
+	}
+
+	@DisplayName("@Transactional(isolation = Isolation.READ_COMMITTED) will succeed")
+	@Test
+	public void supportedIsolation() {
+		personService.supportedIsolation();
+	}
+
+	@Service
+	@Component
+	@EnableTransactionManagement
+	static
+	class PersonService {
+		final CouchbaseOperations ops;
+
+		public PersonService(CouchbaseOperations ops) {
+			this.ops = ops;
+		}
+
+		@Transactional(transactionManager = BeanNames.COUCHBASE_SIMPLE_CALLBACK_TRANSACTION_MANAGER)
+		public <T> T doInTransaction(AtomicInteger tryCount, Function<CouchbaseOperations, T> callback) {
+			tryCount.incrementAndGet();
+			return callback.apply(ops);
+		}
+
+		@Transactional(transactionManager = BeanNames.COUCHBASE_SIMPLE_CALLBACK_TRANSACTION_MANAGER, timeout = 2)
+		public void timeout(String id) {
+			while (true) {
+				Person p = ops.findById(Person.class).one(id);
+				ops.replaceById(Person.class).one(p);
+			}
+		}
+
+		@Transactional(transactionManager = BeanNames.COUCHBASE_SIMPLE_CALLBACK_TRANSACTION_MANAGER, isolation = Isolation.REPEATABLE_READ)
+		public void unsupportedIsolation() {
+		}
+
+		@Transactional(transactionManager = BeanNames.COUCHBASE_SIMPLE_CALLBACK_TRANSACTION_MANAGER, isolation = Isolation.READ_COMMITTED)
+		public void supportedIsolation() {
+		}
+	}
+}
diff --git a/src/test/java/org/springframework/data/couchbase/transactions/CouchbaseTransactionalUnsettableParametersIntegrationTests.java b/src/test/java/org/springframework/data/couchbase/transactions/CouchbaseTransactionalUnsettableParametersIntegrationTests.java
new file mode 100644
index 00000000..3aadd409
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/transactions/CouchbaseTransactionalUnsettableParametersIntegrationTests.java
@@ -0,0 +1,193 @@
+/*
+ * Copyright 2012-2022 the original author or authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *        https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.springframework.data.couchbase.transactions;
+
+import com.couchbase.client.java.kv.InsertOptions;
+import com.couchbase.client.java.kv.PersistTo;
+import com.couchbase.client.java.kv.RemoveOptions;
+import com.couchbase.client.java.kv.ReplaceOptions;
+import com.couchbase.client.java.kv.ReplicateTo;
+import com.couchbase.client.java.transactions.error.TransactionFailedException;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.context.annotation.AnnotationConfigApplicationContext;
+import org.springframework.context.support.GenericApplicationContext;
+import org.springframework.data.couchbase.CouchbaseClientFactory;
+import org.springframework.data.couchbase.config.BeanNames;
+import org.springframework.data.couchbase.core.CouchbaseOperations;
+import org.springframework.data.couchbase.core.CouchbaseTemplate;
+import org.springframework.data.couchbase.core.ReactiveCouchbaseTemplate;
+import org.springframework.data.couchbase.domain.Person;
+import org.springframework.data.couchbase.util.Capabilities;
+import org.springframework.data.couchbase.util.ClusterType;
+import org.springframework.data.couchbase.util.IgnoreWhen;
+import org.springframework.data.couchbase.util.JavaIntegrationTests;
+import org.springframework.stereotype.Component;
+import org.springframework.stereotype.Service;
+import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
+import org.springframework.transaction.annotation.EnableTransactionManagement;
+import org.springframework.transaction.annotation.Transactional;
+
+import java.time.Duration;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Consumer;
+import java.util.function.Function;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.fail;
+
+/**
+ * Tests for @Transactional methods, where parameters/options are being set that aren't support in a transaction.
+ * These will be rejected at runtime.
+ */
+@IgnoreWhen(missesCapabilities = Capabilities.QUERY, clusterTypes = ClusterType.MOCKED)
+@SpringJUnitConfig(Config.class)
+public class CouchbaseTransactionalUnsettableParametersIntegrationTests extends JavaIntegrationTests {
+
+	@Autowired CouchbaseClientFactory couchbaseClientFactory;
+	PersonService personService;
+	static GenericApplicationContext context;
+
+	@BeforeAll
+	public static void beforeAll() {
+		callSuperBeforeAll(new Object() {});
+		context = new AnnotationConfigApplicationContext(Config.class, PersonService.class);
+	}
+
+	@BeforeEach
+	public void beforeEachTest() {
+		personService = context.getBean(PersonService.class); // getting it via autowired results in no @Transactional
+
+		Person walterWhite = new Person(1, "Walter", "White");
+		try {
+			couchbaseClientFactory.getBucket().defaultCollection().remove(walterWhite.getId().toString());
+		} catch (Exception ex) {
+			// System.err.println(ex);
+		}
+	}
+
+	void test(Consumer<CouchbaseOperations> r) {
+		AtomicInteger tryCount = new AtomicInteger(0);
+
+		try {
+			personService.doInTransaction(tryCount, (ops) -> {
+				r.accept(ops);
+				return null;
+			});
+			fail("Transaction should not succeed");
+		}
+		catch (TransactionFailedException err) {
+			assertTrue(err.getCause() instanceof IllegalArgumentException);
+		}
+
+		assertEquals(1, tryCount.get());
+	}
+
+	@DisplayName("Using insertById().withDurability - the PersistTo overload - in a transaction is rejected at runtime")
+	@Test
+	public void insertWithDurability() {
+		test((ops) -> {
+			Person person = new Person(1, "Walter", "White");
+			ops.insertById(Person.class).withDurability(PersistTo.ONE, ReplicateTo.ONE).one(person);
+		});
+	}
+
+	@DisplayName("Using insertById().withExpiry in a transaction is rejected at runtime")
+	@Test
+	public void insertWithExpiry() {
+		test((ops) -> {
+			Person person = new Person(1, "Walter", "White");
+			ops.insertById(Person.class).withExpiry(Duration.ofSeconds(3)).one(person);
+		});
+	}
+
+	@DisplayName("Using insertById().withOptions in a transaction is rejected at runtime")
+	@Test
+	public void insertWithOptions() {
+		test((ops) -> {
+			Person person = new Person(1, "Walter", "White");
+			ops.insertById(Person.class).withOptions(InsertOptions.insertOptions()).one(person);
+		});
+	}
+
+	@DisplayName("Using replaceById().withDurability - the PersistTo overload - in a transaction is rejected at runtime")
+	@Test
+	public void replaceWithDurability() {
+		test((ops) -> {
+			Person person = new Person(1, "Walter", "White");
+			ops.replaceById(Person.class).withDurability(PersistTo.ONE, ReplicateTo.ONE).one(person);
+		});
+	}
+
+	@DisplayName("Using replaceById().withExpiry in a transaction is rejected at runtime")
+	@Test
+	public void replaceWithExpiry() {
+		test((ops) -> {
+			Person person = new Person(1, "Walter", "White");
+			ops.replaceById(Person.class).withExpiry(Duration.ofSeconds(3)).one(person);
+		});
+	}
+
+	@DisplayName("Using replaceById().withOptions in a transaction is rejected at runtime")
+	@Test
+	public void replaceWithOptions() {
+		test((ops) -> {
+			Person person = new Person(1, "Walter", "White");
+			ops.replaceById(Person.class).withOptions(ReplaceOptions.replaceOptions()).one(person);
+		});
+	}
+
+	@DisplayName("Using removeById().withDurability - the PersistTo overload - in a transaction is rejected at runtime")
+	@Test
+	public void removeWithDurability() {
+		test((ops) -> {
+			Person person = new Person(1, "Walter", "White");
+			ops.removeById(Person.class).withDurability(PersistTo.ONE, ReplicateTo.ONE).oneEntity(person);
+		});
+	}
+
+	@DisplayName("Using removeById().withOptions in a transaction is rejected at runtime")
+	@Test
+	public void removeWithOptions() {
+		test((ops) -> {
+			Person person = new Person(1, "Walter", "White");
+			ops.removeById(Person.class).withOptions(RemoveOptions.removeOptions()).oneEntity(person);
+		});
+	}
+
+	@Service
+	@Component
+	@EnableTransactionManagement
+	static
+	class PersonService {
+		final CouchbaseOperations personOperations;
+
+		public PersonService(CouchbaseOperations ops) {
+			personOperations = ops;
+		}
+
+		@Transactional(transactionManager = BeanNames.COUCHBASE_SIMPLE_CALLBACK_TRANSACTION_MANAGER)
+		public <T> T doInTransaction(AtomicInteger tryCount, Function<CouchbaseOperations, T> callback) {
+			tryCount.incrementAndGet();
+			return callback.apply(personOperations);
+		}
+	}
+}
diff --git a/src/test/java/org/springframework/data/couchbase/transactions/ObjectId.java b/src/test/java/org/springframework/data/couchbase/transactions/ObjectId.java
new file mode 100644
index 00000000..7588e0c8
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/transactions/ObjectId.java
@@ -0,0 +1,10 @@
+package org.springframework.data.couchbase.transactions;
+
+import java.util.UUID;
+
+public class ObjectId{
+  public ObjectId(){
+    id = UUID.randomUUID().toString();
+  }
+  String id;
+}
diff --git a/src/test/java/org/springframework/data/couchbase/transactions/SimulateFailureException.java b/src/test/java/org/springframework/data/couchbase/transactions/SimulateFailureException.java
new file mode 100644
index 00000000..44c68e92
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/transactions/SimulateFailureException.java
@@ -0,0 +1,15 @@
+package org.springframework.data.couchbase.transactions;
+
+class SimulateFailureException extends RuntimeException {
+
+  public SimulateFailureException(String... s){
+    super(s!= null && s.length > 0 ? s[0] : null);
+  }
+
+  public SimulateFailureException(){}
+
+  public static void throwEx(String... s){
+    throw new SimulateFailureException(s);
+  }
+
+}
diff --git a/src/test/java/org/springframework/data/couchbase/transactions/TransactionInterception.save b/src/test/java/org/springframework/data/couchbase/transactions/TransactionInterception.save
new file mode 100644
index 00000000..ca64011c
--- /dev/null
+++ b/src/test/java/org/springframework/data/couchbase/transactions/TransactionInterception.save
@@ -0,0 +1,51 @@
+package org.springframework.data.couchbase.transactions;
+
+import org.springframework.beans.factory.config.BeanDefinition;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.context.annotation.Role;
+import org.springframework.data.couchbase.transaction.CouchbaseTransactionManager;
+import org.springframework.data.couchbase.transaction.interceptor.CouchbaseTransactionInterceptor;
+import org.springframework.transaction.annotation.AnnotationTransactionAttributeSource;
+import org.springframework.transaction.config.TransactionManagementConfigUtils;
+import org.springframework.transaction.interceptor.BeanFactoryTransactionAttributeSourceAdvisor;
+import org.springframework.transaction.interceptor.TransactionAttributeSource;
+import org.springframework.transaction.interceptor.TransactionInterceptor;
+
+@Configuration(proxyBeanMethods = false)
+@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
+class TransactionInterception {
+
+  @Bean
+  @Role(BeanDefinition.ROLE_INFRASTRUCTURE)
+  public TransactionInterceptor transactionInterceptor(TransactionAttributeSource transactionAttributeSource,
+                                                       CouchbaseTransactionManager txManager) {
+    TransactionInterceptor interceptor = new CouchbaseTransactionInterceptor();
+    interceptor.setTransactionAttributeSource(transactionAttributeSource);
+    if (txManager != null) {
+      interceptor.setTransactionManager(txManager);
+    }
+    return interceptor;
+  }
+
+  @Bean
+  @Role(BeanDefinition.ROLE_INFRASTRUCTURE)
+  public TransactionAttributeSource transactionAttributeSource() {
+    return new AnnotationTransactionAttributeSource();
+  }
+
+  @Bean(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)
+  @Role(BeanDefinition.ROLE_INFRASTRUCTURE)
+  public BeanFactoryTransactionAttributeSourceAdvisor transactionAdvisor(
+      TransactionAttributeSource transactionAttributeSource, TransactionInterceptor transactionInterceptor) {
+
+    BeanFactoryTransactionAttributeSourceAdvisor advisor = new BeanFactoryTransactionAttributeSourceAdvisor();
+    advisor.setTransactionAttributeSource(transactionAttributeSource);
+    advisor.setAdvice(transactionInterceptor);
+    // if (this.enableTx != null) {
+    // advisor.setOrder(this.enableTx.<Integer>getNumber("order"));
+    // }
+    return advisor;
+  }
+
+}
diff --git a/src/test/java/org/springframework/data/couchbase/util/ClusterAwareIntegrationTests.java b/src/test/java/org/springframework/data/couchbase/util/ClusterAwareIntegrationTests.java
index 42fb74a6..5deab4ba 100644
--- a/src/test/java/org/springframework/data/couchbase/util/ClusterAwareIntegrationTests.java
+++ b/src/test/java/org/springframework/data/couchbase/util/ClusterAwareIntegrationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2012-2020 the original author or authors
+ * Copyright 2012-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,12 +19,20 @@ import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
+import java.time.Duration;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Optional;
 import java.util.Set;
 import java.util.stream.Collectors;
 
+import com.couchbase.client.core.deps.io.netty.handler.ssl.util.InsecureTrustManagerFactory;
+import com.couchbase.client.core.env.SecurityConfig;
+import com.couchbase.client.core.service.Service;
+import com.couchbase.client.java.ClusterOptions;
+import com.couchbase.client.java.env.ClusterEnvironment;
+import com.couchbase.client.java.transactions.config.TransactionsCleanupConfig;
+import com.couchbase.client.java.transactions.config.TransactionsConfig;
 import org.junit.jupiter.api.AfterAll;
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeAll;
@@ -51,20 +59,25 @@ import com.couchbase.client.java.manager.query.CreateQueryIndexOptions;
 public abstract class ClusterAwareIntegrationTests {
 
 	private static TestClusterConfig testClusterConfig;
-	private static final Logger LOGGER = LoggerFactory.getLogger(ClusterAwareIntegrationTests.class);
+	public static final Logger LOGGER = LoggerFactory.getLogger(ClusterAwareIntegrationTests.class);
 
 	@BeforeAll
 	static void setup(TestClusterConfig config) {
 		testClusterConfig = config;
-		try (CouchbaseClientFactory couchbaseClientFactory = new SimpleCouchbaseClientFactory(connectionString(),
-				authenticator(), bucketName())) {
-			couchbaseClientFactory.getCluster().queryIndexes().createPrimaryIndex(bucketName(),
-					CreatePrimaryQueryIndexOptions.createPrimaryQueryIndexOptions().ignoreIfExists(true));
+		// todo gp disabling cleanupLostAttempts to simplify output during development
+		ClusterEnvironment env = ClusterEnvironment.builder()
+				.transactionsConfig(TransactionsConfig.cleanupConfig(TransactionsCleanupConfig.cleanupLostAttempts(false)))
+				.build();
+		String connectString = connectionString();
+		try (CouchbaseClientFactory couchbaseClientFactory = new SimpleCouchbaseClientFactory(connectString,
+				authenticator(), bucketName(), null, env)) {
+			couchbaseClientFactory.getCluster().queryIndexes().createPrimaryIndex(bucketName(), CreatePrimaryQueryIndexOptions
+					.createPrimaryQueryIndexOptions().ignoreIfExists(true).timeout(Duration.ofSeconds(300)));
 			// this is for the N1qlJoin test
 			List<String> fieldList = new ArrayList<>();
 			fieldList.add("parentId");
 			couchbaseClientFactory.getCluster().queryIndexes().createIndex(bucketName(), "parent_idx", fieldList,
-					CreateQueryIndexOptions.createQueryIndexOptions().ignoreIfExists(true));
+					CreateQueryIndexOptions.createQueryIndexOptions().ignoreIfExists(true).timeout(Duration.ofSeconds(300)));
 			// .with("_class", "org.springframework.data.couchbase.domain.Address"));
 		} catch (IndexFailureException ife) {
 			LOGGER.warn("IndexFailureException occurred - ignoring: ", ife);
@@ -122,8 +135,10 @@ public abstract class ClusterAwareIntegrationTests {
 	}
 
 	protected static Set<SeedNode> seedNodes() {
-		return config().nodes().stream().map(cfg -> SeedNode.create(cfg.hostname(),
-				Optional.ofNullable(cfg.ports().get(Services.KV)), Optional.ofNullable(cfg.ports().get(Services.MANAGER))))
+		return config().nodes().stream()
+				.map(cfg -> SeedNode.create(cfg.hostname(),
+						Optional.ofNullable(cfg.ports().get(Services.KV)),
+						Optional.ofNullable(cfg.ports().get(Services.MANAGER))))
 				.collect(Collectors.toSet());
 	}
 
@@ -177,17 +192,14 @@ public abstract class ClusterAwareIntegrationTests {
 				Method[] methods = theClass.getMethods();
 				for (Method m : methods) {
 					annotation = m.getAnnotation(annotationClass);
-					if (annotation != null) {
 					if (annotation != null) {
 						m.invoke(null);
 						invokedSuper = m;
 					}
 				}
-				}
 				if (invokedSuper != null) { // called method is responsible for calling any super methods
 					return;
 				}
-
 			}
 
 		} catch (IllegalAccessException | InvocationTargetException e) {
diff --git a/src/test/java/org/springframework/data/couchbase/util/ClusterInvocationProvider.java b/src/test/java/org/springframework/data/couchbase/util/ClusterInvocationProvider.java
index e4d159f6..a32bb685 100644
--- a/src/test/java/org/springframework/data/couchbase/util/ClusterInvocationProvider.java
+++ b/src/test/java/org/springframework/data/couchbase/util/ClusterInvocationProvider.java
@@ -31,7 +31,6 @@ import org.junit.platform.commons.support.AnnotationSupport;
  * <p>
  * Note that the internals on what and how the containers are managed is up to the {@link TestCluster} implementation,
  * and if it is unmanaged than this very well be mostly a "stub".
- * </p>
  *
  * @since 2.0.0
  */
diff --git a/src/test/java/org/springframework/data/couchbase/util/CollectionAwareIntegrationTests.java b/src/test/java/org/springframework/data/couchbase/util/CollectionAwareIntegrationTests.java
index fb54b55d..bbb4c3fa 100644
--- a/src/test/java/org/springframework/data/couchbase/util/CollectionAwareIntegrationTests.java
+++ b/src/test/java/org/springframework/data/couchbase/util/CollectionAwareIntegrationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2021 the original author or authors
+ * Copyright 2021-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,8 +19,8 @@ import static org.springframework.data.couchbase.config.BeanNames.COUCHBASE_TEMP
 import static org.springframework.data.couchbase.config.BeanNames.REACTIVE_COUCHBASE_TEMPLATE;
 
 import java.time.Duration;
-import java.util.HashSet;
-import java.util.Set;
+import java.util.ArrayList;
+import java.util.List;
 
 import org.junit.jupiter.api.AfterAll;
 import org.junit.jupiter.api.BeforeAll;
@@ -30,14 +30,13 @@ import org.springframework.data.couchbase.core.CouchbaseTemplate;
 import org.springframework.data.couchbase.core.ReactiveCouchbaseTemplate;
 import org.springframework.data.couchbase.domain.Config;
 
+import com.couchbase.client.core.error.IndexExistsException;
 import com.couchbase.client.core.service.ServiceType;
 import com.couchbase.client.java.Bucket;
 import com.couchbase.client.java.Cluster;
 import com.couchbase.client.java.ClusterOptions;
 import com.couchbase.client.java.env.ClusterEnvironment;
 import com.couchbase.client.java.manager.collection.CollectionManager;
-import com.couchbase.client.java.manager.collection.CollectionSpec;
-import com.couchbase.client.java.manager.collection.ScopeSpec;
 
 /**
  * Provides Collection support for integration tests
@@ -49,6 +48,7 @@ public class CollectionAwareIntegrationTests extends JavaIntegrationTests {
 	public static String scopeName = "my_scope";// + randomString();
 	public static String otherScope = "other_scope";
 	public static String collectionName = "my_collection";// + randomString();
+	public static String collectionName2 = "my_collection2";// + randomString();
 	public static String otherCollection = "other_collection";// + randomString();
 
 	@BeforeAll
@@ -64,11 +64,25 @@ public class CollectionAwareIntegrationTests extends JavaIntegrationTests {
 		CollectionManager collectionManager = bucket.collections();
 
 		setupScopeCollection(cluster, scopeName, collectionName, collectionManager);
+		setupScopeCollection(cluster, scopeName, collectionName2, collectionManager);
+
 		if (otherScope != null || otherCollection != null) {
 			// afterAll should be undoing the creation of scope etc
 			setupScopeCollection(cluster, otherScope, otherCollection, collectionManager);
 		}
 
+		try {
+			// needs an index for this N1ql Join
+			// create index ix2 on my_bucket(parent_id) where `_class` = 'org.springframework.data.couchbase.domain.Address';
+
+			List<String> fieldList = new ArrayList<>();
+			fieldList.add("parentId");
+			cluster.query("CREATE INDEX `parent_idx` ON default:`" + bucketName() + "`." + scopeName + "." + collectionName2
+					+ "(parentId)");
+		} catch (IndexExistsException ife) {
+			LOGGER.warn("IndexFailureException occurred - ignoring: ", ife.toString());
+		}
+
 		Config.setScopeName(scopeName);
 		ApplicationContext ac = new AnnotationConfigApplicationContext(Config.class);
 		// the Config class has been modified, these need to be loaded again
diff --git a/src/test/java/org/springframework/data/couchbase/util/JavaIntegrationTests.java b/src/test/java/org/springframework/data/couchbase/util/JavaIntegrationTests.java
index 5ba59248..e9149bf9 100644
--- a/src/test/java/org/springframework/data/couchbase/util/JavaIntegrationTests.java
+++ b/src/test/java/org/springframework/data/couchbase/util/JavaIntegrationTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020-2021 the original author or authors
+ * Copyright 2020-2022 the original author or authors
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -27,6 +27,12 @@ import static org.springframework.data.couchbase.config.BeanNames.COUCHBASE_TEMP
 import static org.springframework.data.couchbase.config.BeanNames.REACTIVE_COUCHBASE_TEMPLATE;
 import static org.springframework.data.couchbase.util.Util.waitUntilCondition;
 
+import okhttp3.Credentials;
+import okhttp3.FormBody;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
 import java.io.IOException;
 import java.time.Duration;
 import java.util.Collections;
@@ -39,9 +45,11 @@ import java.util.concurrent.TimeUnit;
 import java.util.function.Function;
 import java.util.function.Predicate;
 
-import com.couchbase.client.core.io.CollectionIdentifier;
 import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.Timeout;
+import org.junit.jupiter.api.function.Executable;
+import org.junit.platform.commons.util.UnrecoverableExceptions;
+import org.opentest4j.AssertionFailedError;
 import org.springframework.context.ApplicationContext;
 import org.springframework.context.annotation.AnnotationConfigApplicationContext;
 import org.springframework.data.couchbase.CouchbaseClientFactory;
@@ -60,6 +68,7 @@ import com.couchbase.client.core.error.ParsingFailureException;
 import com.couchbase.client.core.error.QueryException;
 import com.couchbase.client.core.error.ScopeNotFoundException;
 import com.couchbase.client.core.error.UnambiguousTimeoutException;
+import com.couchbase.client.core.io.CollectionIdentifier;
 import com.couchbase.client.core.json.Mapper;
 import com.couchbase.client.core.service.ServiceType;
 import com.couchbase.client.java.Bucket;
@@ -105,9 +114,9 @@ public class JavaIntegrationTests extends ClusterAwareIntegrationTests {
 		} catch (IOException ioe) {
 			throw new RuntimeException(ioe);
 		}
-		ApplicationContext ac = new AnnotationConfigApplicationContext(Config.class);
-		couchbaseTemplate = (CouchbaseTemplate) ac.getBean(COUCHBASE_TEMPLATE);
-		reactiveCouchbaseTemplate = (ReactiveCouchbaseTemplate) ac.getBean(REACTIVE_COUCHBASE_TEMPLATE);
+		//ApplicationContext ac = new AnnotationConfigApplicationContext(Config.class);
+		//couchbaseTemplate = (CouchbaseTemplate) ac.getBean(COUCHBASE_TEMPLATE);
+		//reactiveCouchbaseTemplate = (ReactiveCouchbaseTemplate) ac.getBean(REACTIVE_COUCHBASE_TEMPLATE);
 	}
 
 	/**
@@ -201,7 +210,7 @@ public class JavaIntegrationTests extends ClusterAwareIntegrationTests {
 
 			if (!ready) {
 				try {
-					Thread.sleep(50);
+					Thread.sleep(100);
 				} catch (InterruptedException e) {}
 			}
 		}
@@ -370,4 +379,47 @@ public class JavaIntegrationTests extends ClusterAwareIntegrationTests {
 			Thread.sleep(ms);
 		} catch (InterruptedException ie) {}
 	}
+
+	public static Throwable assertThrowsOneOf(Executable executable, Class<?>... expectedTypes) {
+
+		try {
+			executable.execute();
+		}
+		catch (Throwable actualException) {
+			for(Class<?> expectedType:expectedTypes){
+				if(actualException.getClass().isAssignableFrom( expectedType)){
+					return actualException;
+				}
+			}
+			UnrecoverableExceptions.rethrowIfUnrecoverable(actualException);
+			String message = "Unexpected exception type thrown "+actualException.getClass();
+			throw new AssertionFailedError(message, actualException);
+		}
+
+		String message ="Expected "+expectedTypes+" to be thrown, but nothing was thrown.";
+		throw new AssertionFailedError(message);
+	}
+
+	public static Throwable assertThrowsWithCause(Executable executable, Class<?>... expectedTypes) {
+		Class<?> nextExpectedException= null;
+		try {
+			executable.execute();
+		}
+		catch (Throwable actualException) {
+			for(Class<?> expectedType:expectedTypes){
+				nextExpectedException = expectedType;
+				if(actualException == null || !expectedType.isAssignableFrom( actualException.getClass())){
+					String message ="Expected "+nextExpectedException+" to be thrown/cause, but found "+actualException;
+					throw new AssertionFailedError(message, actualException);
+				}
+				actualException = actualException.getCause();
+			}
+			//UnrecoverableExceptions.rethrowIfUnrecoverable(actualException);
+			return actualException;
+		}
+
+		String message ="Expected "+expectedTypes[0]+" to be thrown, but nothing was thrown.";
+		throw new AssertionFailedError(message);
+	}
+
 }
diff --git a/src/test/java/org/springframework/data/couchbase/util/TestCluster.java b/src/test/java/org/springframework/data/couchbase/util/TestCluster.java
index 776283df..0ec98b39 100644
--- a/src/test/java/org/springframework/data/couchbase/util/TestCluster.java
+++ b/src/test/java/org/springframework/data/couchbase/util/TestCluster.java
@@ -16,7 +16,7 @@
 
 package org.springframework.data.couchbase.util;
 
-import static java.nio.charset.StandardCharsets.*;
+import static java.nio.charset.StandardCharsets.UTF_8;
 
 import java.io.IOException;
 import java.net.URL;
@@ -83,7 +83,7 @@ abstract class TestCluster implements ExtensionContext.Store.CloseableResource {
 				defaults.load(url.openStream());
 			}
 		} catch (Exception ex) {
-			throw new RuntimeException("Could not load properties", ex);
+			throw new RuntimeException("Could not load properties - maybe <packaging> is pom instead of jar?", ex);
 		}
 
 		Properties all = new Properties(System.getProperties());
diff --git a/src/test/java/org/springframework/data/couchbase/util/UnmanagedTestCluster.java b/src/test/java/org/springframework/data/couchbase/util/UnmanagedTestCluster.java
index 1eda812a..d7769364 100644
--- a/src/test/java/org/springframework/data/couchbase/util/UnmanagedTestCluster.java
+++ b/src/test/java/org/springframework/data/couchbase/util/UnmanagedTestCluster.java
@@ -60,7 +60,7 @@ public class UnmanagedTestCluster extends TestCluster {
 
 	@Override
 	TestClusterConfig _start() throws Exception {
-		bucketname = UUID.randomUUID().toString();
+		bucketname = "my_bucket"; //UUID.randomUUID().toString();
 
 		Response postResponse = httpClient
 				.newCall(new Request.Builder().header("Authorization", Credentials.basic(adminUsername, adminPassword))
diff --git a/src/test/java/org/springframework/data/couchbase/util/Util.java b/src/test/java/org/springframework/data/couchbase/util/Util.java
index f03c1348..6c6fea9a 100644
--- a/src/test/java/org/springframework/data/couchbase/util/Util.java
+++ b/src/test/java/org/springframework/data/couchbase/util/Util.java
@@ -33,7 +33,7 @@ public class Util {
    * Waits and sleeps for a little bit of time until the given condition is met.
    *
    * <p>Sleeps 1ms between "false" invocations. It will wait at most one minute to prevent hanging forever in case
-   * the condition never becomes true.</p>
+   * the condition never becomes true.
    *
    * @param supplier return true once it should stop waiting.
    */
@@ -83,7 +83,7 @@ public class Util {
    * Reads a file from the resources folder (in the same path as the requesting test class).
    *
    * <p>The class will be automatically loaded relative to the namespace and converted
-   * to a string.</p>
+   * to a string.
    *
    * @param filename the filename of the resource.
    * @param clazz    the reference class.
@@ -96,4 +96,25 @@ public class Util {
     return s.hasNext() ? s.next() : "";
   }
 
+  /**
+   * check if we are/are not in an @Transactional transaction
+   * @param inTransaction
+   */
+  public static void assertInAnnotationTransaction(boolean inTransaction) {
+    StackTraceElement[] stack = Thread.currentThread().getStackTrace();
+    for (StackTraceElement ste : stack) {
+      if (ste.getClassName().startsWith("org.springframework.transaction.interceptor")
+              || ste.getClassName().startsWith("org.springframework.data.couchbase.transaction.interceptor")) {
+        if (inTransaction) {
+          return;
+        }
+      }
+    }
+    if (!inTransaction) {
+      return;
+    }
+    throw new RuntimeException(
+            "in-annotation-transaction = " + (!inTransaction) + " but expected in-annotation-transaction = " + inTransaction);
+  }
+
 }
diff --git a/src/test/resources/integration.properties b/src/test/resources/integration.properties
index f097d05b..4a07e730 100644
--- a/src/test/resources/integration.properties
+++ b/src/test/resources/integration.properties
@@ -2,7 +2,7 @@
 # If set to false, it is assumed that the host is managing the cluster and
 # as a result no containers or anything will be spun up.
 # Options: containerized, mocked, unmanaged
-cluster.type=mocked
+cluster.type=unmanaged
 # Default configs for both cases
 cluster.adminUsername=Administrator
 cluster.adminPassword=password
diff --git a/src/test/resources/logback.xml b/src/test/resources/logback.xml
index 9d05fdc1..6efee2b3 100644
--- a/src/test/resources/logback.xml
+++ b/src/test/resources/logback.xml
@@ -27,5 +27,7 @@
     <logger name="org.springframework.data.couchbase.repository.query.SpatialViewQueryCreator" level="trace"/>
     <logger name="org.springframework.data.couchbase.repository.query.StringN1qlBasedQuery" level="trace"/>
     <logger name="org.springframework.data.couchbase.repository.support.IndexManager" level="debug"/>
+    <logger name="com.couchbase.transactions" level="debug"/>"
+    <logger name="org.springframework.data.couchbase.transaction" level="trace"/>
 
 </configuration>
